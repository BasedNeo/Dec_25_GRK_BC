audit of the marketplace system, based on the requested files plus the marketplace hooks/components that implement listing/buy/offer flows. I also ran read‑only “code_execution” checks where possible; RPC connectivity failed in this environment for on‑chain reads (details in Simulations).
1) Scope & Key Files Reviewed
Marketplace UI
client/src/pages/Marketplace.tsx (listing/search UI; uses useGuardians)
client/src/components/EscrowMarketplace.tsx (actual buy/sell/offer UI)
Marketplace Core Hooks
client/src/hooks/useMarketplace.ts (list/buy/offer/approve contract interactions)
client/src/hooks/useOffersV3.ts (off‑chain offers via EIP‑712 signatures + local storage)
client/src/hooks/useGuardians.ts (data source + listing overlay)
NFT Ownership
client/src/hooks/useOwnedNFTs.ts (tokensOfOwner + tokenURI fetch)
Wallets
client/src/lib/wagmi.ts (RainbowKit/Wagmi config)
client/src/components/Navbar.tsx (ConnectButton + deep link UX)
Server & Schema
server/routes.ts (only search/listings/metadata endpoints; no marketplace mutations)
shared/schema.ts (listings table only; no offers table)
2) Current Functionality (Observed from Code)
A) Listing / Selling
User flow: Listing is handled by useMarketplace.listNFT which calls listNFT on the marketplace contract after approval and a pre‑flight eth_call check for existing listing (client‑side only). This enforces a minimum price of 1 $BASED and checks approval state before listing.
UI entry points: The actual listing UI appears in EscrowMarketplace and NFT detail flows, not in Marketplace.tsx (the Marketplace page is a browse/search view only).
Escrow: Despite the “EscrowMarketplace” name, the V2 marketplace is approval‑based (NFT stays in wallet; “OpenSea‑style”) per hook comment; there is no escrow custody on listing. Any escrow behavior would be contract‑side, not in repo.
B) Offers
V2 on‑chain offers: useMarketplace.makeOffer uses a payable makeOffer call on the V2 contract (on‑chain). Offers can be accepted via acceptOffer.
V3 off‑chain offers: useOffersV3 creates EIP‑712 signed offers and stores them in local SecureStorage (not a backend). It can accept a signed offer on‑chain via acceptOffer and completePurchase on the V3 contract.
Important: these offers are not broadcast server‑side; they are local to the user’s browser unless another channel shares them.
C) Buying
Direct buy: useMarketplace.buyNFT calls buyNFT on‑chain with the price passed from the UI (the contract enforces correct price).
“Buy” on listings: UI uses listing info from useListing or useGuardians to render price and buying capabilities (e.g., in EscrowMarketplace and BuyButton).
D) Marketplace Data Sources
Marketplace page (Marketplace.tsx):
Calls useGuardians(false, true, ...) forcing CSV mode, not on‑chain listings from server or indexer. It overlays on‑chain listing status via fetchActiveListings() inside useGuardians but everything else is CSV/mock‑driven (search, pagination, traits, etc.).
EscrowMarketplace:
Directly queries the chain (ethers) for total minted tokens, token IDs, and active listings; does so repeatedly every 30s and for every token (O(n) calls). This will not scale for large supply / traffic.
E) Server Side
No marketplace mutation endpoints: server/routes.ts only contains metadata and search endpoints for listings/collections. There are no routes for listing creation, offer storage, accept, cancel, etc..
Schema: There is a listings table but no offers table, indicating offers and on‑chain listings are not persisted server‑side.
3) NFT Identification (Ownership & Metadata)
useOwnedNFTs uses tokensOfOwner + tokenURI on the NFT contract (non‑standard ERC‑721 extension). If the contract lacks tokensOfOwner, ownership fetching will fail and return error “Could not fetch owned tokens.” There’s no fallback to tokenOfOwnerByIndex or an indexer/provider API.
Metadata fetch:
Uses tokenURI when available, otherwise uses a static IPFS root.
IPFS URIs are rewritten to https://ipfs.io/ipfs/ and images default to a Pinata URL when missing.
4) Wallet Connections (RainbowKit/Wagmi + Mobile UX)
Wagmi config: single RPC endpoint (https://mainnet.basedaibridge.com/rpc/) and limited retry logic; no fallback or multi‑RPC transport. WalletConnect project ID defaults to a hardcoded string if env var missing.
Navbar desktop: RainbowKit ConnectButton.Custom with chain indicator and connect modal.
Navbar mobile: custom wallet picker with deep links for MetaMask/Rainbow/Coinbase (WalletConnect uses connector directly). The deep‑link fallback only shows a toast; it doesn’t auto‑open WalletConnect after timeout (user must re‑tap).
5) Security Review (App‑side)
Observed Checks
Listing validation: minimum price enforcement and preflight eth_call for existing listing before list.
Approval gating: approves marketplace operator before list (client‑side confirmation + refetch).
Offer validation: V3 offers are EIP‑712 signed and stored locally, but no server or shared orderbook; V2 offers are on‑chain and payable (security depends on contract).
Gaps / Risk Areas
No server‑side listing/offer validation: There is no server route for listing/offer creation, so no consistency checks, no shared orderbook, and no anti‑sybil/anti‑spam enforcement beyond local client logic.
RPC single‑point failure: All on‑chain reads rely on a single RPC URL. No fallback = UX failure risk and attack surface if RPC compromised.
Front‑running / stale pricing: UI uses cached listing prices; contract should revert if wrong price, but no slippage/price‑check in client beyond optional refresh calls. Reliance is on contract safety (not in repo).
Offer visibility: V3 offers are local storage only, so sellers can’t discover offers unless they originate from the same browser/session.
6) Structure & Scalability (5k+ Users)
Marketplace page uses CSV/mock data: useGuardians(false, true, ...) forces CSV mode and uses mock filtering/ownership simulation. This is not production‑grade for real‑time listings/ownership.
EscrowMarketplace performance: full supply scan (totalMinted + tokenByIndex for each) every 30s; price lookup for each active listing is per‑token. This is O(n) RPC calls per refresh. At scale, this will overload RPC and degrade UX.
Server search: search/listings uses a DB table but there is no sync/indexing pipeline shown in code to keep it aligned with on‑chain listing data.
7) Commercial Best Practices Comparison (OpenSea/Seaport, Rarible, Blur)
OpenSea/Seaport: off‑chain orderbook with on‑chain settlement, robust indexing, and multiple RPC/indexer layers. Your current setup lacks a shared orderbook for off‑chain offers (V3) and a robust indexer for listings.
Rarible: offers are visible to sellers via orderbook; here V3 offers are local only.
Blur: heavily optimized for speed with aggressive caching/indexing; current direct token scanning is not viable.
8) Simulations (code_execution)
RPC‑based simulations failed due to network constraints (ENETUNREACH), so no on‑chain listing/buy/offer calls could be executed in this environment.
Deep‑link generation for mobile wallets succeeded.
Commands & Results

⚠️ node --input-type=module -e "import { ethers } from 'ethers'; ... getActiveListings ..."
Result: RPC connection failed (ENETUNREACH), so listing/buy/offer simulation could not be completed.
Command output{line_range_start=56 line_range_end=208 terminal_chunk_id=JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)
node:internal/modules/run_main:123
triggerUncaughtException(
^
Error: connect ENETUNREACH 84.32.25.204:443 - Local (0.0.0.0:0)
at internalConnect (node:net:1110:16)
at defaultTriggerAsyncIdScope (node:internal/async_hooks:472:18)
at GetAddrInfoReqWrap.emitLookup [as callback] (node:net:1523:9)
at GetAddrInfoReqWrap.onlookupall [as oncomplete] (node:dns:134:8) {
errno: -101,
code: 'ENETUNREACH',
syscall: 'connect',
address: '84.32.25.204',
port: 443
}
Node.js v22.21.0】

⚠️ node --input-type=module <<'EOF' ... balanceOf/tokensOfOwner ... EOF
Result: RPC connection failed (ENETUNREACH) so NFT ownership fetch could not be executed.
Command output【JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)
node:internal/modules/run_main:123
triggerUncaughtException(
^
Error: connect ENETUNREACH 84.32.25.204:443 - Local (0.0.0.0:0)
at internalConnect (node:net:1110:16)
at defaultTriggerAsyncIdScope (node:internal/async_hooks:472:18)
at GetAddrInfoReqWrap.emitLookup [as callback] (node:net:1523:9)
at GetAddrInfoReqWrap.onlookupall [as oncomplete] (node:dns:134:8) {
errno: -101,
code: 'ENETUNREACH',
syscall: 'connect',
address: '84.32.25.204',
port: 443
}
Node.js v22.21.0】

✅ node --input-type=module <<'EOF' ... deep link generation ... EOF
Result: Generated mobile deep links consistent with Navbar logic.
Command output【{
metaMask: 'https://metamask.app.link/dapp/basedguardians.com/marketplace',
rainbow: 'rainbow://dapp/basedguardians.com/marketplace',
coinbase: 'https://go.cb-w.com/dapp?cb_url=https%3A%2F%2Fbasedguardians.com%2Fmarketplace'
}】
9) Prioritized Gaps & Exact Edit Recommendations
Below are P0–P2 issues with specific edit locations (line numbers) to implement. These are not applied, just audit guidance.
P0 — No shared offer orderbook (V3 offers stored only in local storage)
Impact: Sellers cannot discover offers from other users, eliminating the core marketplace “offer” workflow.
Where

useOffersV3 stores offers in SecureStorage only; no backend or shared persistence【client/src/hooks/useOffersV3.ts}.
Exact Edits
Add offers table in shared/schema.ts near listings (around L415):
Add offers table with tokenId, buyerAddress, price, expiration, signature, status, createdAt, updatedAt, indexes on tokenId, buyerAddress, status.
Location: shared/schema.ts ~L415–L450.
Add API endpoints in server/routes.ts for:
POST /api/offers (store EIP‑712 offer),
GET /api/offers?tokenId=...,
POST /api/offers/accept (mark accepted + record tx hash).
Place near search endpoints (~L2918).
Update useOffersV3 to POST signed offers to server and read offers from API instead of local storage:
Replace addOffer() / getStoredOffers() usage with server fetch & cache.
Location: client/src/hooks/useOffersV3.ts around L159–L208.
P0 — Marketplace page uses CSV/mock data instead of real listings
Impact: Users see simulated data; real listings are only surfaced via on‑chain overlay, which is incomplete and inconsistent.
Where

Marketplace.tsx forces CSV mode: useGuardians(false, true, guardianFilters).
useGuardians CSV mode simulates ownership and applies filters locally.
Exact Edit
Change Marketplace page to call a real listing indexer or the server’s /api/search/listings endpoint instead of CSV data:
Replace useGuardians(false, true, guardianFilters) with a new hook backed by /api/search/listings.
Location: client/src/pages/Marketplace.tsx around L93–L100.
P0 — No marketplace mutation endpoints on server
Impact: All listing/buy/offer actions are client‑only; there is no audit trail, no server validation, no orderbook, no scalability.
Where

server/routes.ts provides search endpoints only; no listing/offer/buy endpoints.
Exact Edit
Add marketplace mutation routes around L2918:
POST /api/listings (submit new listing intent, store for indexing),
PATCH /api/listings/:id (update/cancel),
POST /api/offers (store off‑chain offer),
POST /api/offers/:id/accept (record accept),
POST /api/sales (record sale).
These can later be cross‑validated against on‑chain events.
P1 — RPC single‑point failure (no fallback)
Impact: RPC outages kill marketplace UX.
Where

wagmi.ts: only one RPC in config.
useOwnedNFTs: single RPC provider.
useGuardians, EscrowMarketplace use direct RPC calls.
Exact Edit
Add multiple RPC endpoints in client/src/lib/constants.ts or wagmi.ts, then use fallback transports (e.g., fallback([http(...), http(...)])) for wagmi and pass fallback list to ethers provider (or use viem with fallback transport).
client/src/lib/wagmi.ts around L58–L69.
client/src/hooks/useOwnedNFTs.ts around L32.
P1 — Non‑standard tokensOfOwner reliance
Impact: If NFT contract doesn’t implement tokensOfOwner, ownership fails entirely.
Where

useOwnedNFTs uses tokensOfOwner without fallback.
Exact Edit
Add a fallback path using:
ERC‑721 Enumerable tokenOfOwnerByIndex, or
An indexer (e.g., Alchemy, Reservoir, or a custom subgraph).
Location: client/src/hooks/useOwnedNFTs.ts around L48–L60.
P2 — EscrowMarketplace scalability
Impact: For 5k+ users, repeated full‑supply scans are too expensive.
Where

EscrowMarketplace fetches totalMinted and tokenByIndex for all tokens every 30s, plus per‑listing price fetches.
Exact Edit
Replace direct scanning with server‑cached listing/index data (batch responses):
Add /api/marketplace/listings + /api/marketplace/mints endpoints in server/routes.ts and update the component to fetch once per session.
Location: client/src/components/EscrowMarketplace.tsx around L120–L206.
10) Before/After Examples (Illustrative)
Before (Current)
Offer creation: EIP‑712 signature stored only in local storage; other users cannot see it.
Marketplace browsing: CSV mock data + on‑chain overlay; real listings visibility is partial.
After (Recommended)
Offer creation: POST /api/offers stores the signed offer in a shared orderbook. Sellers see it in their offers view, and on‑chain acceptance references the stored signature.
Marketplace browsing: /api/search/listings served from indexed on‑chain events or DB sync. All listings/traits displayed consistently.
11) Overhaul Recommendations (Robust, Secure Marketplace)
Indexer + Orderbook
Build a server‑side indexer (event listener) to sync listings, sales, and offers into DB tables.
Expose read APIs for UI (listings search, offers, stats).
Offer Lifecycle
Persist off‑chain offers server‑side, verify EIP‑712 signature before storing, and mark acceptance/cancelation on chain.
RPC & Provider Redundancy
Use fallback RPCs and caching.
Scalability
Replace per‑token calls with batch/indexed queries.
Security
Add server validation for orderbook entries, rate limiting, and anti‑spam controls.
Final Notes
The server currently does not implement marketplace mutations, and the Marketplace page is still CSV/mock‑based (not indexing real on‑chain listings). These are the highest‑impact gaps for functionality and security.
RPC access in this environment failed, so I could not verify on‑chain listing/buy/offer flows with eth_call. If you want me to re‑run these simulations, please provide an accessible RPC endpoint or run the commands in an environment with proper connectivity.