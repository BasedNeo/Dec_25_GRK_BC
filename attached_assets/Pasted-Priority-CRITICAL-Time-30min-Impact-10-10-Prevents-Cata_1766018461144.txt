Priority: CRITICAL | Time: 30min | Impact: 10/10 (Prevents Catastrophic Failures)
=== ARCHITECTURE: CORE CODE PROTECTION + BACKUP SYSTEM ===BACKGROUND: With a tiny dev team, accidental changes to core commerce code could break the entire app. Need automated protection + version control backup system.â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 1: CREATE CORE PROTECTION MANIFESTâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•CREATE: client/src/core/PROTECTION_MANIFEST.json{  "version": "1.0.0",  "lastVerified": "2024-12-17",  "protectedFiles": [    {      "path": "client/src/core/commerce/useMint.ts",      "criticality": "CRITICAL",      "reason": "NFT minting with fixed price (69,420 $BASED)",      "lastModified": "2024-12-15",      "checksum": "",      "testRequired": true,      "tests": ["mint-1-nft", "mint-max-affordable", "mint-soldout-check"]    },    {      "path": "client/src/core/commerce/useMarketplace.ts",      "criticality": "CRITICAL",      "reason": "Marketplace listing, buying, offer acceptance",      "lastModified": "2024-12-15",      "checksum": "",      "testRequired": true,      "tests": ["list-nft", "buy-nft", "approve-marketplace"]    },    {      "path": "client/src/core/commerce/useOffers.ts",      "criticality": "HIGH",      "reason": "V3 off-chain offer system",      "lastModified": "2024-12-15",      "checksum": "",      "testRequired": true,      "tests": ["make-offer-v3", "accept-offer-v3", "complete-purchase"]    },    {      "path": "client/src/lib/constants.ts",      "criticality": "CRITICAL",      "reason": "Contract addresses, revenue splits (LOCKED)",      "lastModified": "2024-12-10",      "checksum": "",      "testRequired": false,      "locked": true,      "allowedChanges": []    },    {      "path": "client/src/lib/mockData.ts",      "criticality": "HIGH",      "reason": "Treasury calculations (LOCKED formulas)",      "lastModified": "2024-12-10",      "checksum": "",      "testRequired": false,      "locked": true,      "allowedChanges": []    },    {      "path": "server/routes.ts",      "criticality": "HIGH",      "reason": "API endpoints, rate limiting, validation",      "lastModified": "2024-12-17",      "checksum": "",      "testRequired": true,      "tests": ["api-profile-login", "api-profile-name", "api-rate-limit"]    },    {      "path": "server/storage.ts",      "criticality": "HIGH",      "reason": "Database operations",      "lastModified": "2024-12-15",      "checksum": "",      "testRequired": true,      "tests": ["db-profile-create", "db-name-check"]    },    {      "path": "shared/schema.ts",      "criticality": "CRITICAL",      "reason": "Database schema (DO NOT MODIFY WITHOUT MIGRATION)",      "lastModified": "2024-12-10",      "checksum": "",      "testRequired": false,      "locked": true,      "allowedChanges": []    }  ],  "requiredTests": {    "mint-1-nft": "Successfully mint 1 NFT with correct price",    "list-nft": "Successfully list owned NFT for sale",    "buy-nft": "Successfully purchase listed NFT",    "approve-marketplace": "Approve marketplace for NFT transfers",    "make-offer-v3": "Create gasless V3 offer",    "accept-offer-v3": "Seller accepts V3 offer",    "api-rate-limit": "Rate limiter blocks >100 requests/15min"  }}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 2: CREATE AUTOMATED BACKUP SCRIPTâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•CREATE: script/backup-core.tsimport fs from 'fs';import path from 'path';import crypto from 'crypto';interface ProtectedFile {  path: string;  criticality: string;  reason: string;  checksum: string;  locked?: boolean;}const MANIFEST_PATH = './client/src/core/PROTECTION_MANIFEST.json';const BACKUP_DIR = '.core-backups';const MAX_BACKUPS = 50; // Keep last 50 versionsfunction getChecksum(filePath: string): string {  try {    const content = fs.readFileSync(filePath, 'utf8');    return crypto.createHash('sha256').update(content).digest('hex');  } catch (error) {    console.error(`âŒ Error reading ${filePath}:`, error);    return '';  }}function createBackup(filePath: string): boolean {  try {    const content = fs.readFileSync(filePath, 'utf8');    const checksum = getChecksum(filePath);    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');        // Create backup directory structure    const backupPath = path.join(BACKUP_DIR, path.dirname(filePath));    fs.mkdirSync(backupPath, { recursive: true });        // Save backup with timestamp    const fileName = path.basename(filePath);    const backupFile = path.join(backupPath, `${fileName}.${timestamp}.bak`);    fs.writeFileSync(backupFile, content, 'utf8');        // Save metadata    const metaFile = `${backupFile}.meta.json`;    fs.writeFileSync(metaFile, JSON.stringify({      originalPath: filePath,      timestamp,      checksum,      size: content.length    }, null, 2));        console.log(`âœ… Backed up: ${filePath} (${checksum.slice(0, 8)}...)`);    return true;  } catch (error) {    console.error(`âŒ Backup failed for ${filePath}:`, error);    return false;  }}function cleanOldBackups(filePath: string) {  try {    const backupPath = path.join(BACKUP_DIR, path.dirname(filePath));    const fileName = path.basename(filePath);        if (!fs.existsSync(backupPath)) return;        // Get all backup files for this file    const backups = fs.readdirSync(backupPath)      .filter(f => f.startsWith(fileName) && f.endsWith('.bak'))      .map(f => ({        name: f,        path: path.join(backupPath, f),        mtime: fs.statSync(path.join(backupPath, f)).mtime      }))      .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());        // Keep only MAX_BACKUPS most recent    if (backups.length > MAX_BACKUPS) {      const toDelete = backups.slice(MAX_BACKUPS);      toDelete.forEach(backup => {        fs.unlinkSync(backup.path);        const metaPath = `${backup.path}.meta.json`;        if (fs.existsSync(metaPath)) fs.unlinkSync(metaPath);        console.log(`ğŸ—‘ï¸  Deleted old backup: ${backup.name}`);      });    }  } catch (error) {    console.error('Error cleaning old backups:', error);  }}function verifyIntegrity(): boolean {  console.log('\nğŸ” Verifying core file integrity...\n');    if (!fs.existsSync(MANIFEST_PATH)) {    console.error('âŒ Protection manifest not found!');    return false;  }    const manifest = JSON.parse(fs.readFileSync(MANIFEST_PATH, 'utf8'));  let allValid = true;  const changes: Array<{ file: string; status: string; action: string }> = [];    for (const file of manifest.protectedFiles) {    if (!fs.existsSync(file.path)) {      console.error(`âŒ CRITICAL: ${file.path} is missing!`);      allValid = false;      changes.push({ file: file.path, status: 'MISSING', action: 'RESTORE FROM BACKUP' });      continue;    }        const currentChecksum = getChecksum(file.path);        // If no checksum in manifest, this is first run - save it    if (!file.checksum) {      file.checksum = currentChecksum;      changes.push({ file: file.path, status: 'INITIALIZED', action: 'Checksum saved' });      continue;    }        // Check if file changed    if (currentChecksum !== file.checksum) {      if (file.locked) {        console.error(`âŒ CRITICAL: LOCKED file ${file.path} was modified!`);        allValid = false;        changes.push({ file: file.path, status: 'MODIFIED (LOCKED)', action: 'REVIEW IMMEDIATELY' });      } else {        console.warn(`âš ï¸  ${file.path} has changed (${file.criticality})`);        changes.push({ file: file.path, status: 'MODIFIED', action: 'Backup created' });                // Create backup before updating checksum        createBackup(file.path);        cleanOldBackups(file.path);        file.checksum = currentChecksum;      }    } else {      console.log(`âœ… ${file.path} - OK`);    }  }    // Update manifest with new checksums  fs.writeFileSync(MANIFEST_PATH, JSON.stringify(manifest, null, 2));    // Show summary  if (changes.length > 0) {    console.log('\nğŸ“‹ CHANGE SUMMARY:\n');    console.table(changes);  }    if (!allValid) {    console.error('\nâŒ INTEGRITY CHECK FAILED - REVIEW REQUIRED\n');    process.exit(1);  }    console.log('\nâœ… All protected files verified successfully\n');  return true;}function restoreBackup(filePath: string, timestamp?: string) {  const backupPath = path.join(BACKUP_DIR, path.dirname(filePath));  const fileName = path.basename(filePath);    if (!fs.existsSync(backupPath)) {    console.error(`âŒ No backups found for ${filePath}`);    return false;  }    // Get all backups  const backups = fs.readdirSync(backupPath)    .filter(f => f.startsWith(fileName) && f.endsWith('.bak'))    .map(f => ({      name: f,      path: path.join(backupPath, f),      timestamp: f.match(/\.(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})/)?.[1] || '',      mtime: fs.statSync(path.join(backupPath, f)).mtime    }))    .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());    if (backups.length === 0) {    console.error(`âŒ No backups found for ${filePath}`);    return false;  }    // Find specific backup or use most recent  const backup = timestamp     ? backups.find(b => b.timestamp === timestamp)    : backups[0];    if (!backup) {    console.error(`âŒ Backup not found`);    return false;  }    try {    const content = fs.readFileSync(backup.path, 'utf8');    fs.writeFileSync(filePath, content, 'utf8');    console.log(`âœ… Restored ${filePath} from backup: ${backup.name}`);    return true;  } catch (error) {    console.error(`âŒ Restore failed:`, error);    return false;  }}// CLI Commandsconst command = process.argv[2];switch (command) {  case 'verify':    verifyIntegrity();    break;      case 'backup':    {      const manifest = JSON.parse(fs.readFileSync(MANIFEST_PATH, 'utf8'));      fs.mkdirSync(BACKUP_DIR, { recursive: true });            console.log('ğŸ” Backing up protected files...\n');      let success = 0;      for (const file of manifest.protectedFiles) {        if (createBackup(file.path)) {          cleanOldBackups(file.path);          success++;        }      }      console.log(`\nâœ… Backed up ${success}/${manifest.protectedFiles.length} files\n`);    }    break;      case 'restore':    {      const filePath = process.argv[3];      const timestamp = process.argv[4];            if (!filePath) {        console.error('Usage: npm run core:restore <file-path> [timestamp]');        process.exit(1);      }            restoreBackup(filePath, timestamp);    }    break;      case 'list':    {      const filePath = process.argv[3];      if (!filePath) {        console.error('Usage: npm run core:list <file-path>');        process.exit(1);      }            const backupPath = path.join(BACKUP_DIR, path.dirname(filePath));      const fileName = path.basename(filePath);            if (!fs.existsSync(backupPath)) {        console.log(`No backups found for ${filePath}`);        process.exit(0);      }            const backups = fs.readdirSync(backupPath)        .filter(f => f.startsWith(fileName) && f.endsWith('.bak'))        .map(f => {          const metaPath = path.join(backupPath, `${f}.meta.json`);          const meta = fs.existsSync(metaPath)             ? JSON.parse(fs.readFileSync(metaPath, 'utf8'))            : {};                    return {            file: f,            timestamp: meta.timestamp || 'unknown',            checksum: (meta.checksum || '').slice(0, 8),            size: `${Math.round((meta.size || 0) / 1024)}KB`          };        });            console.log(`\nğŸ“¦ Backups for ${filePath}:\n`);      console.table(backups);    }    break;      default:    console.log(`ğŸ” Core Protection SystemCommands:  npm run core:verify           Verify integrity of protected files  npm run core:backup           Create backups of all protected files  npm run core:restore <path>   Restore file from most recent backup  npm run core:list <path>      List all backups for a fileExamples:  npm run core:verify  npm run core:backup  npm run core:restore client/src/core/commerce/useMint.ts  npm run core:list client/src/lib/constants.ts    `);    break;}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 3: ADD NPM SCRIPTSâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•FILE: package.jsonFIND "scripts" section, ADD:"scripts": {  ...existing scripts...  "core:verify": "tsx script/backup-core.ts verify",  "core:backup": "tsx script/backup-core.ts backup",  "core:restore": "tsx script/backup-core.ts restore",  "core:list": "tsx script/backup-core.ts list",  "pre-deploy": "npm run core:verify && npm run build",  "pre-commit": "npm run core:verify"}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 4: CREATE PRE-DEPLOYMENT CHECKLISTâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•CREATE: DEPLOYMENT_CHECKLIST.md# ğŸš€ Pre-Deployment ChecklistRun these checks BEFORE every deployment to production.## 1. Core Integrity Checknpm run core:verifyâœ… Expected: All protected files pass integrity checkâŒ If failed: Review changes, restore from backup if needed## 2. Database Verificationnpm run db:verifyâœ… Expected: All tables exist and accessibleâŒ If failed: Run `npm run db:push` to apply migrations## 3. Security Tests# Test rate limitingcurl -X GET http://localhost:5000/api/health (repeat 110 times)# Should see 429 after 100 requests## 4. Commerce Function Tests### Mint Test- [ ] Connect wallet- [ ] Go to Mint page- [ ] Mint 1 NFT successfully- [ ] Verify NFT appears in Portfolio### Marketplace Test- [ ] List owned NFT for sale- [ ] Verify listing appears in Market- [ ] (Optional) Buy from different wallet- [ ] Verify ownership transfer### Offer Test (V3)- [ ] Make gasless offer (EIP-712 signature)- [ ] Verify offer stored in localStorage- [ ] Seller accepts offer- [ ] Buyer completes purchase- [ ] Verify NFT transfer### Profile Test- [ ] Set custom name- [ ] Verify profanity filter blocks bad names- [ ] Verify duplicate names blocked- [ ] Name displays correctly in Stats## 5. Performance Check# Open browser consolememReport()timers()- Memory usage < 200MB after 5 minutes- Active timers < 20- No memory leaks detected## 6. Translation Check- [ ] Switch to 3 different languages- [ ] Verify nav menu translates- [ ] Verify marketplace translates- [ ] No missing translation keys## 7. Mobile Check- [ ] Test on mobile device- [ ] Wallet connect works- [ ] Touch controls responsive- [ ] Game playable (if applicable)## 8. Final Backupnpm run core:backupâœ… All protected files backed up before deployment## 9. Build Productionnpm run buildâœ… Build completes without errorsâœ… No TypeScript errorsâœ… No linter errors## 10. DeployOnly after ALL checks pass:npm run startâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 5: CREATE GIT HOOKS (OPTIONAL BUT RECOMMENDED)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•If using Git:CREATE: .husky/pre-commit (if using Husky)#!/bin/sh. "$(dirname "$0")/_/husky.sh"echo "ğŸ” Verifying core file integrity..."npm run core:verifyif [ $? -ne 0 ]; then  echo "âŒ Core integrity check failed!"  echo "Review changes to protected files before committing."  exit 1fiOR manually add to .git/hooks/pre-commit:#!/bin/bashnpm run core:verify || exit 1Make executable:chmod +x .git/hooks/pre-commitâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•VERIFICATIONâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•1. Initialize protection system:   npm run core:verify   # Should initialize checksums for all protected files2. Create initial backup:   npm run core:backup   # Should create .core-backups directory3. Test integrity detection:   # Make small change to constants.ts (add a comment)   npm run core:verify   # Should detect change and create backup4. Test restore:   npm run core:list client/src/lib/constants.ts   # Shows available backups      npm run core:restore client/src/lib/constants.ts   # Restores most recent backup5. Test locked file protection:   # Change a LOCKED file (e.g., mockData.ts)   npm run core:verify   # Should FAIL and exit with errorCHECKLIST:â–¡ PROTECTION_MANIFEST.json createdâ–¡ backup-core.ts createdâ–¡ NPM scripts addedâ–¡ DEPLOYMENT_CHECKLIST.md createdâ–¡ core:verify runs successfullyâ–¡ core:backup creates backupsâ–¡ core:restore worksâ–¡ Locked file changes detectedâ–¡ Pre-deploy checks documented
âœ… Expected: All protected files pass integrity check
âŒ If failed: Review changes, restore from backup if needed
2. Database Verification
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
=== ARCHITECTURE: PRODUCTION-GRADE ERROR BOUNDARIES ===BACKGROUND: Current ErrorBoundary is basic. Need granular boundaries for each feature, automatic error reporting, and graceful degradation.â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 1: ENHANCED ROOT ERROR BOUNDARYâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•FILE: client/src/components/ErrorBoundary.tsxREPLACE ENTIRE FILE WITH:import React, { Component, ReactNode } from 'react';import { AlertTriangle, RefreshCw, Home, Bug } from 'lucide-react';import { Button } from '@/components/ui/button';import { Card } from '@/components/ui/card';interface Props {  children: ReactNode;  fallback?: ReactNode;  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;  isolate?: boolean; // If true, only this component crashes, not whole app  resetKeys?: any[]; // Reset boundary when these values change  feature?: string; // Feature name for logging}interface State {  hasError: boolean;  error: Error | null;  errorInfo: React.ErrorInfo | null;  errorId: string | null;}class ErrorBoundary extends Component<Props, State> {  constructor(props: Props) {    super(props);    this.state = {      hasError: false,      error: null,      errorInfo: null,      errorId: null    };  }  static getDerivedStateFromError(error: Error): Partial<State> {    return {      hasError: true,      error,      errorId: `err_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`    };  }  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {    const { onError, feature } = this.props;    const { errorId } = this.state;    // Log error details    console.error(`[ErrorBoundary${feature ? ` - ${feature}` : ''}]`, {      errorId,      error,      errorInfo,      timestamp: new Date().toISOString()    });    this.setState({ errorInfo });    // Call custom error handler    if (onError) {      onError(error, errorInfo);    }    // In production, send to error tracking service    if (import.meta.env.PROD) {      this.reportError(error, errorInfo, errorId || '');    }  }  componentDidUpdate(prevProps: Props) {    const { resetKeys } = this.props;    const { hasError } = this.state;    // Auto-reset if reset keys change    if (hasError && resetKeys && prevProps.resetKeys) {      if (resetKeys.some((key, i) => key !== prevProps.resetKeys![i])) {        this.resetError();      }    }  }  reportError(error: Error, errorInfo: React.ErrorInfo, errorId: string) {    // TODO: Integrate with error tracking service (Sentry, etc.)    // For now, just store locally for debugging    try {      const errorLog = {        id: errorId,        message: error.message,        stack: error.stack,        componentStack: errorInfo.componentStack,        timestamp: Date.now(),        feature: this.props.feature,        userAgent: navigator.userAgent,        url: window.location.href      };      const logs = JSON.parse(localStorage.getItem('error_logs') || '[]');      logs.push(errorLog);            // Keep only last 10 errors      if (logs.length > 10) logs.shift();            localStorage.setItem('error_logs', JSON.stringify(logs));    } catch (e) {      console.error('Failed to log error:', e);    }  }  resetError = () => {    this.setState({      hasError: false,      error: null,      errorInfo: null,      errorId: null    });  };  copyErrorDetails = () => {    const { error, errorInfo, errorId } = this.state;    const details = `Error ID: ${errorId}Feature: ${this.props.feature || 'Unknown'}Message: ${error?.message}Stack: ${error?.stack}Component Stack: ${errorInfo?.componentStack}URL: ${window.location.href}Time: ${new Date().toISOString()}    `.trim();    navigator.clipboard.writeText(details);    alert('Error details copied to clipboard');  };  render() {    const { hasError, error, errorId } = this.state;    const { children, fallback, isolate, feature } = this.props;    if (hasError) {      // Use custom fallback if provided      if (fallback) {        return fallback;      }      // Minimal fallback for isolated errors      if (isolate) {        return (          <div className="p-4 border border-red-500/30 bg-red-500/10 rounded-lg">            <div className="flex items-center gap-2 text-red-400 mb-2">              <AlertTriangle size={16} />              <span className="text-sm font-mono">                {feature ? `${feature} Error` : 'Component Error'}              </span>            </div>            <Button              size="sm"              variant="outline"              onClick={this.resetError}              className="text-xs"            >              <RefreshCw size={12} className="mr-1" />              Retry            </Button>          </div>        );      }      // Full-page error UI      return (        <div className="min-h-screen bg-black flex items-center justify-center p-4">          <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,rgba(220,38,38,0.1)_0%,transparent_50%)]" />                    <Card className="relative z-10 max-w-2xl w-full bg-black/95 border-red-500/30 backdrop-blur-xl p-8">            <div className="text-center mb-6">              <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-red-500/20 mb-4">                <AlertTriangle className="w-8 h-8 text-red-400" />              </div>                            <h1 className="text-2xl font-orbitron font-bold text-white mb-2">                Houston, We Have a Problem              </h1>                            <p className="text-gray-400">                Something went wrong while loading this component.                {feature && ` (Feature: ${feature})`}              </p>            </div>            <div className="bg-black/50 border border-red-500/20 rounded-lg p-4 mb-6">              <div className="text-xs font-mono text-red-300 mb-2">                Error ID: {errorId}              </div>              <div className="text-sm text-gray-300 mb-2 font-mono">                {error?.message || 'Unknown error'}              </div>              {import.meta.env.DEV && (                <details className="text-xs text-gray-500 mt-2">                  <summary className="cursor-pointer hover:text-gray-400">                    Stack Trace (Dev Only)                  </summary>                  <pre className="mt-2 p-2 bg-black/50 rounded overflow-x-auto">                    {error?.stack}                  </pre>                </details>              )}            </div>            <div className="flex flex-col sm:flex-row gap-3">              <Button                onClick={this.resetError}                className="flex-1 bg-cyan-500 text-black hover:bg-cyan-400"              >                <RefreshCw className="mr-2" size={16} />                Try Again              </Button>                            <Button                onClick={() => window.location.href = '/'}                variant="outline"                className="flex-1 border-white/20 text-white hover:bg-white/10"              >                <Home className="mr-2" size={16} />                Go Home              </Button>                            <Button                onClick={this.copyErrorDetails}                variant="outline"                className="flex-1 border-white/20 text-white hover:bg-white/10"              >                <Bug className="mr-2" size={16} />                Copy Error              </Button>            </div>            <p className="text-center text-xs text-gray-500 mt-6">              If this problem persists, please contact support with Error ID: {errorId}            </p>          </Card>        </div>      );    }    return children;  }}export { ErrorBoundary };â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 2: FEATURE-SPECIFIC ERROR BOUNDARIESâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•WRAP CRITICAL FEATURES:FILE: client/src/pages/Home.tsxFIND the component export, WRAP WITH:import { ErrorBoundary } from '@/components/ErrorBoundary';export default function Home() {  return (    <ErrorBoundary       feature="Home"       isolate={false}      onError={(error) => {        console.error('[Home] Critical error:', error);      }}    >      {/* Existing Home component content */}    </ErrorBoundary>  );}FILE: client/src/components/EscrowMarketplace.tsxWRAP entire component:export function EscrowMarketplace() {  return (    <ErrorBoundary       feature="Marketplace"       isolate={true}      fallback={        <div className="p-8 text-center">          <p className="text-red-400 mb-4">Unable to load marketplace</p>          <Button onClick={() => window.location.reload()}>Reload</Button>        </div>      }    >      {/* Existing marketplace content */}    </ErrorBoundary>  );}SIMILARLY WRAP:- pages/GuardianDefender.tsx (Game)- components/NFTGallery.tsx (Portfolio)- components/VotingDAO.tsx (Governance)- components/UserStats.tsx (Stats)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 3: ERROR REPORTING UTILITYâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•CREATE: client/src/lib/errorReporter.tsinterface ErrorReport {  id: string;  timestamp: number;  message: string;  stack?: string;  feature?: string;  userAgent: string;  url: string;}class ErrorReporter {  private maxLogs = 20;  /**   * Report error to tracking service   */  report(error: Error, context?: { feature?: string; metadata?: Record<string, any> }) {    const report: ErrorReport = {      id: `err_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`,      timestamp: Date.now(),      message: error.message,      stack: error.stack,      feature: context?.feature,      userAgent: navigator.userAgent,      url: window.location.href    };    // Log to console in development    if (import.meta.env.DEV) {      console.error('[ErrorReporter]', report, context?.metadata);    }    // Store locally    this.storeLocal(report);    // TODO: Send to remote service (Sentry, etc.) in production    if (import.meta.env.PROD) {      this.sendToService(report, context?.metadata);    }    return report.id;  }  private storeLocal(report: ErrorReport) {    try {      const logs = JSON.parse(localStorage.getItem('error_logs') || '[]');      logs.push(report);            // Keep only recent errors      if (logs.length > this.maxLogs) {        logs.splice(0, logs.length - this.maxLogs);      }            localStorage.setItem('error_logs', JSON.stringify(logs));    } catch (e) {      console.error('Failed to store error log:', e);    }  }  private sendToService(report: ErrorReport, metadata?: Record<string, any>) {    // TODO: Integrate with Sentry, LogRocket, etc.    // Example:    // Sentry.captureException(new Error(report.message), {    //   tags: { feature: report.feature },    //   extra: metadata    // });  }  /**   * Get recent error logs (for admin debugging)   */  getLogs(): ErrorReport[] {    try {      return JSON.parse(localStorage.getItem('error_logs') || '[]');    } catch {      return [];    }  }  /**   * Clear all logs   */  clearLogs() {    localStorage.removeItem('error_logs');  }  /**   * Export logs for support   */  exportLogs(): string {    const logs = this.getLogs();    return JSON.stringify(logs, null, 2);  }}export const errorReporter = new ErrorReporter();// Expose for debuggingif (typeof window !== 'undefined') {  (window as any).errorLogs = () => {    console.table(errorReporter.getLogs().map(log => ({      id: log.id.slice(0, 10),      feature: log.feature || 'Unknown',      message: log.message.slice(0, 50),      time: new Date(log.timestamp).toLocaleString()    })));  };    (window as any).exportErrors = () => {    const data = errorReporter.exportLogs();    const blob = new Blob([data], { type: 'application/json' });    const url = URL.createObjectURL(blob);    const a = document.createElement('a');    a.href = url;    a.download = `error-logs-${Date.now()}.json`;    a.click();  };}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 4: ADD ERROR LOGS TO ADMIN DASHBOARDâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•FILE: client/src/components/AdminDashboard.tsxADD new section for error logs:import { errorReporter } from '@/lib/errorReporter';import { useState, useEffect } from 'react';// Inside component:const [errorLogs, setErrorLogs] = useState(errorReporter.getLogs());useEffect(() => {  const interval = setInterval(() => {    setErrorLogs(errorReporter.getLogs());  }, 5000);  return () => clearInterval(interval);}, []);// Add to UI:<Card className="p-6">  <div className="flex items-center justify-between mb-4">    <h3 className="text-lg font-orbitron text-cyan-400">Recent Errors</h3>    <Button size="sm" onClick={() => errorReporter.clearLogs()}>      Clear Logs    </Button>  </div>    {errorLogs.length === 0 ? (    <p className="text-gray-500 text-sm">No errors logged</p>  ) : (    <div className="space-y-2">      {errorLogs.slice(-5).reverse().map(log => (        <div key={log.id} className="p-3 bg-red-500/10 border border-red-500/30 rounded text-xs">          <div className="flex items-start justify-between mb-1">            <span className="font-mono text-red-400">{log.feature || 'Unknown'}</span>            <span className="text-gray-500">              {new Date(log.timestamp).toLocaleTimeString()}            </span>          </div>          <p className="text-gray-300">{log.message}</p>        </div>      ))}    </div>  )}    <Button     size="sm"     variant="outline"     className="w-full mt-4"    onClick={() => (window as any).exportErrors()}  >    Export All Logs  </Button></Card>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•VERIFICATIONâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•1. Test error boundary:   # Temporarily add throw error to a component   throw new Error('Test error');   # Should see custom error UI with error ID2. Test isolated boundary:   # Add error to marketplace component   # Should show inline error, not crash whole app3. Test error recovery:   # Click "Try Again" button   # Should reset and reload component4. View error logs in console:   errorLogs()   # Should show table of recent errors5. Export errors:   exportErrors()   # Should download JSON file6. Check admin dashboard:   # Navigate to admin panel   # Should see "Recent Errors" section   # Should show last 5 errorsCHECKLIST:â–¡ ErrorBoundary.tsx updated with full featuresâ–¡ Feature-specific boundaries addedâ–¡ errorReporter.ts createdâ–¡ Error logs integrated in AdminDashboardâ–¡ Test error throwing/catching worksâ–¡ Isolated errors don't crash appâ–¡ Error recovery worksâ–¡ errorLogs() command worksâ–¡ exportErrors() downloads JSONâ–¡ Admin panel shows recent errors
âœ… Expected: All tables exist and accessible
âŒ If failed: Run npm run db:push to apply migrations
3. Security Tests
=== E2E COMMERCE TEST SUITE + AUTOMATED VERIFICATION ===BACKGROUND: Manual testing is error-prone and time-consuming. Need automated test suite for critical commerce flows.â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 1: CREATE MANUAL TEST PROTOCOL (REQUIRED BEFORE EACH DEPLOY)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•CREATE: tests/MANUAL_TEST_PROTOCOL.md# ğŸ§ª Manual Commerce Test ProtocolRun BEFORE every production deployment. Check ALL boxes.## Prerequisites- [ ] Development server running (`npm run dev`)- [ ] Test wallet with $BASED tokens- [ ] Clean browser (clear localStorage, cookies)- [ ] Desktop + mobile device ready---## TEST 1: MINT FLOW (CRITICAL)### Setup- Navigate to /mint- Connect test wallet- Verify balance shown correctly### Test Cases- [ ] **T1.1** - Display shows correct mint price (69,420 $BASED)- [ ] **T1.2** - Display shows remaining supply accurately- [ ] **T1.3** - Click "Mint 1 NFT" â†’ Wallet prompts for approval- [ ] **T1.4** - Confirm transaction â†’ Shows "Minting..." status- [ ] **T1.5** - Wait for confirmation â†’ Shows success message- [ ] **T1.6** - Navigate to Portfolio â†’ New NFT appears### Expected Behaviorâœ… Mint price matches 69,420 $BASEDâœ… Transaction completes within 60 secondsâœ… NFT ownership verified on-chainâœ… Balance updates correctly after mint### If FailedâŒ Check gas limit set to 8,000,000âŒ Verify NFT_CONTRACT address in constants.tsâŒ Check RPC endpoint health---## TEST 2: MARKETPLACE LISTING (CRITICAL)### Setup- Navigate to Portfolio- Select an owned, unlisted NFT- Click "List for Sale"### Test Cases- [ ] **T2.1** - If not approved â†’ Shows "Approve Marketplace" button- [ ] **T2.2** - Click approve â†’ Wallet prompts for approval- [ ] **T2.3** - Approval confirms â†’ Button changes to "List NFT"- [ ] **T2.4** - Enter price (e.g., 100,000 $BASED)- [ ] **T2.5** - Validation: Price < 1 â†’ Shows error- [ ] **T2.6** - Validation: Already listed â†’ Shows error- [ ] **T2.7** - Valid price â†’ Transaction submits- [ ] **T2.8** - Transaction confirms â†’ NFT appears in Market with "Listed" badge### Expected Behaviorâœ… Two-step process: Approve â†’ Listâœ… NFT stays in wallet (doesn't transfer to marketplace)âœ… Listing appears in market within 30 secondsâœ… Price displays correctly### If FailedâŒ Check MARKETPLACE_CONTRACT addressâŒ Verify approval check logic in useMarketplace.tsâŒ Check event logs from marketplace contract---## TEST 3: MARKETPLACE PURCHASE (CRITICAL)### Setup- Navigate to Market- Find a listed NFT (not owned by you)- Verify you have sufficient balance### Test Cases- [ ] **T3.1** - Click "Buy Now" â†’ Shows purchase confirmation- [ ] **T3.2** - Confirm â†’ Wallet prompts for transaction- [ ] **T3.3** - Verify exact price + platform fee shown- [ ] **T3.4** - Transaction submits â†’ Shows "Buying..." status- [ ] **T3.5** - Transaction confirms â†’ NFT removed from market- [ ] **T3.6** - NFT appears in your Portfolio- [ ] **T3.7** - Seller's balance increases correctly- [ ] **T3.8** - Platform fee sent to correct address### Expected Behaviorâœ… Buyer pays exact listed priceâœ… Ownership transfers immediatelyâœ… Listing removed from marketâœ… Balances update correctly### If FailedâŒ Check gas limit (400,000 for buy)âŒ Verify platform fee percentage (1%)âŒ Check royalty distribution---## TEST 4: V3 OFFER SYSTEM (CRITICAL)### Setup- Navigate to Market or Portfolio- Select an unlisted NFT (or listed NFT you don't own)- Click "Make Offer"### Test Cases- [ ] **T4.1** - Enter offer amount (e.g., 80,000 $BASED)- [ ] **T4.2** - Enter optional message (< 280 chars)- [ ] **T4.3** - Click "Submit Offer" â†’ Wallet prompts for SIGNATURE (NOT transaction)- [ ] **T4.4** - Sign message â†’ No gas cost- [ ] **T4.5** - Offer created â†’ Shows in "My Offers" panel- [ ] **T4.6** - Switch to NFT owner wallet- [ ] **T4.7** - See pending offer with buyer's message- [ ] **T4.8** - Click "Accept" â†’ Transaction submits- [ ] **T4.9** - Switch back to buyer wallet- [ ] **T4.10** - See "Complete Purchase" button- [ ] **T4.11** - Click complete â†’ Transaction submits with offer amount- [ ] **T4.12** - NFT transfers to buyer### Expected Behaviorâœ… Offer creation is FREE (signature only)âœ… Offer stored in localStorageâœ… Seller can accept (pays gas)âœ… Buyer completes (pays price + gas)âœ… NFT transfers correctly### If FailedâŒ Check EIP-712 signature domainâŒ Verify MARKETPLACE_V3_CONTRACT addressâŒ Check localStorage offer storageâŒ Verify nonce tracking---## TEST 5: CUSTOM NAME SYSTEM (HIGH PRIORITY)### Setup- Navigate to Stats page- Connect wallet### Test Cases- [ ] **T5.1** - If no name set â†’ Shows "Set Name" button- [ ] **T5.2** - Click â†’ Shows name input modal- [ ] **T5.3** - Enter 1 character â†’ Shows error "Must be 2+ chars"- [ ] **T5.4** - Enter 17 characters â†’ Auto-truncated to 16- [ ] **T5.5** - Enter special chars (!@#$) â†’ Auto-removed- [ ] **T5.6** - Enter profanity â†’ Shows "inappropriate content" error- [ ] **T5.7** - Enter valid name "TestUser" â†’ Green checkmark- [ ] **T5.8** - Click Save â†’ Shows disclaimer popup- [ ] **T5.9** - Click "I Understand" â†’ Name saves successfully- [ ] **T5.10** - Name displays as "TestUser#ABC" (with wallet suffix)- [ ] **T5.11** - Try duplicate name â†’ Shows "already taken"### Expected Behaviorâœ… Real-time availability checkâœ… Character validation enforcedâœ… Profanity filter worksâœ… Disclaimer shown on first saveâœ… Name persists across sessions### If FailedâŒ Run: npm run db:push (create guardian_profiles table)âŒ Check profanityFilter.tsâŒ Verify API endpoint /api/profile/name---## TEST 6: GAME (MEDIUM PRIORITY)### Setup- Navigate to /game- Test with and without NFT ownership### Test Cases- [ ] **T6.1** - Game loads within 5 seconds- [ ] **T6.2** - Without NFT â†’ 3 lives, 1x score multiplier- [ ] **T6.3** - With NFT â†’ 4 lives, 1.5x score multiplier- [ ] **T6.4** - Controls responsive (arrow keys / touch)- [ ] **T6.5** - Enemies spawn correctly- [ ] **T6.6** - Shooting works (bullets fire)- [ ] **T6.7** - Collision detection works- [ ] **T6.8** - Game Over â†’ Shows final score- [ ] **T6.9** - Play Again â†’ Resets properly- [ ] **T6.10** - Leaderboard updates after game### Expected Behaviorâœ… Smooth 60fps gameplayâœ… NFT holders get perksâœ… Scores saved to databaseâœ… No memory leaks after multiple plays### If FailedâŒ Check useGameAccess.ts (NFT gating)âŒ Verify gameEngine.ts loop cleanupâŒ Check game score API endpoint---## TEST 7: MULTI-LANGUAGE (MEDIUM PRIORITY)### Setup- Open language selector (bottom-right)### Test Cases- [ ] **T7.1** - Switch to Spanish â†’ Nav menu translates- [ ] **T7.2** - Switch to Chinese â†’ UI elements translate- [ ] **T7.3** - Go to Marketplace â†’ Buttons translated- [ ] **T7.4** - Go to Stats â†’ Labels translated- [ ] **T7.5** - No "undefined" or "[object Object]" displayed- [ ] **T7.6** - Switch back to English â†’ Everything reverts### Expected Behaviorâœ… All visible text translatesâœ… No broken keysâœ… Layout doesn't break with longer textâœ… Language persists on refresh### If FailedâŒ Check locale files (en.json, es.json, etc.)âŒ Verify all t('key') callsâŒ Check i18n initialization---## TEST 8: MOBILE RESPONSIVENESS (MEDIUM PRIORITY)### Setup- Open app on mobile device OR Chrome DevTools mobile view- Test with iPhone 12 Pro and Samsung Galaxy S21 sizes### Test Cases- [ ] **T8.1** - Homepage loads correctly- [ ] **T8.2** - Navigation menu accessible (hamburger works)- [ ] **T8.3** - Marketplace cards responsive- [ ] **T8.4** - NFT images load and display correctly- [ ] **T8.5** - Buttons are touch-friendly (min 44px height)- [ ] **T8.6** - Wallet connect modal appears correctly- [ ] **T8.7** - Forms are usable (no zoom-in on input focus)- [ ] **T8.8** - Game playable with touch controls### Expected Behaviorâœ… No horizontal scrollâœ… Touch targets large enoughâœ… Text readable without zoomâœ… Wallet connectivity works### If FailedâŒ Check Tailwind breakpoints (sm:, md:, lg:)âŒ Verify touch-action CSSâŒ Check viewport meta tag---## TEST 9: ERROR HANDLING (HIGH PRIORITY)### Setup- Simulate error conditions### Test Cases- [ ] **T9.1** - Disconnect wallet mid-transaction â†’ Shows error, doesn't crash- [ ] **T9.2** - Insufficient balance â†’ Clear error message- [ ] **T9.3** - Network timeout â†’ Retry option shown- [ ] **T9.4** - Invalid input â†’ Validation message displays- [ ] **T9.5** - Browser console â†’ No uncaught errors- [ ] **T9.6** - Switch networks â†’ Banner prompts to switch back- [ ] **T9.7** - Reject transaction â†’ Returns to previous state### Expected Behaviorâœ… No app crashesâœ… Clear error messagesâœ… Graceful degradationâœ… User can recover from errors### If FailedâŒ Check ErrorBoundary wrappersâŒ Verify error handling in hooksâŒ Check parseContractError utility---## TEST 10: PERFORMANCE & MEMORY (HIGH PRIORITY)### Setup- Open Chrome DevTools â†’ Performance tab- Open browser console### Test Cases- [ ] **T10.1** - Run: `timers()` â†’ Active timers < 20- [ ] **T10.2** - Run: `memReport()` â†’ Memory < 200MB- [ ] **T10.3** - Navigate between pages 10 times â†’ Memory stable- [ ] **T10.4** - Play game 3 times â†’ No memory spike- [ ] **T10.5** - Leave app open 5 minutes â†’ No memory leak- [ ] **T10.6** - Check console â†’ No repeated error logs- [ ] **T10.7** - Check network tab â†’ No failed requests looping### Expected Behaviorâœ… Memory usage stable over timeâœ… Timer count stays lowâœ… No infinite loops or leaksâœ… Efficient resource usage### If FailedâŒ Check useInterval cleanupâŒ Verify useEffect return functionsâŒ Check event listener cleanup---## FINAL SIGN-OFF### Pre-Deploy Checklist- [ ] All 10 test suites passed- [ ] No console errors during testing- [ ] Core integrity verified: `npm run core:verify`- [ ] Database verified: `npm run db:verify`- [ ] Backups created: `npm run core:backup`- [ ] Build succeeds: `npm run build`- [ ] Production build tested locally### Tester Information- **Date**: _______________- **Tester Name**: _______________- **Environment**: Dev / Staging / Production- **Browser**: _______________- **OS**: _______________### Notes_Any issues, warnings, or observations:_â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€**APPROVAL**- [ ] I certify all tests have passed- [ ] I approve deployment to productionSignature: _______________ Date: _______________â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•PART 2: AUTOMATED SMOKE TESTSâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•CREATE: tests/smoke-tests.ts/** * Smoke Tests - Quick automated checks before deployment * Run: tsx tests/smoke-tests.ts */import { ethers } from 'ethers';import fetch from 'node-fetch';const RPC_URL = 'https://mainnet.basedaibridge.com/rpc/';const NFT_CONTRACT = '0xaE51dc5fD1499A129f8654963560f9340773ad59';const MARKETPLACE_CONTRACT = '0x2836f07Ed31a6DEc09E0d62Fb15D7c6c6Ddb139c';const MARKETPLACE_V3_CONTRACT = '0x2a3f9D8b844c2dB2F42095B49817c0D6991514f3';const API_BASE = process.env.API_URL || 'http://localhost:5000';interface TestResult {  name: string;  passed: boolean;  duration: number;  error?: string;}const results: TestResult[] = [];async function test(name: string, fn: () => Promise<void>) {  const start = Date.now();  try {    await fn();    results.push({ name, passed: true, duration: Date.now() - start });    console.log(`âœ… ${name} (${Date.now() - start}ms)`);  } catch (error: any) {    results.push({ name, passed: false, duration: Date.now() - start, error: error.message });    console.error(`âŒ ${name}: ${error.message}`);  }}async function main() {  console.log('\nğŸ§ª Running Smoke Tests...\n');  // Test 1: RPC Connectivity  await test('RPC Endpoint Reachable', async () => {    const provider = new ethers.JsonRpcProvider(RPC_URL);    const blockNumber = await provider.getBlockNumber();    if (blockNumber === 0) throw new Error('Block number is 0');  });  // Test 2: NFT Contract Deployed  await test('NFT Contract Exists', async () => {    const provider = new ethers.JsonRpcProvider(RPC_URL);    const code = await provider.getCode(NFT_CONTRACT);    if (code === '0x') throw new Error('Contract not deployed');  });  // Test 3: Marketplace Contract Deployed  await test('Marketplace V2 Exists', async () => {    const provider = new ethers.JsonRpcProvider(RPC_URL);    const code = await provider.getCode(MARKETPLACE_CONTRACT);    if (code === '0x') throw new Error('Contract not deployed');  });  // Test 4: Marketplace V3 Contract Deployed  await test('Marketplace V3 Exists', async () => {    const provider = new ethers.JsonRpcProvider(RPC_URL);    const code = await provider.getCode(MARKETPLACE_V3_CONTRACT);    if (code === '0x') throw new Error('Contract not deployed');  });  // Test 5: Total Supply Readable  await test('NFT Total Supply Readable', async () => {    const provider = new ethers.JsonRpcProvider(RPC_URL);    const nft = new ethers.Contract(      NFT_CONTRACT,      ['function totalSupply() view returns (uint256)'],      provider    );    const supply = await nft.totalSupply();    if (supply < 0) throw new Error('Invalid supply');  });  // Test 6: Mint Price Correct  await test('Mint Price is 69,420 $BASED', async () => {    const provider = new ethers.JsonRpcProvider(RPC_URL);    const nft = new ethers.Contract(      NFT_CONTRACT,      ['function MINT_PRICE() view returns (uint256)'],      provider    );    const price = await nft.MINT_PRICE();    const expected = ethers.parseEther('69420');    if (price !== expected) {      throw new Error(`Mint price is ${ethers.formatEther(price)}, expected 69420`);    }  });  // Test 7: API Health Check  await test('API Health Endpoint', async () => {    const response = await fetch(`${API_BASE}/api/health`);    if (response.status !== 200) throw new Error(`Status ${response.status}`);  });  // Test 8: Profile API Works  await test('Profile API Responds', async () => {    const response = await fetch(`${API_BASE}/api/profile/check-name/test123`);    if (response.status !== 200) throw new Error(`Status ${response.status}`);    const data = await response.json();    if (!('available' in data)) throw new Error('Invalid response format');  });  // Test 9: Rate Limiting Active  await test('Rate Limiting Active', async () => {    // Make 105 rapid requests (should hit limit at 100)    const promises = [];    for (let i = 0; i < 105; i++) {      promises.push(fetch(`${API_BASE}/api/health`));    }    const responses = await Promise.all(promises);    const rateLimited = responses.filter(r => r.status === 429);    if (rateLimited.length === 0) {      throw new Error('Rate limiting not working');    }  });  // Test 10: Database Connection  await test('Database Accessible', async () => {    const response = await fetch(`${API_BASE}/api/profile/check-name/smoketest${Date.now()}`);    if (response.status !== 200) throw new Error('DB connection failed');  });  // Summary  console.log('\n' + '='.repeat(50));  console.log('SMOKE TEST SUMMARY');  console.log('='.repeat(50));    const passed = results.filter(r => r.passed).length;  const failed = results.filter(r => !r.passed).length;  const totalTime = results.reduce((sum, r) => sum + r.duration, 0);    console.log(`\nTotal: ${results.length} tests`);  console.log(`âœ… Passed: ${passed}`);  console.log(`âŒ Failed: ${failed}`);  console.log(`â±ï¸  Duration: ${totalTime}ms`);    if (failed > 0) {    console.log('\nâŒ FAILED TESTS:');    results.filter(r => !r.passed).forEach(r => {      console.log(`  - ${r.name}: ${r.error}`);    });    process.exit(1);  }    console.log('\nâœ… All smoke tests passed!\n');  process.exit(0);}main().catch(error => {  console.error('\nâŒ Smoke tests failed:', error);  process.exit(1);});ADD TO package.json:"scripts": {  "test:smoke": "tsx tests/smoke-tests.ts",  "pre-deploy": "npm run core:verify && npm run test:smoke && npm run build"}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•VERIFICATIONâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•1. Run smoke tests:   npm run test:smoke   # Should pass all 10 tests in < 5 seconds2. Run manual test protocol:   # Follow MANUAL_TEST_PROTOCOL.md   # Check all boxes   # Document any failures3. Verify pre-deploy script:   npm run pre-deploy   # Should run: core:verify â†’ test:smoke â†’ build   # Should complete successfullyCHECKLIST:â–¡ MANUAL_TEST_PROTOCOL.md createdâ–¡ smoke-tests.ts createdâ–¡ All 10 smoke tests passâ–¡ Manual protocol documentedâ–¡ pre-deploy script worksâ–¡ Test results loggedâ–¡ Ready for production deployment
