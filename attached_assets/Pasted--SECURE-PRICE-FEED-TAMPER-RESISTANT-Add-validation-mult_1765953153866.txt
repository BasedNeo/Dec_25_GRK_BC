=== SECURE PRICE FEED - TAMPER-RESISTANT ===

Add validation, multi-source verification, and integrity checks
to prevent corrupted or manipulated price data.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
REPLACE: /client/src/hooks/usePriceTicker.ts
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import { useState, useEffect, useCallback, useRef } from 'react';

// ============================================
// SECURITY CONFIGURATION
// ============================================

const SECURITY_CONFIG = {
  // Maximum allowed price change between fetches (50%)
  MAX_PRICE_CHANGE_PERCENT: 50,
  
  // Maximum allowed difference between sources (5%)
  MAX_SOURCE_DIVERGENCE_PERCENT: 5,
  
  // Price bounds (sanity checks)
  PRICE_BOUNDS: {
    BTC: { min: 1000, max: 1000000 },      // $1K - $1M
    ETH: { min: 100, max: 100000 },         // $100 - $100K
    SOL: { min: 1, max: 10000 },            // $1 - $10K
    BNB: { min: 10, max: 10000 },           // $10 - $10K
    XRP: { min: 0.01, max: 100 },           // $0.01 - $100
    ADA: { min: 0.01, max: 100 },           // $0.01 - $100
    DOGE: { min: 0.001, max: 10 },          // $0.001 - $10
    DOT: { min: 0.1, max: 1000 },           // $0.1 - $1K
    AVAX: { min: 1, max: 10000 },           // $1 - $10K
    LINK: { min: 0.1, max: 1000 },          // $0.1 - $1K
  } as Record<string, { min: number; max: number }>,
  
  // Maximum cache age before considered stale (5 minutes)
  MAX_CACHE_AGE_MS: 300000,
  
  // Require verification from multiple sources
  REQUIRE_MULTI_SOURCE: true,
  
  // Minimum sources that must agree
  MIN_AGREEING_SOURCES: 2,
};

interface TickerAsset {
  id: string;
  symbol: string;
  name: string;
  binanceSymbol: string;
  logo?: string;
}

interface PriceData {
  symbol: string;
  price: number;
  change24h: number;
  logo?: string;
  source: string;
  verified: boolean;
  timestamp: number;
}

interface ValidationResult {
  valid: boolean;
  reason?: string;
  correctedPrice?: number;
}

// ============================================
// VALIDATION FUNCTIONS
// ============================================

function validatePriceBounds(symbol: string, price: number): ValidationResult {
  const bounds = SECURITY_CONFIG.PRICE_BOUNDS[symbol];
  
  if (!bounds) {
    // Unknown symbol - allow but flag as unverified
    return { valid: true };
  }
  
  if (price < bounds.min) {
    return { 
      valid: false, 
      reason: `${symbol} price $${price} below minimum $${bounds.min}` 
    };
  }
  
  if (price > bounds.max) {
    return { 
      valid: false, 
      reason: `${symbol} price $${price} above maximum $${bounds.max}` 
    };
  }
  
  return { valid: true };
}

function validatePriceChange(
  symbol: string, 
  newPrice: number, 
  oldPrice: number | undefined
): ValidationResult {
  if (!oldPrice || oldPrice === 0) return { valid: true };
  
  const changePercent = Math.abs((newPrice - oldPrice) / oldPrice) * 100;
  
  if (changePercent > SECURITY_CONFIG.MAX_PRICE_CHANGE_PERCENT) {
    return {
      valid: false,
      reason: `${symbol} price changed ${changePercent.toFixed(1)}% (max ${SECURITY_CONFIG.MAX_PRICE_CHANGE_PERCENT}%)`,
    };
  }
  
  return { valid: true };
}

function validateSourceAgreement(
  symbol: string,
  prices: { source: string; price: number }[]
): ValidationResult {
  if (prices.length < 2) {
    return { valid: !SECURITY_CONFIG.REQUIRE_MULTI_SOURCE };
  }
  
  // Calculate average
  const avg = prices.reduce((sum, p) => sum + p.price, 0) / prices.length;
  
  // Check all prices are within tolerance of average
  const maxDivergence = SECURITY_CONFIG.MAX_SOURCE_DIVERGENCE_PERCENT;
  const allAgree = prices.every(p => {
    const divergence = Math.abs((p.price - avg) / avg) * 100;
    return divergence <= maxDivergence;
  });
  
  if (!allAgree) {
    return {
      valid: false,
      reason: `${symbol} sources disagree: ${prices.map(p => `${p.source}=$${p.price}`).join(', ')}`,
    };
  }
  
  return { valid: true, correctedPrice: avg };
}

// ============================================
// SECURE CACHE WITH INTEGRITY CHECK
// ============================================

const CACHE_KEY = 'ticker_prices_secure';
const CACHE_HASH_KEY = 'ticker_prices_hash';

function hashData(data: string): string {
  // Simple hash for integrity check (not cryptographic, but catches tampering)
  let hash = 0;
  for (let i = 0; i < data.length; i++) {
    const char = data.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash.toString(36);
}

function setSecureCache(data: Record<string, PriceData>): void {
  const json = JSON.stringify({ data, timestamp: Date.now() });
  const hash = hashData(json);
  
  try {
    localStorage.setItem(CACHE_KEY, json);
    localStorage.setItem(CACHE_HASH_KEY, hash);
  } catch (e) {
    // Storage full or blocked - continue without cache
  }
}

function getSecureCache(): { data: Record<string, PriceData>; valid: boolean } | null {
  try {
    const json = localStorage.getItem(CACHE_KEY);
    const storedHash = localStorage.getItem(CACHE_HASH_KEY);
    
    if (!json || !storedHash) return null;
    
    // Verify integrity
    const computedHash = hashData(json);
    if (computedHash !== storedHash) {
      console.warn('üö® Cache integrity check failed - data may be tampered');
      localStorage.removeItem(CACHE_KEY);
      localStorage.removeItem(CACHE_HASH_KEY);
      return null;
    }
    
    const parsed = JSON.parse(json);
    
    // Check staleness
    if (Date.now() - parsed.timestamp > SECURITY_CONFIG.MAX_CACHE_AGE_MS) {
      return { data: parsed.data, valid: false }; // Stale but usable as fallback
    }
    
    return { data: parsed.data, valid: true };
  } catch (e) {
    return null;
  }
}

// ============================================
// API FETCHERS WITH ERROR HANDLING
// ============================================

async function fetchFromBinance(
  symbols: string[]
): Promise<Map<string, { price: number; change: number }>> {
  const results = new Map();
  
  try {
    const symbolsParam = symbols.map(s => `"${s}"`).join(',');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000); // 5s timeout
    
    const response = await fetch(
      `https://api.binance.com/api/v3/ticker/24hr?symbols=[${symbolsParam}]`,
      { signal: controller.signal }
    );
    
    clearTimeout(timeout);
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const data = await response.json();
    
    if (!Array.isArray(data)) throw new Error('Invalid response format');
    
    data.forEach((ticker: any) => {
      if (ticker.symbol && ticker.lastPrice) {
        const price = parseFloat(ticker.lastPrice);
        const change = parseFloat(ticker.priceChangePercent || '0');
        
        if (!isNaN(price) && price > 0) {
          results.set(ticker.symbol, { price, change });
        }
      }
    });
    
    return results;
  } catch (e) {
    console.warn('Binance fetch failed:', e);
    return results;
  }
}

async function fetchFromCoinGecko(
  ids: string[]
): Promise<Map<string, { price: number; change: number }>> {
  const results = new Map();
  
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000);
    
    const response = await fetch(
      `https://api.coingecko.com/api/v3/simple/price?ids=${ids.join(',')}&vs_currencies=usd&include_24hr_change=true`,
      { signal: controller.signal }
    );
    
    clearTimeout(timeout);
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const data = await response.json();
    
    Object.entries(data).forEach(([id, info]: [string, any]) => {
      const price = info?.usd;
      const change = info?.usd_24h_change || 0;
      
      if (typeof price === 'number' && price > 0) {
        results.set(id, { price, change });
      }
    });
    
    return results;
  } catch (e) {
    console.warn('CoinGecko fetch failed:', e);
    return results;
  }
}

// Third source for extra verification
async function fetchFromCoinbase(
  symbols: string[]
): Promise<Map<string, { price: number; change: number }>> {
  const results = new Map();
  
  try {
    // Coinbase uses different symbols
    const coinbaseMap: Record<string, string> = {
      'BTC': 'BTC-USD',
      'ETH': 'ETH-USD',
      'SOL': 'SOL-USD',
    };
    
    for (const symbol of symbols) {
      const pair = coinbaseMap[symbol];
      if (!pair) continue;
      
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 3000);
      
      const response = await fetch(
        `https://api.coinbase.com/v2/prices/${pair}/spot`,
        { signal: controller.signal }
      );
      
      clearTimeout(timeout);
      
      if (!response.ok) continue;
      
      const data = await response.json();
      const price = parseFloat(data?.data?.amount);
      
      if (!isNaN(price) && price > 0) {
        results.set(symbol, { price, change: 0 }); // Coinbase doesn't give 24h change easily
      }
    }
    
    return results;
  } catch (e) {
    return results;
  }
}

// ============================================
// MAIN HOOK
// ============================================

const DEFAULT_ASSETS: TickerAsset[] = [
  { id: 'bitcoin', symbol: 'BTC', name: 'Bitcoin', binanceSymbol: 'BTCUSDT', logo: 'https://assets.coingecko.com/coins/images/1/small/bitcoin.png' },
  { id: 'ethereum', symbol: 'ETH', name: 'Ethereum', binanceSymbol: 'ETHUSDT', logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
];

export const AVAILABLE_ASSETS: TickerAsset[] = [
  { id: 'bitcoin', symbol: 'BTC', name: 'Bitcoin', binanceSymbol: 'BTCUSDT', logo: 'https://assets.coingecko.com/coins/images/1/small/bitcoin.png' },
  { id: 'ethereum', symbol: 'ETH', name: 'Ethereum', binanceSymbol: 'ETHUSDT', logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
  { id: 'solana', symbol: 'SOL', name: 'Solana', binanceSymbol: 'SOLUSDT', logo: 'https://assets.coingecko.com/coins/images/4128/small/solana.png' },
  { id: 'binancecoin', symbol: 'BNB', name: 'BNB', binanceSymbol: 'BNBUSDT', logo: 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png' },
  { id: 'ripple', symbol: 'XRP', name: 'XRP', binanceSymbol: 'XRPUSDT', logo: 'https://assets.coingecko.com/coins/images/44/small/xrp-symbol-white-128.png' },
  { id: 'cardano', symbol: 'ADA', name: 'Cardano', binanceSymbol: 'ADAUSDT', logo: 'https://assets.coingecko.com/coins/images/975/small/cardano.png' },
  { id: 'dogecoin', symbol: 'DOGE', name: 'Dogecoin', binanceSymbol: 'DOGEUSDT', logo: 'https://assets.coingecko.com/coins/images/5/small/dogecoin.png' },
  { id: 'polkadot', symbol: 'DOT', name: 'Polkadot', binanceSymbol: 'DOTUSDT', logo: 'https://assets.coingecko.com/coins/images/12171/small/polkadot.png' },
  { id: 'avalanche-2', symbol: 'AVAX', name: 'Avalanche', binanceSymbol: 'AVAXUSDT', logo: 'https://assets.coingecko.com/coins/images/12559/small/Avalanche_Circle_RedWhite_Trans.png' },
  { id: 'chainlink', symbol: 'LINK', name: 'Chainlink', binanceSymbol: 'LINKUSDT', logo: 'https://assets.coingecko.com/coins/images/877/small/chainlink-new-logo.png' },
];

const STORAGE_KEY = 'ticker_assets';
const ROTATE_INTERVAL = 3000;
const FETCH_INTERVAL = 15000; // 15 seconds

export function usePriceTicker() {
  const [prices, setPrices] = useState<Map<string, PriceData>>(new Map());
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedAssets, setSelectedAssets] = useState<TickerAsset[]>(DEFAULT_ASSETS);
  const [securityStatus, setSecurityStatus] = useState<'verified' | 'single-source' | 'stale' | 'error'>('verified');
  const [lastError, setLastError] = useState<string | null>(null);
  const previousPrices = useRef<Map<string, number>>(new Map());
  const lastFetch = useRef<number>(0);

  // Load preferences and cached prices
  useEffect(() => {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      try {
        const ids = JSON.parse(stored) as string[];
        const assets = ids
          .map(id => AVAILABLE_ASSETS.find(a => a.id === id))
          .filter(Boolean) as TickerAsset[];
        if (assets.length >= 2) setSelectedAssets(assets);
      } catch {}
    }

    // Load verified cache
    const cache = getSecureCache();
    if (cache) {
      const priceMap = new Map<string, PriceData>();
      Object.entries(cache.data).forEach(([symbol, data]) => {
        priceMap.set(symbol, data);
        previousPrices.current.set(symbol, data.price);
      });
      setPrices(priceMap);
      setSecurityStatus(cache.valid ? 'verified' : 'stale');
      setIsLoading(false);
    }
  }, []);

  // Secure fetch with multi-source verification
  const fetchPrices = useCallback(async () => {
    if (Date.now() - lastFetch.current < 5000) return;
    lastFetch.current = Date.now();

    const symbols = selectedAssets.map(a => a.symbol);
    const binanceSymbols = selectedAssets.map(a => a.binanceSymbol);
    const geckoIds = selectedAssets.map(a => a.id);

    // Fetch from multiple sources in parallel
    const [binanceData, geckoData, coinbaseData] = await Promise.all([
      fetchFromBinance(binanceSymbols),
      fetchFromCoinGecko(geckoIds),
      fetchFromCoinbase(symbols),
    ]);

    const priceMap = new Map<string, PriceData>();
    const cacheData: Record<string, PriceData> = {};
    let allVerified = true;
    const errors: string[] = [];

    for (const asset of selectedAssets) {
      const sourcePrices: { source: string; price: number; change: number }[] = [];

      // Collect prices from each source
      const binance = binanceData.get(asset.binanceSymbol);
      if (binance) sourcePrices.push({ source: 'binance', ...binance });

      const gecko = geckoData.get(asset.id);
      if (gecko) sourcePrices.push({ source: 'coingecko', ...gecko });

      const coinbase = coinbaseData.get(asset.symbol);
      if (coinbase) sourcePrices.push({ source: 'coinbase', ...coinbase });

      if (sourcePrices.length === 0) {
        errors.push(`No data for ${asset.symbol}`);
        continue;
      }

      // Use primary source (Binance) or average
      let finalPrice = sourcePrices[0].price;
      let finalChange = sourcePrices[0].change;
      let verified = false;

      // Validate bounds
      const boundsCheck = validatePriceBounds(asset.symbol, finalPrice);
      if (!boundsCheck.valid) {
        errors.push(boundsCheck.reason!);
        continue;
      }

      // Validate rate of change
      const previousPrice = previousPrices.current.get(asset.symbol);
      const changeCheck = validatePriceChange(asset.symbol, finalPrice, previousPrice);
      if (!changeCheck.valid) {
        errors.push(changeCheck.reason!);
        // Use previous price as fallback
        finalPrice = previousPrice || finalPrice;
      }

      // Multi-source verification
      if (sourcePrices.length >= 2) {
        const sourceCheck = validateSourceAgreement(
          asset.symbol,
          sourcePrices.map(s => ({ source: s.source, price: s.price }))
        );
        
        if (sourceCheck.valid) {
          verified = true;
          if (sourceCheck.correctedPrice) {
            finalPrice = sourceCheck.correctedPrice;
          }
        } else {
          errors.push(sourceCheck.reason!);
          allVerified = false;
        }
      } else {
        allVerified = false;
      }

      const priceData: PriceData = {
        symbol: asset.symbol,
        price: finalPrice,
        change24h: finalChange,
        logo: asset.logo,
        source: sourcePrices.map(s => s.source).join('+'),
        verified,
        timestamp: Date.now(),
      };

      priceMap.set(asset.symbol, priceData);
      cacheData[asset.symbol] = priceData;
      previousPrices.current.set(asset.symbol, finalPrice);
    }

    // Update state
    setPrices(priceMap);
    setSecurityStatus(
      priceMap.size === 0 ? 'error' :
      allVerified ? 'verified' :
      'single-source'
    );
    setLastError(errors.length > 0 ? errors[0] : null);
    setIsLoading(false);

    // Save to secure cache
    if (priceMap.size > 0) {
      setSecureCache(cacheData);
    }
  }, [selectedAssets]);

  // Fetch on mount and interval
  useEffect(() => {
    fetchPrices();
    const interval = setInterval(fetchPrices, FETCH_INTERVAL);
    return () => clearInterval(interval);
  }, [fetchPrices]);

  // Rotate display
  useEffect(() => {