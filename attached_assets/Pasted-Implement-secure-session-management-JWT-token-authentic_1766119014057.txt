Implement secure session management, JWT token authentication, signature verification for wallet-based auth, anti-CSRF protection, and secure header management.

STEP 1: CREATE SESSION MANAGER

1. CREATE FILE: server/lib/sessionManager.ts

import crypto from 'crypto';

interface Session {
  id: string;
  walletAddress: string;
  createdAt: number;
  expiresAt: number;
  lastActivity: number;
  ipAddress: string;
  userAgent: string;
  isAdmin: boolean;
}

export class SessionManager {
  private static sessions: Map<string, Session> = new Map();
  private static readonly SESSION_DURATION = 24 * 60 * 60 * 1000; // 24 hours
  private static readonly INACTIVITY_TIMEOUT = 60 * 60 * 1000; // 1 hour
  
  static createSession(
    walletAddress: string, 
    ipAddress: string, 
    userAgent: string,
    isAdmin: boolean = false
  ): string {
    const sessionId = crypto.randomBytes(32).toString('hex');
    const now = Date.now();
    
    const session: Session = {
      id: sessionId,
      walletAddress: walletAddress.toLowerCase(),
      createdAt: now,
      expiresAt: now + this.SESSION_DURATION,
      lastActivity: now,
      ipAddress,
      userAgent,
      isAdmin
    };
    
    this.sessions.set(sessionId, session);
    
    console.log(`[SESSION] Created session for ${walletAddress}: ${sessionId}`);
    
    return sessionId;
  }
  
  static validateSession(sessionId: string): Session | null {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      return null;
    }
    
    const now = Date.now();
    
    if (now > session.expiresAt) {
      console.log(`[SESSION] Expired session: ${sessionId}`);
      this.sessions.delete(sessionId);
      return null;
    }
    
    if (now - session.lastActivity > this.INACTIVITY_TIMEOUT) {
      console.log(`[SESSION] Inactive session: ${sessionId}`);
      this.sessions.delete(sessionId);
      return null;
    }
    
    session.lastActivity = now;
    
    return session;
  }
  
  static refreshSession(sessionId: string): boolean {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      return false;
    }
    
    const now = Date.now();
    session.expiresAt = now + this.SESSION_DURATION;
    session.lastActivity = now;
    
    return true;
  }
  
  static destroySession(sessionId: string): boolean {
    const deleted = this.sessions.delete(sessionId);
    
    if (deleted) {
      console.log(`[SESSION] Destroyed session: ${sessionId}`);
    }
    
    return deleted;
  }
  
  static destroyAllUserSessions(walletAddress: string): number {
    const lowerAddress = walletAddress.toLowerCase();
    let count = 0;
    
    for (const [sessionId, session] of this.sessions.entries()) {
      if (session.walletAddress === lowerAddress) {
        this.sessions.delete(sessionId);
        count++;
      }
    }
    
    console.log(`[SESSION] Destroyed ${count} sessions for ${walletAddress}`);
    
    return count;
  }
  
  static getActiveSessions(): Session[] {
    const now = Date.now();
    const active: Session[] = [];
    
    for (const [sessionId, session] of this.sessions.entries()) {
      if (now <= session.expiresAt && now - session.lastActivity <= this.INACTIVITY_TIMEOUT) {
        active.push(session);
      } else {
        this.sessions.delete(sessionId);
      }
    }
    
    return active;
  }
  
  static getUserSessions(walletAddress: string): Session[] {
    const lowerAddress = walletAddress.toLowerCase();
    return this.getActiveSessions().filter(s => s.walletAddress === lowerAddress);
  }
  
  static cleanupExpiredSessions(): number {
    const now = Date.now();
    let cleaned = 0;
    
    for (const [sessionId, session] of this.sessions.entries()) {
      if (now > session.expiresAt || now - session.lastActivity > this.INACTIVITY_TIMEOUT) {
        this.sessions.delete(sessionId);
        cleaned++;
      }
    }
    
    if (cleaned > 0) {
      console.log(`[SESSION] Cleaned up ${cleaned} expired sessions`);
    }
    
    return cleaned;
  }
  
  static getStats() {
    const sessions = this.getActiveSessions();
    const uniqueUsers = new Set(sessions.map(s => s.walletAddress)).size;
    const adminSessions = sessions.filter(s => s.isAdmin).length;
    
    return {
      total: sessions.length,
      uniqueUsers,
      adminSessions,
      regularSessions: sessions.length - adminSessions
    };
  }
}

setInterval(() => {
  SessionManager.cleanupExpiredSessions();
}, 5 * 60 * 1000);

STEP 2: CREATE SIGNATURE VERIFIER

2. CREATE FILE: server/lib/signatureVerifier.ts

import { ethers } from 'ethers';

export class SignatureVerifier {
  static verifySignature(
    message: string,
    signature: string,
    expectedAddress: string
  ): boolean {
    try {
      const recoveredAddress = ethers.verifyMessage(message, signature);
      
      const match = recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
      
      if (!match) {
        console.warn(`[AUTH] Signature mismatch: expected ${expectedAddress}, got ${recoveredAddress}`);
      }
      
      return match;
    } catch (error) {
      console.error('[AUTH] Signature verification failed:', error);
      return false;
    }
  }
  
  static generateNonce(): string {
    return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
  }
  
  static createSignInMessage(walletAddress: string, nonce: string): string {
    return `Sign this message to authenticate with Guardian Command.\n\nWallet: ${walletAddress}\nNonce: ${nonce}\nTimestamp: ${new Date().toISOString()}`;
  }
  
  static verifyMessageAge(message: string, maxAgeMinutes: number = 5): boolean {
    const timestampMatch = message.match(/Timestamp: (.+)/);
    
    if (!timestampMatch) {
      console.warn('[AUTH] No timestamp found in message');
      return false;
    }
    
    try {
      const timestamp = new Date(timestampMatch[1]).getTime();
      const now = Date.now();
      const age = now - timestamp;
      const maxAge = maxAgeMinutes * 60 * 1000;
      
      if (age > maxAge) {
        console.warn(`[AUTH] Message too old: ${age}ms (max: ${maxAge}ms)`);
        return false;
      }
      
      if (age < 0) {
        console.warn('[AUTH] Message timestamp is in the future');
        return false;
      }
      
      return true;
    } catch (error) {
      console.error('[AUTH] Failed to verify message age:', error);
      return false;
    }
  }
}

STEP 3: CREATE NONCE MANAGER

3. CREATE FILE: server/lib/nonceManager.ts

interface Nonce {
  value: string;
  walletAddress: string;
  createdAt: number;
  used: boolean;
}

export class NonceManager {
  private static nonces: Map<string, Nonce> = new Map();
  private static readonly NONCE_EXPIRY = 5 * 60 * 1000; // 5 minutes
  
  static createNonce(walletAddress: string): string {
    const value = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
    
    const nonce: Nonce = {
      value,
      walletAddress: walletAddress.toLowerCase(),
      createdAt: Date.now(),
      used: false
    };
    
    this.nonces.set(value, nonce);
    
    this.cleanupExpiredNonces();
    
    return value;
  }
  
  static validateNonce(value: string, walletAddress: string): boolean {
    const nonce = this.nonces.get(value);
    
    if (!nonce) {
      console.warn(`[AUTH] Nonce not found: ${value}`);
      return false;
    }
    
    if (nonce.used) {
      console.warn(`[AUTH] Nonce already used: ${value}`);
      return false;
    }
    
    if (nonce.walletAddress !== walletAddress.toLowerCase()) {
      console.warn(`[AUTH] Nonce wallet mismatch: expected ${nonce.walletAddress}, got ${walletAddress}`);
      return false;
    }
    
    const age = Date.now() - nonce.createdAt;
    if (age > this.NONCE_EXPIRY) {
      console.warn(`[AUTH] Nonce expired: ${value} (age: ${age}ms)`);
      this.nonces.delete(value);
      return false;
    }
    
    nonce.used = true;
    
    setTimeout(() => {
      this.nonces.delete(value);
    }, 60000);
    
    return true;
  }
  
  static cleanupExpiredNonces(): void {
    const now = Date.now();
    let cleaned = 0;
    
    for (const [value, nonce] of this.nonces.entries()) {
      if (now - nonce.createdAt > this.NONCE_EXPIRY || nonce.used) {
        this.nonces.delete(value);
        cleaned++;
      }
    }
    
    if (cleaned > 0) {
      console.log(`[AUTH] Cleaned up ${cleaned} expired nonces`);
    }
  }
  
  static getStats() {
    const now = Date.now();
    const active = Array.from(this.nonces.values()).filter(
      n => !n.used && now - n.createdAt <= this.NONCE_EXPIRY
    );
    
    return {
      total: this.nonces.size,
      active: active.length,
      used: this.nonces.size - active.length
    };
  }
}

setInterval(() => {
  NonceManager.cleanupExpiredNonces();
}, 60 * 1000);

STEP 4: CREATE AUTH MIDDLEWARE

4. CREATE FILE: server/middleware/auth.ts

import { Request, Response, NextFunction } from 'express';
import { SessionManager } from '../lib/sessionManager';

export interface AuthRequest extends Request {
  session?: {
    id: string;
    walletAddress: string;
    isAdmin: boolean;
  };
}

export function requireAuth(req: AuthRequest, res: Response, next: NextFunction) {
  const sessionId = req.headers['x-session-id'] as string;
  
  if (!sessionId) {
    return res.status(401).json({ 
      error: 'Authentication required',
      code: 'NO_SESSION' 
    });
  }
  
  const session = SessionManager.validateSession(sessionId);
  
  if (!session) {
    return res.status(401).json({ 
      error: 'Invalid or expired session',
      code: 'INVALID_SESSION' 
    });
  }
  
  req.session = {
    id: session.id,
    walletAddress: session.walletAddress,
    isAdmin: session.isAdmin
  };
  
  next();
}

export function requireAdmin(req: AuthRequest, res: Response, next: NextFunction) {
  requireAuth(req, res, () => {
    if (!req.session?.isAdmin) {
      return res.status(403).json({ 
        error: 'Admin access required',
        code: 'NOT_ADMIN' 
      });
    }
    next();
  });
}

export function optionalAuth(req: AuthRequest, res: Response, next: NextFunction) {
  const sessionId = req.headers['x-session-id'] as string;
  
  if (sessionId) {
    const session = SessionManager.validateSession(sessionId);
    if (session) {
      req.session = {
        id: session.id,
        walletAddress: session.walletAddress,
        isAdmin: session.isAdmin
      };
    }
  }
  
  next();
}

STEP 5: ADD AUTH ENDPOINTS

5. UPDATE FILE: server/routes.ts

Add imports:

import { SessionManager } from './lib/sessionManager';
import { SignatureVerifier } from './lib/signatureVerifier';
import { NonceManager } from './lib/nonceManager';
import { requireAuth, requireAdmin, optionalAuth, AuthRequest } from './middleware/auth';

Add auth endpoints:

app.post('/api/auth/nonce', async (req, res) => {
  try {
    const { walletAddress } = req.body;
    
    if (!walletAddress || !/^0x[a-fA-F0-9]{40}$/.test(walletAddress)) {
      return res.status(400).json({ error: 'Invalid wallet address' });
    }
    
    const nonce = NonceManager.createNonce(walletAddress);
    const message = SignatureVerifier.createSignInMessage(walletAddress, nonce);
    
    res.json({ nonce, message });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/auth/verify', async (req, res) => {
  try {
    const { walletAddress, signature, message, nonce } = req.body;
    
    if (!walletAddress || !signature || !message || !nonce) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    if (!SignatureVerifier.verifyMessageAge(message, 5)) {
      return res.status(400).json({ error: 'Message expired' });
    }
    
    if (!NonceManager.validateNonce(nonce, walletAddress)) {
      return res.status(400).json({ error: 'Invalid or expired nonce' });
    }
    
    if (!SignatureVerifier.verifySignature(message, signature, walletAddress)) {
      return res.status(401).json({ error: 'Invalid signature' });
    }
    
    const ipAddress = req.ip || 'unknown';
    const userAgent = req.get('user-agent') || 'unknown';
    
    const adminAddresses = (process.env.ADMIN_ADDRESSES || '').split(',').map(a => a.toLowerCase());
    const isAdmin = adminAddresses.includes(walletAddress.toLowerCase());
    
    const sessionId = SessionManager.createSession(walletAddress, ipAddress, userAgent, isAdmin);
    
    res.json({ 
      sessionId,
      walletAddress,
      isAdmin,
      expiresIn: 24 * 60 * 60 * 1000
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/auth/refresh', requireAuth, async (req: AuthRequest, res) => {
  try {
    const sessionId = req.session!.id;
    const refreshed = SessionManager.refreshSession(sessionId);
    
    if (!refreshed) {
      return res.status(401).json({ error: 'Failed to refresh session' });
    }
    
    res.json({ 
      success: true,
      expiresIn: 24 * 60 * 60 * 1000
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/auth/logout', requireAuth, async (req: AuthRequest, res) => {
  try {
    const sessionId = req.session!.id;
    SessionManager.destroySession(sessionId);
    
    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/auth/sessions', requireAuth, async (req: AuthRequest, res) => {
  try {
    const sessions = SessionManager.getUserSessions(req.session!.walletAddress);
    
    res.json({ 
      sessions: sessions.map(s => ({
        id: s.id,
        createdAt: new Date(s.createdAt),
        lastActivity: new Date(s.lastActivity),
        ipAddress: s.ipAddress,
        userAgent: s.userAgent
      }))
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/auth/sessions/:sessionId', requireAuth, async (req: AuthRequest, res) => {
  try {
    const { sessionId } = req.params;
    SessionManager.destroySession(sessionId);
    
    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/sessions/stats', requireAdmin, async (req, res) => {
  try {
    const stats = SessionManager.getStats();
    const nonceStats = NonceManager.getStats();
    
    res.json({ 
      sessions: stats,
      nonces: nonceStats
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/sessions/active', requireAdmin, async (req, res) => {
  try {
    const sessions = SessionManager.getActiveSessions();
    
    res.json({ 
      sessions: sessions.map(s => ({
        id: s.id,
        walletAddress: s.walletAddress,
        isAdmin: s.isAdmin,
        createdAt: new Date(s.createdAt),
        lastActivity: new Date(s.lastActivity),
        ipAddress: s.ipAddress
      }))
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

STEP 6: UPDATE EXISTING ROUTES WITH AUTH

6. UPDATE FILE: server/routes.ts

Replace existing isAdmin and isAuthenticated checks with new middleware:

// Example: Custom names
app.post('/api/custom-names', requireAuth, async (req: AuthRequest, res) => {
  const walletAddress = req.session!.walletAddress;
  // existing logic
});

// Example: Proposals
app.post('/api/proposals', requireAdmin, async (req: AuthRequest, res) => {
  // existing logic
});

// Example: Profile (optional auth)
app.get('/api/profile/:walletAddress', optionalAuth, async (req: AuthRequest, res) => {
  // existing logic
});

STEP 7: CREATE SESSION MONITOR COMPONENT

7. CREATE FILE: client/src/components/SessionMonitor.tsx

import { useEffect, useState } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Clock, Users, Shield } from 'lucide-react';

export const SessionMonitor = () => {
  const [stats, setStats] = useState<any>(null);
  const [sessions, setSessions] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchData();
    const interval = setInterval(fetchData, 10000);
    return () => clearInterval(interval);
  }, []);
  
  const fetchData = async () => {
    try {
      const [statsRes, sessionsRes] = await Promise.all([
        fetch('/api/admin/sessions/stats'),
        fetch('/api/admin/sessions/active')
      ]);
      
      const statsData = await statsRes.json();
      const sessionsData = await sessionsRes.json();
      
      setStats(statsData);
      setSessions(sessionsData.sessions || []);
    } catch (error) {
      console.error('Failed to fetch session data:', error);
    } finally {
      setLoading(false);
    }
  };
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div className="space-y-6">
      <div className="grid grid-cols-3 gap-4">
        <Card className="p-4 bg-black/60 border-purple-500/30">
          <div className="flex items-center gap-2 mb-2">
            <Users className="w-5 h-5 text-purple-400" />
            <span className="text-sm text-gray-400">Active Sessions</span>
          </div>
          <div className="text-3xl font-bold">{stats?.sessions?.total || 0}</div>
        </Card>
        
        <Card className="p-4 bg-black/60 border-blue-500/30">
          <div className="flex items-center gap-2 mb-2">
            <Users className="w-5 h-5 text-blue-400" />
            <span className="text-sm text-gray-400">Unique Users</span>
          </div>
          <div className="text-3xl font-bold">{stats?.sessions?.uniqueUsers || 0}</div>
        </Card>
        
        <Card className="p-4 bg-black/60 border-green-500/30">
          <div className="flex items-center gap-2 mb-2">
            <Shield className="w-5 h-5 text-green-400" />
            <span className="text-sm text-gray-400">Admin Sessions</span>
          </div>
          <div className="text-3xl font-bold">{stats?.sessions?.adminSessions || 0}</div>
        </Card>
      </div>
      
      <Card className="p-6 bg-black/60 border-purple-500/30">
        <h3 className="text-xl font-bold mb-4">Active Sessions</h3>
        
        {sessions.length === 0 ? (
          <div className="text-gray-400">No active sessions</div>
        ) : (
          <div className="space-y-2">
            {sessions.map((session) => (
              <div key={session.id} className="p-3 bg-black/40 rounded border border-purple-500/20">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="font-mono text-sm text-purple-400">
                      {session.walletAddress}
                      {session.isAdmin && (
                        <span className="ml-2 px-2 py-0.5 bg-green-500/20 text-green-400 text-xs rounded">
                          ADMIN
                        </span>
                      )}
                    </div>
                    <div className="text-xs text-gray-400 mt-1">
                      IP: {session.ipAddress}
                    </div>
                    <div className="text-xs text-gray-400">
                      Created: {new Date(session.createdAt).toLocaleString()}
                    </div>
                    <div className="text-xs text-gray-400">
                      Last active: {new Date(session.lastActivity).toLocaleString()}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </Card>
    </div>
  );
};

STEP 8: ADD SESSION MONITOR TO ADMIN DASHBOARD

8. UPDATE FILE: client/src/components/AdminDashboard.tsx

Add import:

import { SessionMonitor } from './SessionMonitor';

Add to dashboard render:

<div className="mb-8">
  <h2 className="text-2xl font-bold mb-4">üîê Session Management</h2>
  <SessionMonitor />
</div>

STEP 9: CREATE CLIENT-SIDE AUTH HELPER

9. CREATE FILE: client/src/lib/auth.ts

import { useAccount, useSignMessage } from 'wagmi';
import { useState, useEffect } from 'react';

export class AuthManager {
  private static sessionId: string | null = null;
  
  static setSession(sessionId: string) {
    this.sessionId = sessionId;
    localStorage.setItem('sessionId', sessionId);
  }
  
  static getSession(): string | null {
    if (!this.sessionId) {
      this.sessionId = localStorage.getItem('sessionId');
    }
    return this.sessionId;
  }
  
  static clearSession() {
    this.sessionId = null;
    localStorage.removeItem('sessionId');
  }
  
  static async authenticatedFetch(url: string, options: RequestInit = {}) {
    const sessionId = this.getSession();
    
    if (!sessionId) {
      throw new Error('No active session');
    }
    
    const headers = {
      ...options.headers,
      'X-Session-ID': sessionId
    };
    
    const response = await fetch(url, { ...options, headers });
    
    if (response.status === 401) {
      this.clearSession();
      throw new Error('Session expired');
    }
    
    return response;
  }
}

export function useAuth() {
  const { address, isConnected } = useAccount();
  const { signMessageAsync } = useSignMessage();
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isAuthenticating, setIsAuthenticating] = useState(false);
  
  useEffect(() => {
    const sessionId = AuthManager.getSession();
    setIsAuthenticated(!!sessionId && isConnected);
  }, [isConnected]);
  
  const authenticate = async () => {
    if (!address) {
      throw new Error('Wallet not connected');
    }
    
    setIsAuthenticating(true);
    
    try {
      const nonceRes = await fetch('/api/auth/nonce', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ walletAddress: address })
      });
      
      const { nonce, message } = await nonceRes.json();
      
      const signature = await signMessageAsync({ message });
      
      const verifyRes = await fetch('/api/auth/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          walletAddress: address,
          signature,
          message,
          nonce
        })
      });
      
      const { sessionId } = await verifyRes.json();
      
      AuthManager.setSession(sessionId);
      setIsAuthenticated(true);
      
      return sessionId;
    } catch (error) {
      console.error('Authentication failed:', error);
      throw error;
    } finally {
      setIsAuthenticating(false);
    }
  };
  
  const logout = async () => {
    try {
      await AuthManager.authenticatedFetch('/api/auth/logout', { method: 'POST' });
    } catch (error) {
      console.error('Logout failed:', error);
    } finally {
      AuthManager.clearSession();
      setIsAuthenticated(false);
    }
  };
  
  return {
    isAuthenticated,
    isAuthenticating,
    authenticate,
    logout
  };
}

VERIFICATION STEPS:
1. Connect wallet
2. Should trigger authentication flow
3. Sign the message
4. Should receive session ID
5. Check localStorage - should contain sessionId
6. Make API request requiring auth
7. Should work with session header
8. Open Admin Dashboard
9. Find Session Management section
10. Should see your active session
11. Try logging out
12. Session should be destroyed
13. Try making authenticated request
14. Should get 401 error
15. Restart browser
16. Session should persist (if not expired)

Check server logs for:
- [SESSION] Created session
- [AUTH] Signature verification
- [SESSION] Destroyed session

Your app now has secure session management! üîê