Create transaction receipt storage for every financial operation to provide audit trail and tax reporting.

STEP 1: ADD DATABASE TABLE

1. UPDATE FILE: shared/schema.ts

Add this table definition after the existing tables (around line 100+):

export const transactionReceipts = pgTable('transaction_receipts', {
  id: serial('id').primaryKey(),
  walletAddress: text('wallet_address').notNull(),
  transactionType: text('transaction_type').notNull(),
  transactionHash: text('transaction_hash').notNull().unique(),
  tokenId: integer('token_id'),
  amount: text('amount'),
  gasUsed: text('gas_used'),
  gasPrice: text('gas_price'),
  blockNumber: integer('block_number'),
  status: text('status').notNull().default('pending'),
  fromAddress: text('from_address'),
  toAddress: text('to_address'),
  platformFee: text('platform_fee'),
  royaltyFee: text('royalty_fee'),
  metadata: text('metadata'),
  createdAt: timestamp('created_at').defaultNow(),
  confirmedAt: timestamp('confirmed_at'),
});

export type TransactionReceipt = typeof transactionReceipts.$inferSelect;
export type InsertTransactionReceipt = typeof transactionReceipts.$inferInsert;

STEP 2: PUSH DATABASE SCHEMA

2. RUN IN TERMINAL:

npm run db:push

Wait for "âœ… Database schema pushed" message.

STEP 3: ADD DATABASE METHODS

3. UPDATE FILE: server/storage.ts

Add import at the top (around line 2):

import { transactionReceipts, type TransactionReceipt, type InsertTransactionReceipt } from "@shared/schema";

Add these methods to the DatabaseStorage class (after existing methods, before the closing brace):

async createTransactionReceipt(data: InsertTransactionReceipt): Promise<TransactionReceipt> {
  const [receipt] = await db.insert(transactionReceipts).values({
    ...data,
    walletAddress: data.walletAddress.toLowerCase()
  }).returning();
  return receipt;
}

async updateTransactionStatus(
  txHash: string, 
  status: 'confirmed' | 'failed', 
  updates: { blockNumber?: number; gasUsed?: string; gasPrice?: string } = {}
): Promise<void> {
  await db.update(transactionReceipts)
    .set({ 
      status, 
      ...updates,
      confirmedAt: new Date() 
    })
    .where(eq(transactionReceipts.transactionHash, txHash));
}

async getTransactionReceipt(txHash: string): Promise<TransactionReceipt | undefined> {
  const [receipt] = await db.select()
    .from(transactionReceipts)
    .where(eq(transactionReceipts.transactionHash, txHash));
  return receipt;
}

async getUserTransactionHistory(
  walletAddress: string, 
  limit: number = 50
): Promise<TransactionReceipt[]> {
  return db.select()
    .from(transactionReceipts)
    .where(eq(transactionReceipts.walletAddress, walletAddress.toLowerCase()))
    .orderBy(desc(transactionReceipts.createdAt))
    .limit(limit);
}

async getAllTransactions(limit: number = 100): Promise<TransactionReceipt[]> {
  return db.select()
    .from(transactionReceipts)
    .orderBy(desc(transactionReceipts.createdAt))
    .limit(limit);
}

async exportUserTransactionsCSV(walletAddress: string): Promise<string> {
  const receipts = await this.getUserTransactionHistory(walletAddress, 1000);
  
  let csv = 'Date,Type,Amount ($BASED),Gas Used,Status,TX Hash,Token ID,Block Number\n';
  
  for (const receipt of receipts) {
    const date = receipt.createdAt ? new Date(receipt.createdAt).toISOString() : '';
    csv += `${date},`;
    csv += `${receipt.transactionType},`;
    csv += `${receipt.amount || '0'},`;
    csv += `${receipt.gasUsed || '0'},`;
    csv += `${receipt.status},`;
    csv += `${receipt.transactionHash},`;
    csv += `${receipt.tokenId || ''},`;
    csv += `${receipt.blockNumber || ''}\n`;
  }
  
  return csv;
}

STEP 4: ADD API ENDPOINTS

4. UPDATE FILE: server/routes.ts

Add these endpoints (after existing routes):

app.post('/api/transactions/receipt', async (req, res) => {
  try {
    const receipt = await storage.createTransactionReceipt(req.body);
    res.json({ receipt });
  } catch (error: any) {
    console.error('[RECEIPT] Create error:', error);
    res.status(500).json({ error: error.message || 'Failed to create receipt' });
  }
});

app.put('/api/transactions/receipt/:hash', async (req, res) => {
  try {
    const { status, blockNumber, gasUsed, gasPrice } = req.body;
    await storage.updateTransactionStatus(req.params.hash, status, {
      blockNumber,
      gasUsed,
      gasPrice
    });
    res.json({ success: true });
  } catch (error: any) {
    console.error('[RECEIPT] Update error:', error);
    res.status(500).json({ error: error.message || 'Failed to update receipt' });
  }
});

app.get('/api/transactions/receipt/:hash', async (req, res) => {
  try {
    const receipt = await storage.getTransactionReceipt(req.params.hash);
    if (!receipt) {
      return res.status(404).json({ error: 'Receipt not found' });
    }
    res.json({ receipt });
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to get receipt' });
  }
});

app.get('/api/transactions/history/:address', async (req, res) => {
  try {
    const history = await storage.getUserTransactionHistory(req.params.address);
    res.json({ history });
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to get history' });
  }
});

app.get('/api/transactions/export/:address/csv', async (req, res) => {
  try {
    const csv = await storage.exportUserTransactionsCSV(req.params.address);
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename=transactions-${req.params.address}.csv`);
    res.send(csv);
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to export' });
  }
});

app.get('/api/admin/transactions', isAdmin, async (req, res) => {
  try {
    const transactions = await storage.getAllTransactions(100);
    res.json({ transactions });
  } catch (error: any) {
    res.status(500).json({ error: error.message || 'Failed to get transactions' });
  }
});

STEP 5: CREATE RECEIPT LOGGER

5. CREATE FILE: client/src/lib/receiptLogger.ts

export async function logTransactionReceipt(data: {
  walletAddress: string;
  transactionType: string;
  transactionHash: string;
  amount?: string;
  tokenId?: number;
  fromAddress?: string;
  toAddress?: string;
}) {
  try {
    await fetch('/api/transactions/receipt', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...data,
        status: 'pending',
        createdAt: new Date().toISOString()
      })
    });
  } catch (error) {
    console.error('[RECEIPT] Failed to log:', error);
  }
}

export async function updateTransactionReceipt(txHash: string, receipt: any) {
  try {
    await fetch(`/api/transactions/receipt/${txHash}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        status: 'confirmed',
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed?.toString(),
        gasPrice: receipt.gasPrice?.toString(),
      })
    });
  } catch (error) {
    console.error('[RECEIPT] Failed to update:', error);
  }
}

STEP 6: INTEGRATE IN MINTING

6. UPDATE FILE: client/src/hooks/useMint.ts

Add import at the top:

import { logTransactionReceipt, updateTransactionReceipt } from '@/lib/receiptLogger';

Find where the mint transaction is sent (after const tx = await...), and add:

await logTransactionReceipt({
  walletAddress: address!,
  transactionType: 'mint',
  transactionHash: tx.hash,
  amount: (quantity * 69420).toString(),
});

const receipt = await tx.wait();

await updateTransactionReceipt(tx.hash, receipt);

STEP 7: CREATE TRANSACTION HISTORY PAGE

7. CREATE FILE: client/src/pages/TransactionHistory.tsx

import { useEffect, useState } from 'react';
import { useAccount } from 'wagmi';
import { Download, ExternalLink } from 'lucide-react';
import { Button } from '@/components/ui/button';

export default function TransactionHistory() {
  const { address } = useAccount();
  const [history, setHistory] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    if (address) {
      fetch(`/api/transactions/history/${address}`)
        .then(res => res.json())
        .then(data => {
          setHistory(data.history || []);
          setLoading(false);
        })
        .catch(() => setLoading(false));
    }
  }, [address]);
  
  const downloadCSV = () => {
    window.open(`/api/transactions/export/${address}/csv`, '_blank');
  };
  
  if (!address) {
    return (
      <div className="min-h-screen bg-black flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-2xl font-bold text-white mb-4">Connect Wallet</h2>
          <p className="text-gray-400">Connect your wallet to view transaction history</p>
        </div>
      </div>
    );
  }
  
  return (
    <div className="min-h-screen bg-black pt-24 pb-12 px-4">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <h1 className="text-4xl font-bold text-white font-orbitron">Transaction History</h1>
          <Button onClick={downloadCSV} variant="outline" className="border-cyan-500 text-cyan-400">
            <Download size={16} className="mr-2" />
            Export CSV
          </Button>
        </div>
        
        {loading ? (
          <div className="text-center py-12 text-white">Loading transactions...</div>
        ) : history.length === 0 ? (
          <div className="text-center py-12 text-gray-400">No transactions yet</div>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead>
                <tr className="border-b border-white/10">
                  <th className="text-left p-4 text-gray-400 font-mono text-sm">Date</th>
                  <th className="text-left p-4 text-gray-400 font-mono text-sm">Type</th>
                  <th className="text-left p-4 text-gray-400 font-mono text-sm">Amount</th>
                  <th className="text-left p-4 text-gray-400 font-mono text-sm">Status</th>
                  <th className="text-left p-4 text-gray-400 font-mono text-sm">TX Hash</th>
                </tr>
              </thead>
              <tbody>
                {history.map((tx) => (
                  <tr key={tx.id} className="border-b border-white/5 hover:bg-white/5">
                    <td className="p-4 text-white">
                      {new Date(tx.createdAt).toLocaleDateString()} {new Date(tx.createdAt).toLocaleTimeString()}
                    </td>
                    <td className="p-4">
                      <span className="px-2 py-1 rounded text-xs font-mono bg-cyan-500/20 text-cyan-400">
                        {tx.transactionType}
                      </span>
                    </td>
                    <td className="p-4 text-white font-mono">
                      {tx.amount ? `${parseFloat(tx.amount).toLocaleString()} $BASED` : '-'}
                    </td>
                    <td className="p-4">
                      <span className={`px-2 py-1 rounded text-xs font-mono ${
                        tx.status === 'confirmed' ? 'bg-green-500/20 text-green-400' :
                        tx.status === 'failed' ? 'bg-red-500/20 text-red-400' :
                        'bg-yellow-500/20 text-yellow-400'
                      }`}>
                        {tx.status}
                      </span>
                    </td>
                    <td className="p-4">
                      <a 
                        href={`https://explorer.bf1337.org/tx/${tx.transactionHash}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-cyan-400 hover:text-cyan-300 font-mono text-sm flex items-center gap-1"
                      >
                        {tx.transactionHash.slice(0, 10)}...{tx.transactionHash.slice(-8)}
                        <ExternalLink size={12} />
                      </a>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

STEP 8: ADD ROUTE

8. UPDATE FILE: client/src/App.tsx

Add import at the top:

import TransactionHistory from "@/pages/TransactionHistory";

Add route in the Router component:

<Route path="/transactions" component={TransactionHistory} />

STEP 9: ADD TO NAVBAR

9. UPDATE FILE: client/src/components/Navbar.tsx

Add to the navItems array:

{ id: 'transactions', label: t('nav.transactions', 'Transactions') },

VERIFICATION STEPS:
1. Check terminal output from npm run db:push - should see table created
2. Check database: Open Replit database tool and verify transaction_receipts table exists
3. Mint an NFT from the app
4. Check database again: SELECT * FROM transaction_receipts; (should show 1 record)
5. Navigate to /transactions page in browser
6. Should see your mint transaction in the table
7. Click "Export CSV" button
8. CSV file should download with transaction data
9. Open CSV and verify it has correct data
10. Try minting another NFT - should see 2 transactions now