Implement comprehensive input sanitization, XSS prevention, and content validation for all user inputs including custom names, proposal descriptions, offers, and form submissions.

STEP 1: CREATE INPUT SANITIZATION SERVICE

1. CREATE FILE: server/lib/sanitizer.ts

import DOMPurify from 'isomorphic-dompurify';

interface SanitizationOptions {
  maxLength?: number;
  allowedTags?: string[];
  allowedAttributes?: Record<string, string[]>;
  stripHtml?: boolean;
}

export class InputSanitizer {
  static sanitizeString(
    input: string, 
    options: SanitizationOptions = {}
  ): string {
    if (typeof input !== 'string') {
      throw new Error('Input must be a string');
    }
    
    let sanitized = input.trim();
    
    if (options.stripHtml) {
      sanitized = sanitized.replace(/<[^>]*>/g, '');
    } else {
      sanitized = DOMPurify.sanitize(sanitized, {
        ALLOWED_TAGS: options.allowedTags || [],
        ALLOWED_ATTR: options.allowedAttributes || {}
      });
    }
    
    sanitized = sanitized
      .replace(/[<>]/g, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '')
      .replace(/eval\(/gi, '')
      .replace(/script/gi, '');
    
    if (options.maxLength && sanitized.length > options.maxLength) {
      sanitized = sanitized.substring(0, options.maxLength);
    }
    
    return sanitized;
  }
  
  static sanitizeCustomName(name: string): string {
    const sanitized = this.sanitizeString(name, { 
      maxLength: 32, 
      stripHtml: true 
    });
    
    if (!/^[a-zA-Z0-9_\s-]+$/.test(sanitized)) {
      throw new Error('Custom name contains invalid characters');
    }
    
    const profanityList = ['badword1', 'badword2'];
    const lowerName = sanitized.toLowerCase();
    for (const word of profanityList) {
      if (lowerName.includes(word)) {
        throw new Error('Custom name contains inappropriate content');
      }
    }
    
    return sanitized;
  }
  
  static sanitizeProposalTitle(title: string): string {
    return this.sanitizeString(title, { 
      maxLength: 100, 
      stripHtml: true 
    });
  }
  
  static sanitizeProposalDescription(description: string): string {
    return this.sanitizeString(description, { 
      maxLength: 2000,
      allowedTags: ['b', 'i', 'u', 'br', 'p'],
      allowedAttributes: {}
    });
  }
  
  static sanitizeWalletAddress(address: string): string {
    const sanitized = address.trim().toLowerCase();
    
    if (!/^0x[a-f0-9]{40}$/i.test(sanitized)) {
      throw new Error('Invalid wallet address format');
    }
    
    return sanitized;
  }
  
  static sanitizeNumericInput(input: string | number): number {
    const num = typeof input === 'string' ? parseFloat(input) : input;
    
    if (isNaN(num) || !isFinite(num)) {
      throw new Error('Invalid numeric input');
    }
    
    if (num < 0) {
      throw new Error('Negative numbers not allowed');
    }
    
    return num;
  }
  
  static sanitizeTokenId(tokenId: string | number): number {
    const id = this.sanitizeNumericInput(tokenId);
    
    if (!Number.isInteger(id)) {
      throw new Error('Token ID must be an integer');
    }
    
    if (id < 0 || id > 10000) {
      throw new Error('Token ID out of valid range');
    }
    
    return id;
  }
  
  static sanitizeUrl(url: string): string {
    const sanitized = this.sanitizeString(url, { maxLength: 500 });
    
    try {
      const parsed = new URL(sanitized);
      
      if (!['http:', 'https:'].includes(parsed.protocol)) {
        throw new Error('Invalid URL protocol');
      }
      
      return parsed.toString();
    } catch (error) {
      throw new Error('Invalid URL format');
    }
  }
  
  static sanitizeJson(input: string): any {
    try {
      const parsed = JSON.parse(input);
      
      const jsonString = JSON.stringify(parsed);
      if (jsonString.length > 10000) {
        throw new Error('JSON payload too large');
      }
      
      return parsed;
    } catch (error) {
      throw new Error('Invalid JSON format');
    }
  }
  
  static validateAndSanitizeRequest(data: Record<string, any>, rules: Record<string, {
    type: 'string' | 'number' | 'wallet' | 'tokenId' | 'url' | 'json';
    required?: boolean;
    maxLength?: number;
    min?: number;
    max?: number;
  }>): Record<string, any> {
    const sanitized: Record<string, any> = {};
    
    for (const [key, rule] of Object.entries(rules)) {
      const value = data[key];
      
      if (rule.required && (value === undefined || value === null || value === '')) {
        throw new Error(`${key} is required`);
      }
      
      if (value === undefined || value === null || value === '') {
        continue;
      }
      
      try {
        switch (rule.type) {
          case 'string':
            sanitized[key] = this.sanitizeString(value, { maxLength: rule.maxLength, stripHtml: true });
            break;
          case 'number':
            sanitized[key] = this.sanitizeNumericInput(value);
            if (rule.min !== undefined && sanitized[key] < rule.min) {
              throw new Error(`${key} must be at least ${rule.min}`);
            }
            if (rule.max !== undefined && sanitized[key] > rule.max) {
              throw new Error(`${key} must be at most ${rule.max}`);
            }
            break;
          case 'wallet':
            sanitized[key] = this.sanitizeWalletAddress(value);
            break;
          case 'tokenId':
            sanitized[key] = this.sanitizeTokenId(value);
            break;
          case 'url':
            sanitized[key] = this.sanitizeUrl(value);
            break;
          case 'json':
            sanitized[key] = this.sanitizeJson(value);
            break;
        }
      } catch (error: any) {
        throw new Error(`Invalid ${key}: ${error.message}`);
      }
    }
    
    return sanitized;
  }
}

STEP 2: INSTALL DEPENDENCIES

2. RUN IN TERMINAL:

npm install isomorphic-dompurify

STEP 3: CREATE VALIDATION MIDDLEWARE

3. CREATE FILE: server/middleware/validation.ts

import { Request, Response, NextFunction } from 'express';
import { InputSanitizer } from '../lib/sanitizer';

export function validateCustomName(req: Request, res: Response, next: NextFunction) {
  try {
    if (!req.body.customName) {
      return res.status(400).json({ error: 'Custom name is required' });
    }
    
    req.body.customName = InputSanitizer.sanitizeCustomName(req.body.customName);
    next();
  } catch (error: any) {
    res.status(400).json({ error: error.message });
  }
}

export function validateProposal(req: Request, res: Response, next: NextFunction) {
  try {
    const sanitized = InputSanitizer.validateAndSanitizeRequest(req.body, {
      title: { type: 'string', required: true, maxLength: 100 },
      description: { type: 'string', required: true, maxLength: 2000 },
      category: { type: 'string', required: true, maxLength: 50 },
      durationDays: { type: 'number', required: false, min: 1, max: 30 }
    });
    
    req.body = { ...req.body, ...sanitized };
    next();
  } catch (error: any) {
    res.status(400).json({ error: error.message });
  }
}

export function validateListing(req: Request, res: Response, next: NextFunction) {
  try {
    const sanitized = InputSanitizer.validateAndSanitizeRequest(req.body, {
      tokenId: { type: 'tokenId', required: true },
      price: { type: 'string', required: true, maxLength: 50 }
    });
    
    req.body = { ...req.body, ...sanitized };
    next();
  } catch (error: any) {
    res.status(400).json({ error: error.message });
  }
}

export function validateOffer(req: Request, res: Response, next: NextFunction) {
  try {
    const sanitized = InputSanitizer.validateAndSanitizeRequest(req.body, {
      tokenId: { type: 'tokenId', required: true },
      price: { type: 'string', required: true, maxLength: 50 },
      expiresAt: { type: 'number', required: true }
    });
    
    req.body = { ...req.body, ...sanitized };
    next();
  } catch (error: any) {
    res.status(400).json({ error: error.message });
  }
}

export function validateWalletAddress(req: Request, res: Response, next: NextFunction) {
  try {
    const walletAddress = req.params.walletAddress || req.body.walletAddress;
    
    if (!walletAddress) {
      return res.status(400).json({ error: 'Wallet address is required' });
    }
    
    const sanitized = InputSanitizer.sanitizeWalletAddress(walletAddress);
    
    if (req.params.walletAddress) {
      req.params.walletAddress = sanitized;
    }
    if (req.body.walletAddress) {
      req.body.walletAddress = sanitized;
    }
    
    next();
  } catch (error: any) {
    res.status(400).json({ error: error.message });
  }
}

export function sanitizeQueryParams(req: Request, res: Response, next: NextFunction) {
  try {
    for (const [key, value] of Object.entries(req.query)) {
      if (typeof value === 'string') {
        req.query[key] = InputSanitizer.sanitizeString(value, { stripHtml: true, maxLength: 200 });
      }
    }
    next();
  } catch (error: any) {
    res.status(400).json({ error: 'Invalid query parameters' });
  }
}

STEP 4: APPLY VALIDATION TO ROUTES

4. UPDATE FILE: server/routes.ts

Add imports at top:

import { 
  validateCustomName, 
  validateProposal, 
  validateListing, 
  validateOffer,
  validateWalletAddress,
  sanitizeQueryParams
} from './middleware/validation';
import { InputSanitizer } from './lib/sanitizer';

Apply middleware to existing routes:

// Custom names
app.post('/api/custom-names', isAuthenticated, validateCustomName, async (req, res) => {
  // existing code
});

// Proposals
app.post('/api/proposals', isAdmin, validateProposal, async (req, res) => {
  // existing code
});

// Listings (if you have these endpoints)
app.post('/api/marketplace/list', isAuthenticated, validateListing, async (req, res) => {
  // existing code
});

// Offers
app.post('/api/offers', isAuthenticated, validateOffer, async (req, res) => {
  // existing code
});

// Profile/wallet endpoints
app.get('/api/profile/:walletAddress', validateWalletAddress, async (req, res) => {
  // existing code
});

// Apply query sanitization to all GET routes
app.use('/api/*', sanitizeQueryParams);

STEP 5: ADD CLIENT-SIDE VALIDATION

5. CREATE FILE: client/src/lib/clientValidator.ts

export class ClientValidator {
  static validateCustomName(name: string): { valid: boolean; error?: string } {
    if (!name || name.trim().length === 0) {
      return { valid: false, error: 'Name cannot be empty' };
    }
    
    if (name.length > 32) {
      return { valid: false, error: 'Name must be 32 characters or less' };
    }
    
    if (!/^[a-zA-Z0-9_\s-]+$/.test(name)) {
      return { valid: false, error: 'Name can only contain letters, numbers, spaces, hyphens, and underscores' };
    }
    
    if (name.trim().length < 3) {
      return { valid: false, error: 'Name must be at least 3 characters' };
    }
    
    return { valid: true };
  }
  
  static validateProposalTitle(title: string): { valid: boolean; error?: string } {
    if (!title || title.trim().length === 0) {
      return { valid: false, error: 'Title cannot be empty' };
    }
    
    if (title.length > 100) {
      return { valid: false, error: 'Title must be 100 characters or less' };
    }
    
    if (title.trim().length < 10) {
      return { valid: false, error: 'Title must be at least 10 characters' };
    }
    
    return { valid: true };
  }
  
  static validateProposalDescription(description: string): { valid: boolean; error?: string } {
    if (!description || description.trim().length === 0) {
      return { valid: false, error: 'Description cannot be empty' };
    }
    
    if (description.length > 2000) {
      return { valid: false, error: 'Description must be 2000 characters or less' };
    }
    
    if (description.trim().length < 50) {
      return { valid: false, error: 'Description must be at least 50 characters' };
    }
    
    return { valid: true };
  }
  
  static validatePrice(price: string): { valid: boolean; error?: string } {
    if (!price || price.trim().length === 0) {
      return { valid: false, error: 'Price cannot be empty' };
    }
    
    const num = parseFloat(price);
    
    if (isNaN(num) || !isFinite(num)) {
      return { valid: false, error: 'Price must be a valid number' };
    }
    
    if (num <= 0) {
      return { valid: false, error: 'Price must be greater than 0' };
    }
    
    if (num > 1000000000) {
      return { valid: false, error: 'Price is too large' };
    }
    
    return { valid: true };
  }
  
  static sanitizeDisplayText(text: string): string {
    return text
      .replace(/[<>]/g, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '');
  }
}

STEP 6: UPDATE CUSTOM NAME COMPONENT WITH VALIDATION

6. UPDATE FILE: client/src/components/Profile.tsx

Add import:

import { ClientValidator } from '@/lib/clientValidator';

Update the custom name input section:

const [nameError, setNameError] = useState('');

const handleNameChange = (value: string) => {
  setCustomName(value);
  
  const validation = ClientValidator.validateCustomName(value);
  if (!validation.valid) {
    setNameError(validation.error || '');
  } else {
    setNameError('');
  }
};

const handleSetCustomName = async () => {
  const validation = ClientValidator.validateCustomName(customName);
  
  if (!validation.valid) {
    showToast(validation.error || 'Invalid name', 'error');
    return;
  }
  
  // existing setCustomName logic
};

In the JSX:

<input
  type="text"
  value={customName}
  onChange={(e) => handleNameChange(e.target.value)}
  maxLength={32}
  className={`px-4 py-2 bg-black/60 border rounded ${
    nameError ? 'border-red-500' : 'border-purple-500/30'
  }`}
/>
{nameError && (
  <div className="text-red-400 text-sm mt-1">{nameError}</div>
)}

STEP 7: UPDATE GOVERNANCE COMPONENT WITH VALIDATION

7. UPDATE FILE: client/src/components/Governance.tsx

Add import:

import { ClientValidator } from '@/lib/clientValidator';

Update proposal form:

const [titleError, setTitleError] = useState('');
const [descError, setDescError] = useState('');

const validateProposalForm = (): boolean => {
  const titleValidation = ClientValidator.validateProposalTitle(newProposal.title);
  const descValidation = ClientValidator.validateProposalDescription(newProposal.description);
  
  setTitleError(titleValidation.error || '');
  setDescError(descValidation.error || '');
  
  return titleValidation.valid && descValidation.valid;
};

const handleCreateProposal = async () => {
  if (!validateProposalForm()) {
    showToast('Please fix validation errors', 'error');
    return;
  }
  
  // existing create proposal logic
};

In the JSX:

<input
  type="text"
  value={newProposal.title}
  onChange={(e) => {
    setNewProposal({ ...newProposal, title: e.target.value });
    const validation = ClientValidator.validateProposalTitle(e.target.value);
    setTitleError(validation.error || '');
  }}
  maxLength={100}
  className={`px-4 py-2 border rounded ${
    titleError ? 'border-red-500' : 'border-purple-500/30'
  }`}
/>
{titleError && <div className="text-red-400 text-sm">{titleError}</div>}

<textarea
  value={newProposal.description}
  onChange={(e) => {
    setNewProposal({ ...newProposal, description: e.target.value });
    const validation = ClientValidator.validateProposalDescription(e.target.value);
    setDescError(validation.error || '');
  }}
  maxLength={2000}
  rows={6}
  className={`px-4 py-2 border rounded ${
    descError ? 'border-red-500' : 'border-purple-500/30'
  }`}
/>
{descError && <div className="text-red-400 text-sm">{descError}</div>}

STEP 8: ADD XSS TEST ENDPOINT (ADMIN ONLY)

8. UPDATE FILE: server/routes.ts

Add test endpoint:

app.post('/api/admin/test-sanitization', isAdmin, async (req, res) => {
  try {
    const { input, type } = req.body;
    
    let result;
    switch (type) {
      case 'customName':
        result = InputSanitizer.sanitizeCustomName(input);
        break;
      case 'proposal':
        result = InputSanitizer.sanitizeProposalDescription(input);
        break;
      case 'wallet':
        result = InputSanitizer.sanitizeWalletAddress(input);
        break;
      default:
        result = InputSanitizer.sanitizeString(input, { stripHtml: true });
    }
    
    res.json({ 
      original: input, 
      sanitized: result,
      safe: result === input
    });
  } catch (error: any) {
    res.status(400).json({ error: error.message });
  }
});

STEP 9: CREATE XSS TEST SCRIPT

9. CREATE FILE: script/test-xss-protection.ts

import fetch from 'node-fetch';

const API_URL = process.env.API_URL || 'http://localhost:5000';

const xssPayloads = [
  '<script>alert("XSS")</script>',
  '<img src=x onerror=alert("XSS")>',
  'javascript:alert("XSS")',
  '<svg onload=alert("XSS")>',
  '<iframe src="javascript:alert(\'XSS\')">',
  '"><script>alert(String.fromCharCode(88,83,83))</script>',
  '<body onload=alert("XSS")>',
];

async function testSanitization(payload: string, type: string) {
  try {
    const response = await fetch(`${API_URL}/api/admin/test-sanitization`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ input: payload, type })
    });
    
    const data = await response.json() as any;
    
    if (data.safe) {
      console.log(`‚ùå FAILED: Payload not sanitized: ${payload}`);
      return false;
    } else {
      console.log(`‚úÖ PASSED: Payload sanitized: ${payload.substring(0, 50)}...`);
      return true;
    }
  } catch (error: any) {
    console.log(`‚úÖ PASSED: Payload rejected: ${error.message}`);
    return true;
  }
}

async function runTests() {
  console.log('üîí Running XSS Protection Tests...\n');
  
  let passed = 0;
  let failed = 0;
  
  for (const payload of xssPayloads) {
    const result = await testSanitization(payload, 'customName');
    if (result) {
      passed++;
    } else {
      failed++;
    }
  }
  
  console.log(`\nüìä Results: ${passed} passed, ${failed} failed`);
  
  if (failed > 0) {
    console.log('‚ö†Ô∏è  Some XSS payloads were not properly sanitized!');
    process.exit(1);
  } else {
    console.log('‚úÖ All XSS protection tests passed!');
  }
}

runTests();

STEP 10: ADD TO PACKAGE.JSON

10. UPDATE FILE: package.json

Add script:

"test:xss": "tsx script/test-xss-protection.ts"

VERIFICATION STEPS:
1. Try submitting a custom name with <script>alert("xss")</script>
2. Should be rejected or sanitized
3. Try creating a proposal with malicious HTML
4. Should be sanitized
5. Try entering malformed wallet address
6. Should get validation error
7. Run in terminal: npm run test:xss
8. All tests should pass
9. Check browser console - no XSS warnings
10. Test all forms with special characters
11. All should be properly escaped/sanitized

Check server logs for sanitization warnings.

Your app is now protected against XSS attacks! üîí