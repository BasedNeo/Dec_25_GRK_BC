=== ARCHITECTURE: PRODUCTION-GRADE ERROR BOUNDARIES ===

BACKGROUND: Current ErrorBoundary is basic. Need granular boundaries for each feature, automatic error reporting, and graceful degradation.

═══════════════════════════════════════════════════════════
PART 1: ENHANCED ROOT ERROR BOUNDARY
═══════════════════════════════════════════════════════════

FILE: client/src/components/ErrorBoundary.tsx

REPLACE ENTIRE FILE WITH:

import React, { Component, ReactNode } from 'react';
import { AlertTriangle, RefreshCw, Home, Bug } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
  isolate?: boolean; // If true, only this component crashes, not whole app
  resetKeys?: any[]; // Reset boundary when these values change
  feature?: string; // Feature name for logging
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
  errorId: string | null;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: null
    };
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return {
      hasError: true,
      error,
      errorId: `err_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    const { onError, feature } = this.props;
    const { errorId } = this.state;

    // Log error details
    console.error(`[ErrorBoundary${feature ? ` - ${feature}` : ''}]`, {
      errorId,
      error,
      errorInfo,
      timestamp: new Date().toISOString()
    });

    this.setState({ errorInfo });

    // Call custom error handler
    if (onError) {
      onError(error, errorInfo);
    }

    // In production, send to error tracking service
    if (import.meta.env.PROD) {
      this.reportError(error, errorInfo, errorId || '');
    }
  }

  componentDidUpdate(prevProps: Props) {
    const { resetKeys } = this.props;
    const { hasError } = this.state;

    // Auto-reset if reset keys change
    if (hasError && resetKeys && prevProps.resetKeys) {
      if (resetKeys.some((key, i) => key !== prevProps.resetKeys![i])) {
        this.resetError();
      }
    }
  }

  reportError(error: Error, errorInfo: React.ErrorInfo, errorId: string) {
    // TODO: Integrate with error tracking service (Sentry, etc.)
    // For now, just store locally for debugging
    try {
      const errorLog = {
        id: errorId,
        message: error.message,
        stack: error.stack,
        componentStack: errorInfo.componentStack,
        timestamp: Date.now(),
        feature: this.props.feature,
        userAgent: navigator.userAgent,
        url: window.location.href
      };

      const logs = JSON.parse(localStorage.getItem('error_logs') || '[]');
      logs.push(errorLog);
      
      // Keep only last 10 errors
      if (logs.length > 10) logs.shift();
      
      localStorage.setItem('error_logs', JSON.stringify(logs));
    } catch (e) {
      console.error('Failed to log error:', e);
    }
  }

  resetError = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: null
    });
  };

  copyErrorDetails = () => {
    const { error, errorInfo, errorId } = this.state;
    const details = `
Error ID: ${errorId}
Feature: ${this.props.feature || 'Unknown'}
Message: ${error?.message}
Stack: ${error?.stack}
Component Stack: ${errorInfo?.componentStack}
URL: ${window.location.href}
Time: ${new Date().toISOString()}
    `.trim();

    navigator.clipboard.writeText(details);
    alert('Error details copied to clipboard');
  };

  render() {
    const { hasError, error, errorId } = this.state;
    const { children, fallback, isolate, feature } = this.props;

    if (hasError) {
      // Use custom fallback if provided
      if (fallback) {
        return fallback;
      }

      // Minimal fallback for isolated errors
      if (isolate) {
        return (
          <div className="p-4 border border-red-500/30 bg-red-500/10 rounded-lg">
            <div className="flex items-center gap-2 text-red-400 mb-2">
              <AlertTriangle size={16} />
              <span className="text-sm font-mono">
                {feature ? `${feature} Error` : 'Component Error'}
              </span>
            </div>
            <Button
              size="sm"
              variant="outline"
              onClick={this.resetError}
              className="text-xs"
            >
              <RefreshCw size={12} className="mr-1" />
              Retry
            </Button>
          </div>
        );
      }

      // Full-page error UI
      return (
        <div className="min-h-screen bg-black flex items-center justify-center p-4">
          <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,rgba(220,38,38,0.1)_0%,transparent_50%)]" />
          
          <Card className="relative z-10 max-w-2xl w-full bg-black/95 border-red-500/30 backdrop-blur-xl p-8">
            <div className="text-center mb-6">
              <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-red-500/20 mb-4">
                <AlertTriangle className="w-8 h-8 text-red-400" />
              </div>
              
              <h1 className="text-2xl font-orbitron font-bold text-white mb-2">
                Houston, We Have a Problem
              </h1>
              
              <p className="text-gray-400">
                Something went wrong while loading this component.
                {feature && ` (Feature: ${feature})`}
              </p>
            </div>

            <div className="bg-black/50 border border-red-500/20 rounded-lg p-4 mb-6">
              <div className="text-xs font-mono text-red-300 mb-2">
                Error ID: {errorId}
              </div>
              <div className="text-sm text-gray-300 mb-2 font-mono">
                {error?.message || 'Unknown error'}
              </div>
              {import.meta.env.DEV && (
                <details className="text-xs text-gray-500 mt-2">
                  <summary className="cursor-pointer hover:text-gray-400">
                    Stack Trace (Dev Only)
                  </summary>
                  <pre className="mt-2 p-2 bg-black/50 rounded overflow-x-auto">
                    {error?.stack}
                  </pre>
                </details>
              )}
            </div>

            <div className="flex flex-col sm:flex-row gap-3">
              <Button
                onClick={this.resetError}
                className="flex-1 bg-cyan-500 text-black hover:bg-cyan-400"
              >
                <RefreshCw className="mr-2" size={16} />
                Try Again
              </Button>
              
              <Button
                onClick={() => window.location.href = '/'}
                variant="outline"
                className="flex-1 border-white/20 text-white hover:bg-white/10"
              >
                <Home className="mr-2" size={16} />
                Go Home
              </Button>
              
              <Button
                onClick={this.copyErrorDetails}
                variant="outline"
                className="flex-1 border-white/20 text-white hover:bg-white/10"
              >
                <Bug className="mr-2" size={16} />
                Copy Error
              </Button>
            </div>

            <p className="text-center text-xs text-gray-500 mt-6">
              If this problem persists, please contact support with Error ID: {errorId}
            </p>
          </Card>
        </div>
      );
    }

    return children;
  }
}

export { ErrorBoundary };

═══════════════════════════════════════════════════════════
PART 2: FEATURE-SPECIFIC ERROR BOUNDARIES
═══════════════════════════════════════════════════════════

WRAP CRITICAL FEATURES:

FILE: client/src/pages/Home.tsx

FIND the component export, WRAP WITH:
import { ErrorBoundary } from '@/components/ErrorBoundary';

export default function Home() {
  return (
    <ErrorBoundary 
      feature="Home" 
      isolate={false}
      onError={(error) => {
        console.error('[Home] Critical error:', error);
      }}
    >
      {/* Existing Home component content */}
    </ErrorBoundary>
  );
}

FILE: client/src/components/EscrowMarketplace.tsx

WRAP entire component:
export function EscrowMarketplace() {
  return (
    <ErrorBoundary 
      feature="Marketplace" 
      isolate={true}
      fallback={
        <div className="p-8 text-center">
          <p className="text-red-400 mb-4">Unable to load marketplace</p>
          <Button onClick={() => window.location.reload()}>Reload</Button>
        </div>
      }
    >
      {/* Existing marketplace content */}
    </ErrorBoundary>
  );
}

SIMILARLY WRAP:
- pages/GuardianDefender.tsx (Game)
- components/NFTGallery.tsx (Portfolio)
- components/VotingDAO.tsx (Governance)
- components/UserStats.tsx (Stats)

═══════════════════════════════════════════════════════════
PART 3: ERROR REPORTING UTILITY
═══════════════════════════════════════════════════════════

CREATE: client/src/lib/errorReporter.ts

interface ErrorReport {
  id: string;
  timestamp: number;
  message: string;
  stack?: string;
  feature?: string;
  userAgent: string;
  url: string;
}

class ErrorReporter {
  private maxLogs = 20;

  /**
   * Report error to tracking service
   */
  report(error: Error, context?: { feature?: string; metadata?: Record<string, any> }) {
    const report: ErrorReport = {
      id: `err_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`,
      timestamp: Date.now(),
      message: error.message,
      stack: error.stack,
      feature: context?.feature,
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    // Log to console in development
    if (import.meta.env.DEV) {
      console.error('[ErrorReporter]', report, context?.metadata);
    }

    // Store locally
    this.storeLocal(report);

    // TODO: Send to remote service (Sentry, etc.) in production
    if (import.meta.env.PROD) {
      this.sendToService(report, context?.metadata);
    }

    return report.id;
  }

  private storeLocal(report: ErrorReport) {
    try {
      const logs = JSON.parse(localStorage.getItem('error_logs') || '[]');
      logs.push(report);
      
      // Keep only recent errors
      if (logs.length > this.maxLogs) {
        logs.splice(0, logs.length - this.maxLogs);
      }
      
      localStorage.setItem('error_logs', JSON.stringify(logs));
    } catch (e) {
      console.error('Failed to store error log:', e);
    }
  }

  private sendToService(report: ErrorReport, metadata?: Record<string, any>) {
    // TODO: Integrate with Sentry, LogRocket, etc.
    // Example:
    // Sentry.captureException(new Error(report.message), {
    //   tags: { feature: report.feature },
    //   extra: metadata
    // });
  }

  /**
   * Get recent error logs (for admin debugging)
   */
  getLogs(): ErrorReport[] {
    try {
      return JSON.parse(localStorage.getItem('error_logs') || '[]');
    } catch {
      return [];
    }
  }

  /**
   * Clear all logs
   */
  clearLogs() {
    localStorage.removeItem('error_logs');
  }

  /**
   * Export logs for support
   */
  exportLogs(): string {
    const logs = this.getLogs();
    return JSON.stringify(logs, null, 2);
  }
}

export const errorReporter = new ErrorReporter();

// Expose for debugging
if (typeof window !== 'undefined') {
  (window as any).errorLogs = () => {
    console.table(errorReporter.getLogs().map(log => ({
      id: log.id.slice(0, 10),
      feature: log.feature || 'Unknown',
      message: log.message.slice(0, 50),
      time: new Date(log.timestamp).toLocaleString()
    })));
  };
  
  (window as any).exportErrors = () => {
    const data = errorReporter.exportLogs();
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `error-logs-${Date.now()}.json`;
    a.click();
  };
}

═══════════════════════════════════════════════════════════
PART 4: ADD ERROR LOGS TO ADMIN DASHBOARD
═══════════════════════════════════════════════════════════

FILE: client/src/components/AdminDashboard.tsx

ADD new section for error logs:

import { errorReporter } from '@/lib/errorReporter';
import { useState, useEffect } from 'react';

// Inside component:
const [errorLogs, setErrorLogs] = useState(errorReporter.getLogs());

useEffect(() => {
  const interval = setInterval(() => {
    setErrorLogs(errorReporter.getLogs());
  }, 5000);
  return () => clearInterval(interval);
}, []);

// Add to UI:
<Card className="p-6">
  <div className="flex items-center justify-between mb-4">
    <h3 className="text-lg font-orbitron text-cyan-400">Recent Errors</h3>
    <Button size="sm" onClick={() => errorReporter.clearLogs()}>
      Clear Logs
    </Button>
  </div>
  
  {errorLogs.length === 0 ? (
    <p className="text-gray-500 text-sm">No errors logged</p>
  ) : (
    <div className="space-y-2">
      {errorLogs.slice(-5).reverse().map(log => (
        <div key={log.id} className="p-3 bg-red-500/10 border border-red-500/30 rounded text-xs">
          <div className="flex items-start justify-between mb-1">
            <span className="font-mono text-red-400">{log.feature || 'Unknown'}</span>
            <span className="text-gray-500">
              {new Date(log.timestamp).toLocaleTimeString()}
            </span>
          </div>
          <p className="text-gray-300">{log.message}</p>
        </div>
      ))}
    </div>
  )}
  
  <Button 
    size="sm" 
    variant="outline" 
    className="w-full mt-4"
    onClick={() => (window as any).exportErrors()}
  >
    Export All Logs
  </Button>
</Card>

═══════════════════════════════════════════════════════════
VERIFICATION
═══════════════════════════════════════════════════════════

1. Test error boundary:
   # Temporarily add throw error to a component
   throw new Error('Test error');
   # Should see custom error UI with error ID

2. Test isolated boundary:
   # Add error to marketplace component
   # Should show inline error, not crash whole app

3. Test error recovery:
   # Click "Try Again" button
   # Should reset and reload component

4. View error logs in console:
   errorLogs()
   # Should show table of recent errors

5. Export errors:
   exportErrors()
   # Should download JSON file

6. Check admin dashboard:
   # Navigate to admin panel
   # Should see "Recent Errors" section
   # Should show last 5 errors

CHECKLIST:
□ ErrorBoundary.tsx updated with full features
□ Feature-specific boundaries added
□ errorReporter.ts created
□ Error logs integrated in AdminDashboard
□ Test error throwing/catching works
□ Isolated errors don't crash app
□ Error recovery works
□ errorLogs() command works
□ exportErrors() downloads JSON
□ Admin panel shows recent errors