FIX COLLECTION CARD IMAGES - FETCH NFT #1 AS CARD IMAGE

ISSUE: Collections page shows collection cards but no images - just gradient backgrounds.

ROOT CAUSE: imageUrl field is null or broken because metadata fetching failed during sync.

GOAL: Improve image fetching logic and re-sync to get proper NFT images for each collection.

═══════════════════════════════════════════════════════════════════
STEP 1: IMPROVE IMAGE FETCHING IN COLLECTION SYNC
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: server/lib/collectionSync.ts

Find the section that fetches images (should be around line 70-100) and REPLACE the entire image fetching block with this improved version:

// Get image from first available NFT (try multiple token IDs and methods)
let imageUrl: string | null = null;
try {
  if (Number(totalSupply) > 0) {
    console.log(`[CollectionSync] Fetching image for ${symbol}...`);
    
    // Try multiple token IDs (collections may start at 0, 1, or have gaps)
    const tokenIdsToTry = [0, 1, 2, 3, 4, 5];
    
    for (const tokenId of tokenIdsToTry) {
      try {
        console.log(`[CollectionSync] Trying token #${tokenId} for ${symbol}`);
        
        // Fetch tokenURI with 5 second timeout
        const tokenURIPromise = contract.tokenURI(tokenId);
        const timeoutPromise = new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('TokenURI timeout')), 5000)
        );
        
        const tokenURI = await Promise.race([tokenURIPromise, timeoutPromise]);
        
        if (tokenURI) {
          let metadataUrl = tokenURI;
          
          // Handle different URI formats
          if (tokenURI.startsWith('ipfs://')) {
            // Try multiple IPFS gateways
            const ipfsHash = tokenURI.replace('ipfs://', '');
            metadataUrl = `https://ipfs.io/ipfs/${ipfsHash}`;
          } else if (tokenURI.startsWith('data:application/json;base64,')) {
            // Handle base64 encoded metadata
            const base64Data = tokenURI.split(',')[1];
            const jsonString = Buffer.from(base64Data, 'base64').toString();
            const metadata = JSON.parse(jsonString);
            
            if (metadata.image) {
              let imgUrl = metadata.image;
              if (imgUrl.startsWith('ipfs://')) {
                const ipfsHash = imgUrl.replace('ipfs://', '');
                imgUrl = `https://ipfs.io/ipfs/${ipfsHash}`;
              }
              imageUrl = imgUrl;
              console.log(`[CollectionSync] ✓ Found base64 image for ${symbol}: token #${tokenId}`);
              break;
            }
          }
          
          // Fetch metadata JSON if it's a URL
          if (metadataUrl.startsWith('http')) {
            const metadataPromise = fetch(metadataUrl, { 
              signal: AbortSignal.timeout(5000),
              headers: {
                'User-Agent': 'Mozilla/5.0',
              }
            }).then(r => r.json());
            
            const metadataTimeoutPromise = new Promise<never>((_, reject) => 
              setTimeout(() => reject(new Error('Metadata timeout')), 5000)
            );
            
            const metadata = await Promise.race([metadataPromise, metadataTimeoutPromise]);
            
            if (metadata && metadata.image) {
              let imgUrl = metadata.image;
              
              // Handle IPFS image URLs
              if (imgUrl.startsWith('ipfs://')) {
                const ipfsHash = imgUrl.replace('ipfs://', '');
                imgUrl = `https://ipfs.io/ipfs/${ipfsHash}`;
              }
              
              imageUrl = imgUrl;
              console.log(`[CollectionSync] ✓ Found image for ${symbol}: token #${tokenId}`);
              break; // Stop trying once we find an image
            }
          }
        }
      } catch (tokenError) {
        console.warn(`[CollectionSync] Token #${tokenId} failed for ${symbol}:`, tokenError instanceof Error ? tokenError.message : tokenError);
        // Continue to next token ID
        continue;
      }
    }
    
    if (!imageUrl) {
      console.warn(`[CollectionSync] Could not fetch image for ${symbol}, will use placeholder`);
    }
  }
} catch (error) {
  console.error(`[CollectionSync] Error fetching image for ${address}:`, error);
}

// If no image found, use a nice placeholder with collection symbol
if (!imageUrl) {
  imageUrl = `https://via.placeholder.com/400/6366f1/ffffff?text=${encodeURIComponent(symbol)}`;
}


═══════════════════════════════════════════════════════════════════
STEP 2: ADD BUFFER IMPORT FOR BASE64 DECODING
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: server/lib/collectionSync.ts

At the very top of the file, make sure you have:

import { ethers } from 'ethers';
import { RPC_URL } from '../../client/src/lib/constants';
import { upsertCollection } from '../storage';
import { Buffer } from 'buffer'; // ADD THIS LINE


═══════════════════════════════════════════════════════════════════
STEP 3: IMPROVE CLIENT-SIDE IMAGE FALLBACK
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: client/src/pages/Collections.tsx

Find the <img> tag in the collection card (around line 160-170) and replace it with this improved version:

<img
  src={collection.imageUrl || `https://via.placeholder.com/400/6366f1/ffffff?text=${encodeURIComponent(collection.symbol)}`}
  alt={collection.name}
  className="w-full h-full object-cover group-hover:scale-110 transition-transform duration-300"
  loading="lazy"
  onError={(e) => {
    const target = e.currentTarget;
    // First fallback: try placeholder if original failed
    if (!target.src.includes('placeholder')) {
      console.warn(`[Collections] Image failed for ${collection.symbol}, using placeholder`);
      target.src = `https://via.placeholder.com/400/6366f1/ffffff?text=${encodeURIComponent(collection.symbol)}`;
    }
    // Second fallback: use a generic icon if placeholder also fails
    else if (!target.dataset.triedFinal) {
      target.dataset.triedFinal = 'true';
      target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgZmlsbD0iIzYzNjZmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iNDgiIGZpbGw9IiNmZmZmZmYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ORlQ8L3RleHQ+PC9zdmc+';
    }
  }}
/>


═══════════════════════════════════════════════════════════════════
STEP 4: RE-RUN COLLECTION SYNC TO FETCH IMAGES
═══════════════════════════════════════════════════════════════════

Now that we've improved the image fetching, let's re-sync to get the images.

In Replit terminal, run:

curl -X POST http://localhost:5000/api/collections/sync

OR if curl doesn't work, open browser console (F12) and run:

fetch('http://localhost:5000/api/collections/sync', {method: 'POST'})
  .then(r => r.json())
  .then(d => console.log('Sync result:', d))

This will take 30-90 seconds.

WATCH THE SERVER LOGS for messages like:
[CollectionSync] Fetching image for BASEDAI2140...
[CollectionSync] Trying token #0 for BASEDAI2140
[CollectionSync] Trying token #1 for BASEDAI2140
[CollectionSync] ✓ Found image for BASEDAI2140: token #1

EXPECTED RESULT:
Some collections will successfully fetch images, others may use placeholders.
That's OK - at least they'll all have SOME image now.


═══════════════════════════════════════════════════════════════════
STEP 5: VERIFY IMAGES IN DATABASE
═══════════════════════════════════════════════════════════════════

1. Run database studio:
npm run db:studio

2. Click on "collections" table

3. Look at the "imageUrl" column

4. Verify that rows now have URLs (not null):
   - Some will have real IPFS/metadata URLs
   - Some will have placeholder URLs like "https://via.placeholder.com/400/..."
   - NONE should be null anymore


═══════════════════════════════════════════════════════════════════
STEP 6: REFRESH COLLECTIONS PAGE
═══════════════════════════════════════════════════════════════════

1. Go to /collections in your browser

2. Hard refresh: Cmd+Shift+R (Mac) or Ctrl+Shift+R (Windows)

3. You should now see:
   ✓ Collection cards with images (either real NFT images or styled placeholders)
   ✓ No more empty gradient backgrounds
   ✓ Each collection has a visual representation

4. If still showing gradients:
   - Check browser console (F12) for errors
   - Look for "Image failed for..." warnings
   - Verify the API returns imageUrl: curl http://localhost:5000/api/collections/all


═══════════════════════════════════════════════════════════════════
STEP 7: ADD ADMIN MANUAL IMAGE UPDATE (OPTIONAL)
═══════════════════════════════════════════════════════════════════

For collections where auto-fetch fails, let's add a way to manually set images.

1. UPDATE FILE: server/routes.ts

Add this endpoint:

// Manually update collection image
app.put('/api/collections/:address/image', async (req, res) => {
  try {
    const { address } = req.params;
    const { imageUrl } = req.body;
    
    // TODO: Add admin authentication check here
    
    await upsertCollection({
      address,
      imageUrl,
      // Other fields will be preserved
    } as any);
    
    res.json({ success: true });
  } catch (error: any) {
    console.error('[API] Failed to update collection image:', error);
    res.status(500).json({ error: error.message });
  }
});


═══════════════════════════════════════════════════════════════════
TROUBLESHOOTING
═══════════════════════════════════════════════════════════════════

PROBLEM: Still no images after re-sync
SOLUTION: 
- Check server logs during sync - are all collections timing out?
- May need to increase timeout values (currently 5 seconds)
- Some collections may have broken metadata on-chain (use placeholder)

PROBLEM: Images showing but very slowly
SOLUTION:
- IPFS can be slow - this is normal
- Images are lazy-loaded, so they load as you scroll
- Consider caching images on your server in the future

PROBLEM: Some collections show placeholder, others show real image
SOLUTION:
- This is expected! Some collections have working metadata, others don't
- Placeholder is styled to match your theme
- You can manually set images later using the admin endpoint

DONE! Collection cards should now show images (real NFT images or styled placeholders).