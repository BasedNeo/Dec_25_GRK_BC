Create an automated daily reconciliation system that compares blockchain data versus database data to detect discrepancies and ensure financial accuracy.

STEP 1: CREATE RECONCILIATION SERVICE

1. CREATE FILE: server/lib/reconciliation.ts

import { ethers } from 'ethers';
import { NFT_CONTRACT, MARKETPLACE_CONTRACT, RPC_URL } from '../../client/src/lib/constants';

interface ReconciliationReport {
  timestamp: Date;
  totalMinted: { blockchain: number; database: number; difference: number };
  totalSales: { blockchain: number; database: number; difference: number };
  totalVolume: { blockchain: string; database: string; difference: string };
  discrepancies: Array<{ type: string; blockchain: any; database: any; severity: 'low' | 'medium' | 'high' }>;
  status: 'healthy' | 'warning' | 'critical';
}

export class FinancialReconciliation {
  private provider: ethers.JsonRpcProvider;
  
  constructor() {
    this.provider = new ethers.JsonRpcProvider(RPC_URL);
  }
  
  async reconcile(): Promise<ReconciliationReport> {
    const report: ReconciliationReport = {
      timestamp: new Date(),
      totalMinted: { blockchain: 0, database: 0, difference: 0 },
      totalSales: { blockchain: 0, database: 0, difference: 0 },
      totalVolume: { blockchain: '0', database: '0', difference: '0' },
      discrepancies: [],
      status: 'healthy'
    };
    
    try {
      const nftContract = new ethers.Contract(
        NFT_CONTRACT,
        ['function totalMinted() view returns (uint256)'],
        this.provider
      );
      
      const blockchainMinted = Number(await nftContract.totalMinted());
      const databaseMinted = await this.getDatabaseMintedCount();
      
      report.totalMinted = {
        blockchain: blockchainMinted,
        database: databaseMinted,
        difference: blockchainMinted - databaseMinted
      };
      
      if (Math.abs(report.totalMinted.difference) > 0) {
        report.discrepancies.push({
          type: 'minted_count',
          blockchain: blockchainMinted,
          database: databaseMinted,
          severity: Math.abs(report.totalMinted.difference) > 5 ? 'high' : 'medium'
        });
      }
      
      const marketplaceSales = await this.getMarketplaceSalesCount();
      const databaseSales = await this.getDatabaseSalesCount();
      
      report.totalSales = {
        blockchain: marketplaceSales,
        database: databaseSales,
        difference: marketplaceSales - databaseSales
      };
      
      if (Math.abs(report.totalSales.difference) > 0) {
        report.discrepancies.push({
          type: 'sales_count',
          blockchain: marketplaceSales,
          database: databaseSales,
          severity: Math.abs(report.totalSales.difference) > 10 ? 'high' : 'medium'
        });
      }
      
      const blockchainVolume = await this.getMarketplaceVolume();
      const databaseVolume = await this.getDatabaseVolume();
      
      report.totalVolume = {
        blockchain: blockchainVolume,
        database: databaseVolume,
        difference: (parseFloat(blockchainVolume) - parseFloat(databaseVolume)).toString()
      };
      
      const volumeDiffPercent = Math.abs((parseFloat(report.totalVolume.difference) / parseFloat(blockchainVolume)) * 100);
      
      if (volumeDiffPercent > 1) {
        report.discrepancies.push({
          type: 'volume',
          blockchain: blockchainVolume,
          database: databaseVolume,
          severity: volumeDiffPercent > 5 ? 'high' : 'medium'
        });
      }
      
      const highSeverity = report.discrepancies.filter(d => d.severity === 'high');
      const mediumSeverity = report.discrepancies.filter(d => d.severity === 'medium');
      
      if (highSeverity.length > 0) {
        report.status = 'critical';
      } else if (mediumSeverity.length > 0) {
        report.status = 'warning';
      }
      
    } catch (error) {
      console.error('[RECONCILIATION] Error:', error);
      report.status = 'critical';
      report.discrepancies.push({
        type: 'reconciliation_failed',
        blockchain: null,
        database: null,
        severity: 'high'
      });
    }
    
    return report;
  }
  
  private async getDatabaseMintedCount(): Promise<number> {
    return 0;
  }
  
  private async getDatabaseSalesCount(): Promise<number> {
    return 0;
  }
  
  private async getDatabaseVolume(): Promise<string> {
    return '0';
  }
  
  private async getMarketplaceSalesCount(): Promise<number> {
    try {
      const marketplace = new ethers.Contract(
        MARKETPLACE_CONTRACT,
        ['event NFTSold(uint256 indexed tokenId, address seller, address buyer, uint256 price)'],
        this.provider
      );
      
      const currentBlock = await this.provider.getBlockNumber();
      const fromBlock = Math.max(0, currentBlock - 1000000);
      
      const filter = marketplace.filters.NFTSold();
      const events = await marketplace.queryFilter(filter, fromBlock, 'latest');
      
      return events.length;
    } catch (error) {
      console.error('[RECONCILIATION] Failed to get marketplace sales:', error);
      return 0;
    }
  }
  
  private async getMarketplaceVolume(): Promise<string> {
    try {
      const marketplace = new ethers.Contract(
        MARKETPLACE_CONTRACT,
        ['event NFTSold(uint256 indexed tokenId, address seller, address buyer, uint256 price)'],
        this.provider
      );
      
      const currentBlock = await this.provider.getBlockNumber();
      const fromBlock = Math.max(0, currentBlock - 1000000);
      
      const filter = marketplace.filters.NFTSold();
      const events = await marketplace.queryFilter(filter, fromBlock, 'latest');
      
      let total = BigInt(0);
      for (const event of events) {
        if ('args' in event && event.args && event.args.price) {
          total += BigInt(event.args.price);
        }
      }
      
      return ethers.formatEther(total);
    } catch (error) {
      console.error('[RECONCILIATION] Failed to get marketplace volume:', error);
      return '0';
    }
  }
}

STEP 2: CREATE RECONCILIATION SCRIPT

2. CREATE FILE: script/reconcile-finances.ts

import { FinancialReconciliation } from '../server/lib/reconciliation';

async function main() {
  console.log('üîç Starting financial reconciliation...\n');
  
  const reconciliation = new FinancialReconciliation();
  const report = await reconciliation.reconcile();
  
  console.log('üìä RECONCILIATION REPORT');
  console.log('========================');
  console.log(`Timestamp: ${report.timestamp.toISOString()}`);
  console.log(`Status: ${report.status.toUpperCase()}\n`);
  
  console.log('Total Minted:');
  console.log(`  Blockchain: ${report.totalMinted.blockchain}`);
  console.log(`  Database: ${report.totalMinted.database}`);
  console.log(`  Difference: ${report.totalMinted.difference}\n`);
  
  console.log('Total Sales:');
  console.log(`  Blockchain: ${report.totalSales.blockchain}`);
  console.log(`  Database: ${report.totalSales.database}`);
  console.log(`  Difference: ${report.totalSales.difference}\n`);
  
  console.log('Total Volume:');
  console.log(`  Blockchain: ${report.totalVolume.blockchain} $BASED`);
  console.log(`  Database: ${report.totalVolume.database} $BASED`);
  console.log(`  Difference: ${report.totalVolume.difference} $BASED\n`);
  
  if (report.discrepancies.length > 0) {
    console.log(`‚ö†Ô∏è  DISCREPANCIES FOUND: ${report.discrepancies.length}\n`);
    report.discrepancies.forEach((d, i) => {
      console.log(`${i + 1}. ${d.type} [${d.severity.toUpperCase()}]`);
      console.log(`   Blockchain: ${JSON.stringify(d.blockchain)}`);
      console.log(`   Database: ${JSON.stringify(d.database)}\n`);
    });
    
    if (report.status === 'critical') {
      console.log('üö® CRITICAL DISCREPANCY - Manual review required\n');
    }
  } else {
    console.log('‚úÖ All systems in sync!\n');
  }
  
  console.log('Reconciliation complete.');
}

main().catch(console.error);

STEP 3: ADD RECONCILIATION REPORTS TABLE

3. UPDATE FILE: shared/schema.ts

Add this table:

export const reconciliationReports = pgTable('reconciliation_reports', {
  id: serial('id').primaryKey(),
  timestamp: timestamp('timestamp').defaultNow(),
  status: text('status').notNull(),
  totalMintedBlockchain: integer('total_minted_blockchain'),
  totalMintedDatabase: integer('total_minted_database'),
  totalSalesBlockchain: integer('total_sales_blockchain'),
  totalSalesDatabase: integer('total_sales_database'),
  totalVolumeBlockchain: text('total_volume_blockchain'),
  totalVolumeDatabase: text('total_volume_database'),
  discrepancies: text('discrepancies'),
  notes: text('notes'),
});

export type ReconciliationReport = typeof reconciliationReports.$inferSelect;
export type InsertReconciliationReport = typeof reconciliationReports.$inferInsert;

STEP 4: PUSH DATABASE

4. RUN IN TERMINAL:

npm run db:push

STEP 5: ADD DATABASE METHODS

5. UPDATE FILE: server/storage.ts

Add import:

import { reconciliationReports, type ReconciliationReport as ReconciliationReportType, type InsertReconciliationReport } from "@shared/schema";

Add methods:

async saveReconciliationReport(report: any): Promise<ReconciliationReportType> {
  const [saved] = await db.insert(reconciliationReports).values({
    status: report.status,
    totalMintedBlockchain: report.totalMinted.blockchain,
    totalMintedDatabase: report.totalMinted.database,
    totalSalesBlockchain: report.totalSales.blockchain,
    totalSalesDatabase: report.totalSales.database,
    totalVolumeBlockchain: report.totalVolume.blockchain,
    totalVolumeDatabase: report.totalVolume.database,
    discrepancies: JSON.stringify(report.discrepancies),
  }).returning();
  return saved;
}

async getLatestReconciliationReport(): Promise<ReconciliationReportType | undefined> {
  const [report] = await db.select()
    .from(reconciliationReports)
    .orderBy(desc(reconciliationReports.timestamp))
    .limit(1);
  return report;
}

async getReconciliationHistory(limit: number = 30): Promise<ReconciliationReportType[]> {
  return db.select()
    .from(reconciliationReports)
    .orderBy(desc(reconciliationReports.timestamp))
    .limit(limit);
}

STEP 6: ADD API ENDPOINTS

6. UPDATE FILE: server/routes.ts

Add:

import { FinancialReconciliation } from './lib/reconciliation';

app.post('/api/admin/reconcile', isAdmin, async (req, res) => {
  try {
    const reconciliation = new FinancialReconciliation();
    const report = await reconciliation.reconcile();
    
    await storage.saveReconciliationReport(report);
    
    res.json({ report });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/reconciliation/latest', isAdmin, async (req, res) => {
  try {
    const report = await storage.getLatestReconciliationReport();
    res.json({ report });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/reconciliation/history', isAdmin, async (req, res) => {
  try {
    const history = await storage.getReconciliationHistory(30);
    res.json({ history });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

STEP 7: ADD ADMIN UI

7. UPDATE FILE: client/src/components/AdminDashboard.tsx

Add this component:

const ReconciliationPanel = () => {
  const [report, setReport] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    fetchLatestReport();
  }, []);
  
  const fetchLatestReport = async () => {
    try {
      const res = await fetch('/api/admin/reconciliation/latest');
      const data = await res.json();
      setReport(data.report);
    } catch (error) {
      console.error('Failed to fetch report:', error);
    }
  };
  
  const runReconciliation = async () => {
    setLoading(true);
    addLog('Running financial reconciliation...');
    
    try {
      const res = await fetch('/api/admin/reconcile', { method: 'POST' });
      const data = await res.json();
      
      setReport(data.report);
      addLog(`‚úÖ Reconciliation complete: ${data.report.status}`);
      
      if (data.report.discrepancies.length > 0) {
        showToast(`Found ${data.report.discrepancies.length} discrepancies`, 'warning');
      } else {
        showToast('All systems in sync', 'success');
      }
    } catch (error: any) {
      addLog(`‚ùå Reconciliation failed: ${error.message}`);
      showToast('Reconciliation failed', 'error');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className={`p-6 border rounded-xl ${
      report?.status === 'critical' ? 'border-red-500 bg-red-500/10' :
      report?.status === 'warning' ? 'border-yellow-500 bg-yellow-500/10' :
      'border-green-500 bg-green-500/10'
    }`}>
      <h3 className="text-xl font-bold mb-4">üìä Financial Reconciliation</h3>
      
      <Button onClick={runReconciliation} disabled={loading} className="mb-4">
        {loading ? 'Running...' : 'Run Reconciliation Now'}
      </Button>
      
      {report && (
        <>
          <div className={`text-2xl font-bold mb-4 ${
            report.status === 'healthy' ? 'text-green-400' :
            report.status === 'warning' ? 'text-yellow-400' :
            'text-red-400'
          }`}>
            Status: {report.status.toUpperCase()}
          </div>
          
          <div className="grid grid-cols-3 gap-4 mb-4">
            <div className="bg-black/40 p-3 rounded">
              <div className="text-xs text-gray-400">Total Minted</div>
              <div className="text-white">Blockchain: {report.totalMintedBlockchain}</div>
              <div className="text-white">Database: {report.totalMintedDatabase}</div>
              <div className={
                report.totalMintedBlockchain !== report.totalMintedDatabase ? 'text-red-400' : 'text-green-400'
              }>
                Diff: {report.totalMintedBlockchain - report.totalMintedDatabase}
              </div>
            </div>
            
            <div className="bg-black/40 p-3 rounded">
              <div className="text-xs text-gray-400">Total Sales</div>
              <div className="text-white">Blockchain: {report.totalSalesBlockchain}</div>
              <div className="text-white">Database: {report.totalSalesDatabase}</div>
              <div className={
                report.totalSalesBlockchain !== report.totalSalesDatabase ? 'text-red-400' : 'text-green-400'
              }>
                Diff: {report.totalSalesBlockchain - report.totalSalesDatabase}
              </div>
            </div>
            
            <div className="bg-black/40 p-3 rounded">
              <div className="text-xs text-gray-400">Total Volume</div>
              <div className="text-white">Chain: {parseFloat(report.totalVolumeBlockchain).toLocaleString()}</div>
              <div className="text-white">DB: {parseFloat(report.totalVolumeDatabase).toLocaleString()}</div>
            </div>
          </div>
          
          {report.discrepancies && JSON.parse(report.discrepancies).length > 0 && (
            <div className="space-y-2">
              <h4 className="font-bold">‚ö†Ô∏è Discrepancies:</h4>
              {JSON.parse(report.discrepancies).map((d: any, i: number) => (
                <div key={i} className={`p-3 bg-black/40 rounded border ${
                  d.severity === 'high' ? 'border-red-500' : 'border-yellow-500'
                }`}>
                  <div className="font-bold">{d.type}</div>
                  <div className="text-sm">Blockchain: {JSON.stringify(d.blockchain)}</div>
                  <div className="text-sm">Database: {JSON.stringify(d.database)}</div>
                </div>
              ))}
            </div>
          )}
          
          <div className="text-xs text-gray-400 mt-4">
            Last run: {new Date(report.timestamp).toLocaleString()}
          </div>
        </>
      )}
    </div>
  );
};

Then add <ReconciliationPanel /> to the dashboard render.

STEP 8: ADD TO PACKAGE.JSON

8. UPDATE FILE: package.json

Add script:

"reconcile": "tsx script/reconcile-finances.ts"

STEP 9: SCHEDULE DAILY RECONCILIATION

9. CREATE FILE: .github/workflows/reconcile.yml (if using GitHub)

name: Daily Reconciliation

on:
  schedule:
    - cron: '0 3 * * *'

jobs:
  reconcile:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
      - run: npm install
      - run: npm run reconcile

Or document manual scheduling in Replit Cron.

VERIFICATION STEPS:
1. Run in terminal: npm run reconcile
2. Should see reconciliation report output
3. Check database: SELECT * FROM reconciliation_reports;
4. Should see 1 report record
5. Open Admin Dashboard
6. Find Reconciliation panel
7. Click "Run Reconciliation Now"
8. Should see status and metrics
9. If discrepancies found, should show in red/yellow
10. Run again - should store multiple reports

This ensures your financial data stays accurate and synced with blockchain.