=== IMPLEMENT V3 OFF-CHAIN OFFERS (AFTERMINT STYLE) ===

The V3 marketplace contract is deployed at 0x2a3f9D8b844c2dB2F42095B49817c0D6991514f3
It uses EIP-712 signatures so funds STAY in buyer's wallet until seller accepts.

STEP 1: Create /client/src/hooks/useOffersV3.ts

import { useState, useCallback, useEffect } from 'react';
import { useAccount, useSignTypedData, useWriteContract, useWaitForTransactionReceipt, usePublicClient } from 'wagmi';
import { parseEther, formatEther } from 'viem';
import { MARKETPLACE_V3_CONTRACT, NFT_CONTRACT, CHAIN_ID, SITE_URL } from '@/lib/constants';

const DOMAIN = {
  name: 'BasedGuardiansMarketplaceV3',
  version: '1',
  chainId: CHAIN_ID,
  verifyingContract: MARKETPLACE_V3_CONTRACT as `0x${string}`,
};

const OFFER_TYPES = {
  Offer: [
    { name: 'tokenId', type: 'uint256' },
    { name: 'amount', type: 'uint256' },
    { name: 'expirationTime', type: 'uint256' },
    { name: 'nonce', type: 'uint256' },
  ],
};

export interface OffchainOffer {
  id: string;
  tokenId: number;
  buyer: string;
  amount: string;
  amountWei: bigint;
  expirationTime: number;
  nonce: number;
  signature: string;
  status: 'pending' | 'accepted' | 'completed' | 'cancelled' | 'expired';
  createdAt: number;
}

const STORAGE_KEY = 'basedguardians_offers_v3';

function getStoredOffers(): OffchainOffer[] {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) return [];
    const offers = JSON.parse(stored);
    return offers.filter((o: OffchainOffer) => o.expirationTime * 1000 > Date.now() && o.status !== 'completed' && o.status !== 'cancelled');
  } catch { return []; }
}

function saveOffers(offers: OffchainOffer[]) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(offers));
}

export function useOffersV3() {
  const { address } = useAccount();
  const publicClient = usePublicClient();
  const [offers, setOffers] = useState<OffchainOffer[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  const { signTypedDataAsync } = useSignTypedData();
  const { writeContract, data: txHash, isPending } = useWriteContract();
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash: txHash });

  useEffect(() => { setOffers(getStoredOffers()); }, []);

  const fetchNonce = useCallback(async (buyerAddress: string): Promise<number> => {
    if (!publicClient) return 0;
    try {
      const nonce = await publicClient.readContract({
        address: MARKETPLACE_V3_CONTRACT as `0x${string}`,
        abi: [{ name: 'nonces', type: 'function', stateMutability: 'view', inputs: [{ type: 'address' }], outputs: [{ type: 'uint256' }] }],
        functionName: 'nonces',
        args: [buyerAddress as `0x${string}`],
      });
      return Number(nonce);
    } catch { return 0; }
  }, [publicClient]);

  const makeOffer = useCallback(async (tokenId: number, amountBased: number, durationDays: number = 7) => {
    if (!address) throw new Error('Connect wallet');
    setIsLoading(true);
    try {
      const nonce = await fetchNonce(address);
      const expirationTime = Math.floor(Date.now() / 1000) + (durationDays * 24 * 60 * 60);
      const amountWei = parseEther(String(amountBased));

      const signature = await signTypedDataAsync({
        domain: DOMAIN,
        types: OFFER_TYPES,
        primaryType: 'Offer',
        message: { tokenId: BigInt(tokenId), amount: amountWei, expirationTime: BigInt(expirationTime), nonce: BigInt(nonce) },
      });

      const offer: OffchainOffer = {
        id: `${address}-${tokenId}-${Date.now()}`,
        tokenId, buyer: address, amount: String(amountBased), amountWei,
        expirationTime, nonce, signature, status: 'pending', createdAt: Date.now(),
      };

      const updated = [...getStoredOffers().filter(o => !(o.buyer === address && o.tokenId === tokenId)), offer];
      saveOffers(updated);
      setOffers(updated);
      return offer;
    } finally { setIsLoading(false); }
  }, [address, signTypedDataAsync, fetchNonce]);

  const cancelOffer = useCallback((offerId: string) => {
    const updated = getStoredOffers().map(o => o.id === offerId ? { ...o, status: 'cancelled' as const } : o);
    saveOffers(updated);
    setOffers(updated.filter(o => o.status !== 'cancelled'));
  }, []);

  const getOffersForToken = useCallback((tokenId: number) => {
    return offers.filter(o => o.tokenId === tokenId && o.status === 'pending');
  }, [offers]);

  const getMyOffers = useCallback(() => {
    if (!address) return [];
    return offers.filter(o => o.buyer.toLowerCase() === address.toLowerCase());
  }, [address, offers]);

  return { makeOffer, cancelOffer, getOffersForToken, getMyOffers, offers, isLoading, isPending, isConfirming, isSuccess, txHash };
}

STEP 2: Create /client/src/components/MyOffersPanel.tsx

import { useOffersV3 } from '@/hooks/useOffersV3';
import { formatDistanceToNow } from 'date-fns';

export function MyOffersPanel() {
  const { getMyOffers, cancelOffer, isLoading } = useOffersV3();
  const myOffers = getMyOffers();

  if (myOffers.length === 0) {
    return (
      <div className="bg-black/60 border border-cyan-500/30 rounded-lg p-6 text-center">
        <p className="text-gray-400">No active offers</p>
        <p className="text-sm text-gray-500 mt-2">Your offers will appear here</p>
      </div>
    );
  }

  return (
    <div className="bg-black/60 border border-cyan-500/30 rounded-lg overflow-hidden">
      <div className="p-4 border-b border-cyan-500/30">
        <h3 className="text-lg font-bold text-cyan-400">MY OFFERS ({myOffers.length})</h3>
      </div>
      <div className="divide-y divide-cyan-500/20">
        {myOffers.map(offer => (
          <div key={offer.id} className="p-4 flex items-center justify-between hover:bg-cyan-500/5">
            <div className="flex items-center gap-4">
              <div className="w-12 h-12 bg-gradient-to-br from-cyan-500/20 to-purple-500/20 rounded flex items-center justify-center">
                <span className="text-cyan-400 font-bold">#{offer.tokenId}</span>
              </div>
              <div>
                <p className="font-bold text-white">{Number(offer.amount).toLocaleString()} $BASED</p>
                <p className="text-xs text-gray-400">
                  Expires {formatDistanceToNow(offer.expirationTime * 1000, { addSuffix: true })}
                </p>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <span className={`px-2 py-1 rounded text-xs font-bold ${
                offer.status === 'pending' ? 'bg-yellow-500/20 text-yellow-400' :
                offer.status === 'accepted' ? 'bg-green-500/20 text-green-400' : 'bg-gray-500/20 text-gray-400'
              }`}>
                {offer.status.toUpperCase()}
              </span>
              {offer.status === 'pending' && (
                <button
                  onClick={() => cancelOffer(offer.id)}
                  className="px-3 py-1 bg-red-500/20 text-red-400 rounded hover:bg-red-500/30 text-sm font-bold"
                  disabled={isLoading}
                >
                  CANCEL
                </button>
              )}
            </div>
          </div>
        ))}
      </div>
      <div className="p-3 bg-cyan-500/5 border-t border-cyan-500/30">
        <p className="text-xs text-cyan-400/70 text-center">
          âœ“ Funds stay in your wallet until seller accepts
        </p>
      </div>
    </div>
  );
}

STEP 3: Add MyOffersPanel to Portfolio page
In /client/src/components/EscrowMarketplace.tsx (or wherever Portfolio tab is):
- Import: import { MyOffersPanel } from './MyOffersPanel';
- Add the <MyOffersPanel /> component in the Portfolio tab section, after the NFT grid