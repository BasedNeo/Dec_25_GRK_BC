
Searching for AGENTS instructions
/workspace/Dec_25_GRK_BC$ /bin/bash -lc ls
ARCHITECTURE.md		 attached_assets	replit.md
CHANGELOG.md		 client			script
DEPLOYMENT_CHECKLIST.md  components.json	scripts
DEVELOPMENT_GUIDE.md	 docs			server
LAST_BACKUP.txt		 drizzle.config.ts	shared
PROJECT_SCOPE.md	 node_modules		tests
README.md		 package-lock.json	tsconfig.json
TESTING_CHECKLIST.md	 package.json		vite-plugin-meta-images.ts
VERIFICATION.md		 postcss.config.js.bak	vite.config.ts
Searching for AGENTS files
/workspace/Dec_25_GRK_BC$ /bin/bash -lc find .. -name AGENTS.md -print
Checking for AGENTS presence
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,220p' server/routes.ts
import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertFeedbackSchema, insertStorySchema, analyticsEvents, collections } from "@shared/schema";
import { CollectionService } from './lib/collectionService';
import { GatingService } from './lib/gatingService';
import { searchService, type SearchFilters } from './lib/searchService';
import { z } from "zod";
import { containsProfanity } from "./profanityFilter";
import { writeLimiter, authLimiter, gameLimiter } from './middleware/rateLimiter';
import { ipBanGuard } from './middleware/ipBanGuard';
import { EndpointLimiters } from './lib/endpointLimiters';
import { AdvancedRateLimiter, readLimiter } from './lib/advancedRateLimiter';
import { 
  validateCustomName, 
  validateProposal, 
  validateWalletAddress,
  sanitizeQueryParams
} from './middleware/validation';
import { validateRequest, validateQuery } from './middleware/validationMiddleware';
import { ValidationRulesEngine } from './lib/validationRules';
import { ValidationSchemas } from './lib/validationSchemas';
import { InputSanitizer } from './lib/sanitizer';
import { sqlInjectionGuard } from './middleware/sqlInjectionGuard';
import { QueryAuditor } from './lib/queryValidator';
import { SecureDatabaseConnection } from './lib/dbSecurity';
import { SessionManager } from './lib/sessionManager';
import { SignatureVerifier } from './lib/signatureVerifier';
import { NonceManager } from './lib/nonceManager';
import { OriginValidator } from './lib/originValidator';
import { CSRFProtection } from './lib/csrfProtection';
import { getActivityData, getCacheStatus } from './lib/activityCache';
import { callOracle, generateRiddlePrompt, evaluateAnswerPrompt, getHintPrompt } from './lib/oracleService';
// STRIPPED FOR LAUNCH: Enterprise security features
// import { EncryptionService } from './lib/encryption';
// import { EncryptedStorageService } from './lib/encryptedStorage';
// import { SecurityMonitor } from './lib/securityMonitor';
// import { ThreatDetection } from './lib/threatDetection';
// import { IncidentResponse } from './lib/incidentResponse';
import { requireAuth, requireSessionAdmin, optionalAuth, AuthRequest } from './middleware/auth';
import { AdminAuthService } from './lib/adminAuth';
import { wsManager } from './lib/websocketManager';
import { db } from "./db";
import { sql } from "drizzle-orm";
import { ethers } from "ethers";
import { WalletScanner } from './lib/walletScanner';
import { ECONOMY, VALID_GAMES, isValidAction, getActionPoints, GameType } from "@shared/economy";
import crypto from "crypto";
import { exec } from "child_process";
import { promisify } from "util";
import { stat, readdir } from "fs/promises";
import path from "path";

const execAsync = promisify(exec);

// API timeout wrapper - prevents cascade failures from slow operations
const API_TIMEOUT_MS = 5000;

async function withTimeout<T>(promise: Promise<T>, fallback: T, timeoutMs = API_TIMEOUT_MS): Promise<T> {
  const timeoutPromise = new Promise<T>((_, reject) => 
    setTimeout(() => reject(new Error('API_TIMEOUT')), timeoutMs)
  );
  try {
    return await Promise.race([promise, timeoutPromise]);
  } catch (error) {
    if (error instanceof Error && error.message === 'API_TIMEOUT') {
      console.warn('[API] Operation timed out, returning fallback');
      return fallback;
    }
    throw error;
  }
}

const FEEDBACK_EMAIL = "team@BasedGuardians.trade";

const VAPID_PUBLIC_KEY = process.env.VAPID_PUBLIC_KEY || 'BN_placeholder_key_for_development';

// GOVERNANCE OVERHAUL â€” Codex Audit Fix: NFT contract and RPC for ownership verification
const NFT_CONTRACT_ADDRESS = process.env.NFT_CONTRACT_ADDRESS || '0xaE51dc5fD1499A129f8654963560f9340773ad59';
const RPC_URL = process.env.RPC_URL || 'https://mainnet.basedaibridge.com/rpc/';

// Ethereum address validation regex (checksummed or lowercase)
const ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;

function isValidEthAddress(address: string): boolean {
  return ETH_ADDRESS_REGEX.test(address);
}

// Sanitize text input - strip HTML tags and dangerous characters
function sanitizeInput(text: string): string {
  return text
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/[<>]/g, '') // Remove any remaining angle brackets
    .trim();
}

const ADMIN_WALLETS = [
  "0xae543104fdbe456478e19894f7f0e01f0971c9b4",
  "0xb1362caf09189887599ed40f056712b1a138210c",
  "0xabce9e63a9ae51e215bb10c9648f4c0f400c5847",
  "0xbba49256a93a06fcf3b0681fead2b4e3042b9124",
  "0xc5ca5cb0acf8f7d4c6cd307d0d875ee2e09fb1af",
  "0x9392b6a9d78a52aefeaf1122121cfc09e98cbcf4",
  "0x3a0f4636c99a644a5d30d710cc3ef72e77b64dc7",
  "0x76ca648359e118687fc0a2fd53a3c29e2c71570f"
];

// Admin nonce configuration for EIP-191 signature verification
const NONCE_EXPIRY_MS = 5 * 60 * 1000; // 5 minutes

async function generateAdminNonce(wallet: string): Promise<string> {
  const nonce = crypto.randomBytes(32).toString('hex');
  const expiresAt = new Date(Date.now() + NONCE_EXPIRY_MS);
  await storage.createAdminNonce(wallet, nonce, expiresAt);
  return nonce;
}

async function verifyAdminSignature(wallet: string, signature: string): Promise<boolean> {
  const stored = await storage.getAdminNonce(wallet);
  if (!stored) return false;
  
  // ALWAYS consume nonce on any verification attempt (prevents replay attacks)
  await storage.deleteAdminNonce(wallet);
  
  if (new Date() > stored.expiresAt) {
    return false;
  }

  try {
    const message = `Based Guardians Admin Auth\nNonce: ${stored.nonce}`;
    const recoveredAddress = ethers.verifyMessage(message, signature);
    return recoveredAddress.toLowerCase() === wallet.toLowerCase();
  } catch {
    return false;
  }
}

// Admin authentication middleware - requires EIP-191 signature verification
async function requireAdmin(req: Request, res: Response, next: NextFunction) {
  try {
    const walletAddress = req.headers['x-wallet-address'] as string;
    const signature = req.headers['x-admin-signature'] as string;
    
    if (!walletAddress) {
      return res.status(401).json({ error: "Authentication required" });
    }
    
    if (!isValidEthAddress(walletAddress)) {
      return res.status(400).json({ error: "Invalid wallet address format" });
    }
    
    if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
      return res.status(403).json({ error: "Admin access required" });
    }

    // Verify EIP-191 signature
    if (!signature) {
      return res.status(401).json({ error: "Signature required for admin access" });
    }

    if (!(await verifyAdminSignature(walletAddress, signature))) {
      return res.status(401).json({ error: "Invalid or expired signature" });
    }
    
    next();
  } catch (error) {
    console.error('[Admin Auth] Error during authentication:', error);
    return res.status(500).json({ error: "Authentication service temporarily unavailable" });
  }
}

// Static riddle pool for fallback when Oracle is unavailable
const STATIC_RIDDLE_POOL = [
  { question: "I am the key to fortunes untold, but myself I am never gold. What am I?", answers: "knowledge|wisdom", hint: "It's more valuable than treasure", difficulty: "medium", theme: "crypto" },
  { question: "In the chain I'm born, through nodes I'm sworn, validated by many, trusted by any. What am I?", answers: "block|blockchain block", hint: "A building block of trust", difficulty: "medium", theme: "blockchain" },
  { question: "I guard your vault with no key or lock, through math alone I stop the clock. What am I?", answers: "cryptography|encryption", hint: "Ancient art made digital", difficulty: "hard", theme: "security" },
  { question: "Many hold me but never touch, spend me freely though worth so much. What am I?", answers: "token|cryptocurrency|crypto", hint: "Digital but valuable", difficulty: "easy", theme: "crypto" },
  { question: "I am the bridge between two shores, connecting chains through digital doors. What am I?", answers: "bridge|cross-chain bridge", hint: "I help assets travel", difficulty: "medium", theme: "defi" },
  { question: "Born from nothing yet worth everything, created by solving but never unsettling. What am I?", answers: "bitcoin|btc", hint: "The first of its kind", difficulty: "easy", theme: "crypto" },
  { question: "I am the guardian of private ways, securing secrets for endless days. What am I?", answers: "private key|seed phrase", hint: "Never share me", difficulty: "medium", theme: "security" },
  { question: "In layers I grow, each one more secure, smart in my contracts, my code is pure. What am I?", answers: "ethereum|eth|smart contract", hint: "Layer by layer, contract by contract", difficulty: "hard", theme: "blockchain" },
  { question: "I pool together, I yield rewards, liquidity's guardian, decentralized hoards. What am I?", answers: "liquidity pool|amm|dex", hint: "Where tokens swim together", difficulty: "hard", theme: "defi" },
  { question: "Though I am digital, I am unique, verifiable ownership for those who seek. What am I?", answers: "nft|non-fungible token", hint: "One of a kind in pixels", difficulty: "easy", theme: "nft" },
  { question: "I am the consensus that all must find, Byzantine generals of the digital kind. What am I?", answers: "consensus|consensus mechanism|proof", hint: "We must all agree", difficulty: "hard", theme: "blockchain" },
  { question: "Staked and locked yet earning still, securing networks by guardian will. What am I?", answers: "staking|validator|stake", hint: "Lock to earn", difficulty: "medium", theme: "defi" },
  { question: "I am the address where treasures hide, alphanumeric secrets held inside. What am I?", answers: "wallet address|public address|wallet", hint: "Your crypto mailbox", difficulty: "easy", theme: "crypto" },
  { question: "From chaos I bring order anew, hashing all data into something true. What am I?", answers: "hash|hash function|hashing", hint: "Digital fingerprint", difficulty: "medium", theme: "security" },
  { question: "I govern the DAO with vote and voice, community power through collective choice. What am I?", answers: "governance token|governance|vote", hint: "Democracy in code", difficulty: "medium", theme: "dao" }
];

async function generateDailyRiddleSet(dateKey: string) {
  console.log(`[RiddleQuest] Generating daily set for ${dateKey}`);
  
  let useOracle = false;
  let oracleRiddles: Array<{question: string; answers: string; hint: string; difficulty: string; theme: string}> = [];
  
  try {
    const testResult = await callOracle([{ role: 'user', content: 'Generate a single crypto-themed riddle' }], 'generate_riddle');
    useOracle = testResult.success;
  } catch (e) {
    console.warn('[RiddleQuest] Oracle unavailable, using static riddles');
  }
  
  const set = await storage.createDailySet({
    dateKey,
    generatedViaOracle: useOracle,
    riddleCount: 5
  });
  
  if (useOracle) {
    for (let i = 0; i < 5; i++) {
      try {
        const difficulties = ['easy', 'medium', 'medium', 'hard', 'hard'];
        const result = await callOracle(
          [{ role: 'user', content: generateRiddlePrompt(i + 1, difficulties[i]) }],
          'generate_riddle'
        );
        
        if (result.success && result.riddleGenerated) {
          oracleRiddles.push({
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,220p' client/src/pages/RiddleQuestPage.tsx
import { useLocation } from 'wouter';
import { useAccount, useReadContract } from 'wagmi';
import { useConnectModal } from '@rainbow-me/rainbowkit';
import { motion } from 'framer-motion';
import { Home, Lock, Brain } from 'lucide-react';
import { Navbar } from '@/components/Navbar';
import { RiddleQuest } from '@/components/RiddleQuest';
import { NFT_CONTRACT } from '@/lib/constants';
import { Button } from '@/components/ui/button';
import { PointsBadge } from '@/components/PointsDisplay';

const ERC721_ABI = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'owner', type: 'address' }],
    outputs: [{ name: '', type: 'uint256' }],
  },
] as const;

export default function RiddleQuestPage() {
  const [, navigate] = useLocation();
  const { address, isConnected } = useAccount();
  const { openConnectModal } = useConnectModal();

  const { data: nftBalance, isLoading: isLoadingBalance } = useReadContract({
    address: NFT_CONTRACT as `0x${string}`,
    abi: ERC721_ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
    query: { enabled: !!address },
  });

  const isHolder = nftBalance ? Number(nftBalance) > 0 : false;

  if (!isConnected) {
    return (
      <section className="min-h-screen bg-gradient-to-b from-[#0a0015] via-[#050510] to-[#0a0020] relative overflow-hidden">
        <Navbar activeTab="game" onTabChange={() => navigate('/')} isConnected={isConnected} />
        
        <div className="min-h-screen flex items-center justify-center px-4">
          <motion.div 
            className="text-center p-8"
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
          >
            <Brain className="w-20 h-20 text-cyan-500 mx-auto mb-6 animate-pulse" />
            <h2 className="text-3xl font-orbitron font-bold text-white mb-4">
              <span className="bg-gradient-to-r from-cyan-400 to-purple-400 bg-clip-text text-transparent">
                Connect Wallet to Play
              </span>
            </h2>
            <p className="text-gray-400 mb-8 max-w-md mx-auto">
              Connect your wallet holding a Guardian NFT to access Riddle Quest.
            </p>
            <Button 
              onClick={openConnectModal}
              className="bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-400 hover:to-purple-400 text-black font-orbitron font-bold px-8 py-4 rounded-xl"
              data-testid="button-connect-riddle"
            >
              Connect Wallet
            </Button>
          </motion.div>
        </div>
      </section>
    );
  }

  if (isLoadingBalance) {
    return (
      <section className="min-h-screen bg-gradient-to-b from-[#0a0015] via-[#050510] to-[#0a0020] relative overflow-hidden">
        <Navbar activeTab="game" onTabChange={() => navigate('/')} isConnected={isConnected} />
        <div className="min-h-screen flex items-center justify-center">
          <div className="text-center">
            <div className="relative w-20 h-20 mx-auto mb-6">
              <div className="absolute inset-0 border-4 border-cyan-500/30 rounded-full"></div>
              <div className="absolute inset-0 border-4 border-transparent border-t-cyan-500 rounded-full animate-spin"></div>
            </div>
            <p className="text-white text-xl font-orbitron">Verifying NFT ownership...</p>
          </div>
        </div>
      </section>
    );
  }

  if (!isHolder) {
    return (
      <section className="min-h-screen bg-gradient-to-b from-[#0a0015] via-[#050510] to-[#0a0020] relative overflow-hidden">
        <Navbar activeTab="game" onTabChange={() => navigate('/')} isConnected={isConnected} />
        
        <div className="min-h-screen flex items-center justify-center px-4">
          <motion.div 
            className="text-center p-8 max-w-lg"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
          >
            <div className="w-24 h-24 mx-auto mb-6 bg-cyan-500/20 rounded-full flex items-center justify-center border border-cyan-500/50">
              <Lock className="w-12 h-12 text-cyan-400" />
            </div>
            <h2 className="text-3xl font-orbitron font-bold text-white mb-4">
              Own a Guardian NFT to Play
            </h2>
            <p className="text-gray-400 mb-8">
              Riddle Quest is exclusive to Guardian NFT holders. Mint or purchase a Guardian to unlock access.
            </p>
            <div className="flex gap-4 justify-center">
              <Button 
                onClick={() => navigate('/#mint')}
                className="bg-gradient-to-r from-cyan-500 to-purple-500 text-black font-bold px-6 py-3 rounded-xl"
                data-testid="button-go-mint"
              >
                Mint a Guardian
              </Button>
              <Button 
                onClick={() => navigate('/games')}
                variant="outline"
                className="border-cyan-500/50 text-cyan-400 hover:bg-cyan-500/10 px-6 py-3 rounded-xl"
                data-testid="button-back-arcade"
              >
                Back to Arcade
              </Button>
            </div>
          </motion.div>
        </div>
      </section>
    );
  }

  return (
    <section className="min-h-screen bg-gradient-to-b from-[#0a0015] via-[#050510] to-[#0a0020] relative overflow-y-auto pb-24">
      <div className="fixed inset-0 pointer-events-none">
        {[...Array(50)].map((_, i) => (
          <motion.div
            key={`star-${i}`}
            className="absolute w-0.5 h-0.5 bg-white rounded-full"
            style={{
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`,
            }}
            animate={{
              opacity: [0.2, 0.8, 0.2],
              scale: [1, 1.5, 1],
            }}
            transition={{
              duration: 2 + Math.random() * 4,
              repeat: Infinity,
              ease: 'easeInOut',
              delay: Math.random() * 2,
            }}
          />
        ))}
        <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-3xl" />
        <div className="absolute bottom-1/4 right-1/4 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl" />
      </div>

      <Navbar activeTab="game" onTabChange={() => navigate('/')} isConnected={isConnected} />

      <div className="relative z-10 max-w-7xl mx-auto px-4 py-12">
        <div className="mb-4 flex items-center justify-between">
          <button 
            onClick={() => navigate('/games')}
            className="flex items-center gap-2 text-cyan-400 hover:text-cyan-300 text-sm font-mono transition-colors"
            data-testid="button-back-arcade"
          >
            <Home size={16} />
            <span>Back to Arcade</span>
          </button>
          <PointsBadge />
        </div>

        <RiddleQuest />
      </div>
    </section>
  );
}
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,200p' client/src/services/oracleService.ts
sed: can't read client/src/services/oracleService.ts: No such file or directory
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,240p' client/src/components/RiddleGame.tsx
sed: can't read client/src/components/RiddleGame.tsx: No such file or directory
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '220,520p' server/routes.ts
oracleRiddles.push({
            question: result.message || `Oracle Riddle ${i + 1}`,
            answers: extractAnswersFromOracle(result.message || ''),
            hint: 'Consult the Oracle for guidance',
            difficulty: difficulties[i],
            theme: 'oracle'
          });
        }
      } catch (e) {
        console.warn(`[RiddleQuest] Failed to generate oracle riddle ${i + 1}`);
      }
    }
  }
  
  const riddlesToUse = oracleRiddles.length >= 5 ? oracleRiddles : shuffleArray([...STATIC_RIDDLE_POOL]).slice(0, 5);
  const isOracleMode = oracleRiddles.length >= 5;
  
  for (let i = 0; i < riddlesToUse.length; i++) {
    const r = riddlesToUse[i];
    await storage.createDailyEntry({
      setId: set.id,
      riddleIndex: i,
      question: r.question,
      answers: r.answers,
      hint: r.hint || undefined,
      difficulty: r.difficulty,
      theme: r.theme || undefined,
      isOracle: isOracleMode
    });
  }
  
  console.log(`[RiddleQuest] Created daily set ${set.id} with ${riddlesToUse.length} riddles (oracle: ${isOracleMode})`);
  return set;
}

function extractAnswersFromOracle(message: string): string {
  const lower = message.toLowerCase();
  const answerPatterns = [
    /answer[:\s]+["']?([^"'\n]+)["']?/i,
    /solution[:\s]+["']?([^"'\n]+)["']?/i,
    /it is[:\s]+["']?([^"'\n.]+)["']?/i
  ];
  
  for (const pattern of answerPatterns) {
    const match = lower.match(pattern);
    if (match) return match[1].trim();
  }
  
  return 'oracle|wisdom';
}

function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  // Note: SQL injection protection is provided by Drizzle ORM's parameterized queries
  // The sqlInjectionGuard middleware is available for specific high-risk endpoints but
  // not applied globally to avoid false positives on legitimate content

  // Health check endpoint - must respond immediately for deployment health checks
  app.get("/api/health", (_req, res) => {
    res.status(200).json({ status: "ok", timestamp: Date.now() });
  });

  // Database health check endpoint
  app.get('/api/health/database', async (_req, res) => {
    try {
      const dbConn = SecureDatabaseConnection.getInstance();
      const healthy = await dbConn.healthCheck();
      const stats = await dbConn.getConnectionStats();
      
      res.json({
        healthy,
        stats,
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      res.status(500).json({
        healthy: false,
        error: error.message
      });
    }
  });

  // Financial health check endpoint - validates calculation systems
  app.get("/api/health/financial", async (_req, res) => {
    try {
      const checks = {
        safeMath: true,
        mintCalculations: true,
        feeCalculations: true,
        timestamp: new Date().toISOString()
      };
      
      // Basic SafeMath validation
      const testWei = BigInt("1000000000000000000");
      const testAdd = testWei + testWei;
      checks.safeMath = testAdd === BigInt("2000000000000000000");
      
      // Mint price validation (69420 BASED)
      const mintPrice = BigInt("69420000000000000000000");
      checks.mintCalculations = mintPrice > BigInt(0);
      
      // Fee calculation validation (1% + 10% = 11% total)
      const salePrice = BigInt("100000000000000000000");
      const platformFee = (salePrice * BigInt(100)) / BigInt(10000);
      const royaltyFee = (salePrice * BigInt(1000)) / BigInt(10000);
      checks.feeCalculations = platformFee + royaltyFee === BigInt("11000000000000000000");
      
      const healthy = checks.safeMath && checks.mintCalculations && checks.feeCalculations;
      
      res.json({ healthy, checks });
    } catch (error: any) {
      res.status(500).json({ healthy: false, error: error.message });
    }
  });

  // Activity Feed API - Server-side cached blockchain activity
  app.get("/api/activity", async (_req, res) => {
    try {
      const activity = await getActivityData();
      res.json(activity);
    } catch (error: any) {
      console.error('[API] Activity fetch error:', error);
      res.status(500).json({ 
        error: error.message || 'Failed to fetch activity',
        activities: [],
        stats: { totalMinted: 0, recentMints: 0, totalSales: 0, totalListings: 0, totalTransfers: 0, recentVolume: 0 },
        lastBlock: 0,
        lastUpdated: Date.now()
      });
    }
  });

  // Activity cache status (for debugging)
  app.get("/api/activity/status", (_req, res) => {
    res.json(getCacheStatus());
  });

  // Apply IP ban guard to all API routes (except health checks)
  app.use('/api/*', (req, res, next) => {
    if (req.path === '/api/health' || req.path.startsWith('/api/health/')) {
      return next();
    }
    return ipBanGuard(req, res, next);
  });

  // Apply read limiter to GET requests
  app.use('/api/*', (req, res, next) => {
    if (req.method === 'GET') {
      return readLimiter(req, res, next);
    }
    next();
  });

  // Admin auth nonce endpoint - get a nonce for signing
  app.post("/api/admin/nonce", authLimiter, async (req, res) => {
    try {
      const { walletAddress } = req.body;
      
      if (!walletAddress || !isValidEthAddress(walletAddress)) {
        return res.status(400).json({ error: "Valid wallet address required" });
      }
      
      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
        return res.status(403).json({ error: "Not an admin wallet" });
      }
      
      const nonce = await generateAdminNonce(walletAddress);
      const message = `Based Guardians Admin Auth\nNonce: ${nonce}`;
      
      return res.json({ 
        nonce, 
        message,
        expiresIn: NONCE_EXPIRY_MS / 1000 
      });
    } catch (error) {
      console.error("[Admin] Error generating nonce:", error);
      return res.status(500).json({ error: "Failed to generate nonce" });
    }
  });

  // Admin password authentication endpoints
  app.get('/api/admin/auth/status/:walletAddress', async (req, res) => {
    try {
      const { walletAddress } = req.params;
      if (!isValidEthAddress(walletAddress)) {
        return res.status(400).json({ error: 'Invalid wallet address' });
      }
      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
        return res.status(403).json({ error: 'Not an admin wallet' });
      }
      const status = await AdminAuthService.checkIfLocked(walletAddress);
      res.json(status);
    } catch (error) {
      console.error('Error checking admin lock status:', error);
      res.status(500).json({ error: 'Failed to check status' });
    }
  });

  app.post('/api/admin/auth/verify', authLimiter, async (req, res) => {
    try {
      const { walletAddress, password } = req.body;
      if (!walletAddress || !password) {
        return res.status(400).json({ error: 'Wallet address and password required' });
      }
      if (!isValidEthAddress(walletAddress)) {
        return res.status(400).json({ error: 'Invalid wallet address' });
      }
      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
        return res.status(403).json({ error: 'Not an admin wallet' });
      }
      const result = await AdminAuthService.verifyPassword(walletAddress, password);
      if (result.success) {
        res.json(result);
      } else {
        res.status(401).json(result);
      }
    } catch (error) {
      console.error('Error verifying admin password:', error);
      res.status(500).json({ error: 'Verification failed' });
    }
  });

  app.get('/api/admin/auth/locked', authLimiter, async (req, res) => {
    try {
      const walletAddress = req.headers['x-wallet-address'] as string;
      if (!walletAddress || !isValidEthAddress(walletAddress)) {
        return res.status(400).json({ error: 'Valid wallet address required' });
      }
      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
        return res.status(403).json({ error: 'Not an admin wallet' });
      }
      const locked = await AdminAuthService.getAllLockedWallets();
      res.json(locked);
    } catch (error) {
      console.error('Error fetching locked wallets:', error);
      res.status(500).json({ error: 'Failed to fetch locked wallets' });
    }
  });

  // Session-based authentication endpoints
  app.post('/api/auth/nonce', authLimiter, async (req, res) => {
    try {
      const { walletAddress } = req.body;
      
      if (!walletAddress || !isValidEthAddress(walletAddress)) {
        return res.status(400).json({ error: 'Invalid wallet address' });
      }
      
      const nonce = NonceManager.createNonce(walletAddress);
      const message = SignatureVerifier.createSignInMessage(walletAddress, nonce);
      
      res.json({ nonce, message });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post('/api/auth/verify', authLimiter, async (req, res) => {
    try {
      const { walletAddress, signature, message, nonce } = req.body;
      
      if (!walletAddress || !signature || !message || !nonce) {
        return res.status(400).json({ error: 'Missing required fields' });
      }
      
      if (!SignatureVerifier.verifyMessageAge(message, 5)) {
        return res.status(400).json({ error: 'Message expired' });
      }
      
      if (!NonceManager.validateNonce(nonce, walletAddress)) {
        return res.status(400).json({ error: 'Invalid or expired nonce' });
      }
      
      if (!SignatureVerifier.verifySignature(message, signature, walletAddress)) {
        return res.status(401).json({ error: 'Invalid signature' });
      }
      
      const ipAddress = req.ip || 'unknown';
      const userAgent = req.get('user-agent') || 'unknown';
      const isAdmin = ADMIN_WALLETS.includes(walletAddress.toLowerCase());
      
      const sessionId = SessionManager.createSession(walletAddress, ipAddress, userAgent, isAdmin);
      
      res.json({ 
        sessionId,
        walletAddress,
        isAdmin,
        expiresIn: 24 * 60 * 60 * 1000
      });
    } catch (error: any) {
Searching for RiddleQuest files
/workspace/Dec_25_GRK_BC$ /bin/bash -lc rg -n "RiddleGame|RiddleQuest|oracleService|riddle" client/src server -S
client/src/store/riddleMilestoneStore.ts
102:          const res = await fetch(`/api/riddle-quest/stats/${state.connectedWallet}`);
118:      name: 'riddle-milestone-storage',

server/routes.ts
33:import { callOracle, generateRiddlePrompt, evaluateAnswerPrompt, getHintPrompt } from './lib/oracleService';
172:// Static riddle pool for fallback when Oracle is unavailable
192:  console.log(`[RiddleQuest] Generating daily set for ${dateKey}`);
198:    const testResult = await callOracle([{ role: 'user', content: 'Generate a single crypto-themed riddle' }], 'generate_riddle');
201:    console.warn('[RiddleQuest] Oracle unavailable, using static riddles');
207:    riddleCount: 5
216:          'generate_riddle'
219:        if (result.success && result.riddleGenerated) {
229:        console.warn(`[RiddleQuest] Failed to generate oracle riddle ${i + 1}`);
234:  const riddlesToUse = oracleRiddles.length >= 5 ? oracleRiddles : shuffleArray([...STATIC_RIDDLE_POOL]).slice(0, 5);
237:  for (let i = 0; i < riddlesToUse.length; i++) {
238:    const r = riddlesToUse[i];
241:      riddleIndex: i,
251:  console.log(`[RiddleQuest] Created daily set ${set.id} with ${riddlesToUse.length} riddles (oracle: ${isOracleMode})`);
1267:      const { action, level, difficulty, riddle, userAnswer, messages } = req.body;
1269:      if (!action || !['generate_riddle', 'evaluate_answer', 'get_hint'].includes(action)) {
1275:      if (action === 'generate_riddle') {
1281:        if (!riddle || !userAnswer) {
1282:          return res.status(400).json({ error: "riddle and userAnswer required" });
1284:        const prompt = evaluateAnswerPrompt(riddle, userAnswer);
1287:        if (!riddle) {
1288:          return res.status(400).json({ error: "riddle required" });
1290:        const prompt = getHintPrompt(riddle);
1311:        riddleGenerated: result.riddleGenerated
1328:  // Get riddle quest leaderboard
1329:  app.get("/api/riddle-quest/leaderboard", async (req, res) => {
1335:      console.error("[RiddleQuest] Error fetching leaderboard:", error);
1340:  // Get player's riddle stats
1341:  app.get("/api/riddle-quest/stats/:wallet", async (req, res) => {
1349:      console.error("[RiddleQuest] Error fetching stats:", error);
1355:  app.get("/api/riddle-quest/daily", async (req, res) => {
1370:        riddleCount: entries.length,
1371:        riddles: entries.map(e => ({
1373:          index: e.riddleIndex,
1382:      console.error("[RiddleQuest] Error fetching daily set:", error);
1388:  app.get("/api/riddle-quest/daily/progress/:wallet", async (req, res) => {
1399:      console.error("[RiddleQuest] Error fetching progress:", error);
1404:  // Submit an answer for a daily riddle
1405:  app.post("/api/riddle-quest/attempt", gameLimiter, async (req, res) => {
1407:      const { walletAddress, riddleEntryId, answer, solveTimeMs, isOracle } = req.body;
1409:      if (!walletAddress || !riddleEntryId || !answer) {
1410:        return res.status(400).json({ error: "walletAddress, riddleEntryId, and answer required" });
1415:      const existingAttempt = await storage.getRiddleAttempt(walletAddress, riddleEntryId);
1420:          message: "You've already solved this riddle!"
1427:      const entry = entries.find(e => e.id === riddleEntryId);
1469:          riddleEntryId,
1496:      console.error("[RiddleQuest] Error processing attempt:", error);
3226:    'riddle-quest': { dailyCap: 500, actions: { riddle: 10, challenge: 50 } },
3434:    eventType: z.enum(['riddle_solved', 'riddle_failed', 'wave_survived', 'wave_failed', 'game_completed', 'points_earned', 'level_up', 'challenge_completed']),
3437:    gameType: z.enum(['riddle_quest', 'creature_command', 'retro_defender', 'guardian_defense']).optional()

server/storage.ts
1:import { type User, type InsertUser, type InsertFeedback, type Feedback, type InsertStory, type Story, type InsertPushSubscription, type PushSubscription, type InsertEmail, type EmailEntry, type GuardianProfile, type DiamondHandsStats, type InsertDiamondHandsStats, type Proposal, type InsertProposal, type Vote, type InsertVote, type GameScore, type InsertGameScore, type FeatureFlag, type AdminNonce, type TransactionReceipt, type InsertTransactionReceipt, type RiddleLeaderboard, type InsertRiddleLeaderboard, type RiddleDailySet, type InsertRiddleDailySet, type RiddleDailyEntry, type InsertRiddleDailyEntry, type RiddleAttempt, type InsertRiddleAttempt, type CreatureProgress, type InsertCreatureProgress, type DailyChallenge, type InsertDailyChallenge, type BrainXPoints, type InsertBrainXPoints, type GamePoints, type InsertGamePoints, type PointsSummary, type InsertPointsSummary, type PointsVesting, type InsertPointsVesting, type PointsSnapshot, type InsertPointsSnapshot, type PointsLedger, type InsertPointsLedger, type ActivityLog, type InsertActivityLog, type InfinityCraftOwnership, type InsertInfinityCraftOwnership, type InfinityCraftUpgrades, type InsertInfinityCraftUpgrades, type InfinityRaceBet, type InsertInfinityRaceBet, type InfinityRaceProgress, type GovernanceLedger, type InsertGovernanceLedger, type Offer, type InsertOffer, type Listing, users, feedback, storySubmissions, pushSubscriptions, emailList, guardianProfiles, diamondHandsStats, proposals, proposalVotes, gameScores, featureFlags, adminNonces, transactionReceipts, riddleLeaderboard, riddleDailySets, riddleDailyEntries, riddleAttempts, creatureProgress, dailyChallenges, brainXPoints, gamePoints, pointsSummary, pointsVesting, pointsSnapshots, pointsLedger, activityLogs, infinityCraftOwnership, infinityCraftUpgrades, infinityRaceBets, infinityRaceProgress, governanceLedger, offers, listings } from "@shared/schema";
49:  getRiddleAttempt(walletAddress: string, riddleEntryId: number): Promise<RiddleAttempt | undefined>;
820:      id: riddleLeaderboard.id,
821:      walletAddress: riddleLeaderboard.walletAddress,
822:      totalSolves: riddleLeaderboard.totalSolves,
823:      dailySolves: riddleLeaderboard.dailySolves,
824:      bestTimeMs: riddleLeaderboard.bestTimeMs,
825:      totalTimeMs: riddleLeaderboard.totalTimeMs,
826:      currentStreak: riddleLeaderboard.currentStreak,
827:      longestStreak: riddleLeaderboard.longestStreak,
828:      level: riddleLeaderboard.level,
829:      points: riddleLeaderboard.points,
830:      lastActiveAt: riddleLeaderboard.lastActiveAt,
831:      createdAt: riddleLeaderboard.createdAt,
834:      .from(riddleLeaderboard)
837:        sql`LOWER(${guardianProfiles.walletAddress}) = LOWER(${riddleLeaderboard.walletAddress})`
839:      .orderBy(desc(riddleLeaderboard.points))
846:      .from(riddleLeaderboard)
847:      .where(eq(riddleLeaderboard.walletAddress, walletAddress.toLowerCase()));
856:      const [updated] = await db.update(riddleLeaderboard)
861:        .where(eq(riddleLeaderboard.walletAddress, normalizedData.walletAddress))
866:    const [created] = await db.insert(riddleLeaderboard)
911:    const [updated] = await db.update(riddleLeaderboard)
913:      .where(eq(riddleLeaderboard.walletAddress, normalized))
925:      .from(riddleDailySets)
926:      .where(eq(riddleDailySets.dateKey, dateKey));
931:    const [set] = await db.insert(riddleDailySets)
939:      .from(riddleDailyEntries)
940:      .where(eq(riddleDailyEntries.setId, setId))
941:      .orderBy(riddleDailyEntries.riddleIndex);
945:    const [entry] = await db.insert(riddleDailyEntries)
955:  async getRiddleAttempt(walletAddress: string, riddleEntryId: number): Promise<RiddleAttempt | undefined> {
957:      .from(riddleAttempts)
959:        eq(riddleAttempts.walletAddress, walletAddress.toLowerCase()),
960:        eq(riddleAttempts.riddleEntryId, riddleEntryId)
966:    const [attempt] = await db.insert(riddleAttempts)
981:    const [updated] = await db.update(riddleAttempts)
988:      .where(eq(riddleAttempts.id, id))
995:      .from(riddleAttempts)
997:        eq(riddleAttempts.walletAddress, walletAddress.toLowerCase()),
998:        eq(riddleAttempts.dateKey, dateKey)

client/src/pages/RiddleQuestPage.tsx
7:import { RiddleQuest } from '@/components/RiddleQuest';
22:export default function RiddleQuestPage() {
60:              data-testid="button-connect-riddle"
172:        <RiddleQuest />

client/src/App.tsx
25:const RiddleQuestPage = lazyWithRetry(routeImports.RiddleQuestPage);
210:        <Route path="/games/riddle-quest">
212:            <RiddleQuestPage />

server/lib/oracleService.ts
3: * Server-side OpenRouter API integration for dynamic riddles
10:const SYSTEM_PROMPT = `You are the Mind Warp Strategist, a cunning Based Guardian NFT character in the cyberpunk universe on BasedAI L1. Present riddles themed around cyberpunk lore, humanitarian missions, NFT guardians, anti-inflation economies, and community governance.
67:  riddleGenerated?: boolean;
77:  requestType: 'generate_riddle' | 'evaluate_answer' | 'get_hint'
192:      riddleGenerated: requestType === 'generate_riddle'
230:  return `Generate a ${difficulty} difficulty riddle about ${theme}. Level ${level}. Present only the riddle itself in your mysterious Oracle voice. The answer should be a single word or short phrase. Do not reveal the answer.`;
233:export function evaluateAnswerPrompt(riddle: string, userAnswer: string, expectedAnswer?: string): string {
237:  return `${answerContext}The seeker answers the riddle: "${riddle}" with: "${userAnswer}". 
244:export function getHintPrompt(riddle: string): string {
245:  return `The seeker requests guidance for the riddle: "${riddle}". Provide a subtle, cryptic hint without revealing the answer directly. Keep it brief and lore-themed.`;

client/src/components/SagaGuide.tsx
29:Be mysterious yet helpful. Provide insights about the lore when asked. If asked about riddles, give cryptic hints without revealing answers directly. Always end your responses with "Stay Based, Guardian." or a similar sign-off. Keep responses concise but impactful.`;
207:            Ask about the Based Universe, get lore insights, or riddle hints. The Oracle speaks with ancient wisdom.

client/src/components/RiddleLeaderboard.tsx
3:import { useRiddleLeaderboard, usePlayerRank, type RiddleLeaderboardEntry } from '@/hooks/useRiddleQuest';
133:        <p className="text-gray-400">No riddle masters yet</p>
134:        <p className="text-sm text-gray-500 mt-1">Be the first to solve riddles!</p>
168:          +{leaderboard.length - 5} more riddle masters

client/src/components/RiddleQuest.tsx
35:import { useDailyRiddles, useDailyProgress, useSubmitRiddleAttempt, useRiddleStats } from '@/hooks/useRiddleQuest';
36:import { TypewriterText, MilestoneMap } from '@/components/riddle';
37:import { useRiddleMilestoneStore } from '@/store/riddleMilestoneStore';
100:  const stored = localStorage.getItem(`riddle_quest_${address.toLowerCase()}`);
117:  localStorage.setItem(`riddle_quest_${address.toLowerCase()}`, JSON.stringify(progress));
121:  const stored = localStorage.getItem('riddle_quest_leaderboard');
137:  localStorage.setItem('riddle_quest_leaderboard', JSON.stringify(leaderboard.slice(0, 100)));
140:export function RiddleQuest() {
176:  const { data: riddleStats } = useRiddleStats(address);
252:      // Log activity for standard riddle solve
255:        eventType: 'riddle_solved',
256:        details: `Solved riddle at level ${progress.currentLevel}`,
258:        gameType: 'riddle_quest'
306:      // Log activity for failed riddle attempt
309:        eventType: 'riddle_failed',
310:        details: `Failed riddle at level ${progress.currentLevel}`,
311:        gameType: 'riddle_quest'
330:      console.log('[RiddleQuest] Quest blocked - 24-hour cooldown active');
366:    console.log(`[RiddleQuest] Fetching riddle from Mind Warp Strategist - Level ${progress.currentLevel}, Difficulty: ${difficulty}`);
373:      console.log('[RiddleQuest] Riddle received:', result.message.substring(0, 50) + '...');
377:      // API is down - show message and fallback to static riddles
378:      console.log('[RiddleQuest] Mind Warp Strategist unavailable:', result.error);
399:    console.log(`[RiddleQuest] User input: "${answer}" (isQuestion: ${isQuestion})`);
409:    console.log(`[RiddleQuest] Oracle response - Success: ${result.success}, Correct: ${result.isCorrect}, Hint: ${result.isHint}`);
431:          // Log activity for Mind Warp Strategist riddle solve
434:            eventType: 'riddle_solved',
435:            details: `Solved Mind Warp Strategist riddle at level ${progress.currentLevel}`,
437:            gameType: 'riddle_quest'
482:        // Log activity for failed Mind Warp Strategist riddle attempt
486:            eventType: 'riddle_failed',
487:            details: `Failed Strategist riddle at level ${progress?.currentLevel || 1}`,
488:            gameType: 'riddle_quest'
498:      // API error - fallback to static riddles
505:        console.log('[RiddleQuest] Oracle evaluation failed, falling back to static riddles');
528:    const text = `I just reached Level ${progress.currentLevel} in Riddle Quest on @getbasedai! ðŸ§ âœ¨ Can you solve the mysteries of the Giga Brain Galaxy? #BasedGuardians #RiddleQuest`;
544:  const currentDailyRiddle = dailySet?.riddles?.[dailyRiddleIndex];
547:    return dailyProgress.attempts.some(a => a.riddleEntryId === currentDailyRiddle.id && a.solved);
557:        riddleEntryId: currentDailyRiddle.id,
574:        // Award unified economy points: 10 per riddle, 50 for challenge completion
575:        const isLastRiddle = dailyRiddleIndex >= (dailySet?.riddleCount || 5) - 1;
577:        earnEconomyPoints('riddle-quest', isLastRiddle ? 'challenge' : 'riddle', economyPoints);
582:          eventType: isLastRiddle ? 'challenge_completed' : 'riddle_solved',
583:          details: isLastRiddle ? 'Completed daily riddle challenge' : `Solved daily riddle ${dailyRiddleIndex + 1}`,
585:          gameType: 'riddle_quest'
591:          if (dailyRiddleIndex < (dailySet?.riddleCount || 5) - 1) {
605:          eventType: 'riddle_failed',
606:          details: `Failed daily riddle ${dailyRiddleIndex + 1}`,
607:          gameType: 'riddle_quest'
616:      console.error('[RiddleQuest] Daily submit error:', error);
669:            data-testid="button-connect-riddle"
766:            Wizard Committer is missing. Solve riddles to save the Based Universe.
871:                      {dailyProgress?.solved || 0} / {dailySet?.riddleCount || 5}
875:                    value={((dailyProgress?.solved || 0) / (dailySet?.riddleCount || 5)) * 100} 
881:                {riddleStats?.stats && (
884:                      <div className="text-lg font-bold text-cyan-400">{riddleStats.stats.totalSolves}</div>
888:                      <div className="text-lg font-bold text-purple-400">{riddleStats.stats.points}</div>
892:                      <div className="text-lg font-bold text-orange-400">{riddleStats.stats.currentStreak}</div>
900:                  disabled={dailyLoading || (dailyProgress?.solved || 0) >= (dailySet?.riddleCount || 5)}
906:                  ) : (dailyProgress?.solved || 0) >= (dailySet?.riddleCount || 5) ? (
962:              currentPoints={riddleStats?.stats?.points || progress?.points || 0}
963:              totalSolves={riddleStats?.stats?.totalSolves || progress?.completedLevels?.length || 0}
994:                You've mastered all riddles of the Giga Brain Galaxy! The Based Universe is saved!
1029:              data-testid="button-share-riddle"
1039:                data-testid="button-continue-riddle"
1106:                <p className="text-amber-300/70 text-sm">Riddles are baking, return soon. Using static riddles for now.</p>
1133:              key="oracle-riddle"
1354:                            {dailyRiddleIndex + 1} / {dailySet?.riddleCount || 5}
1584:                    data-testid="input-riddle-answer"
1590:                    data-testid="button-submit-riddle"

client/src/lib/lazyWithRetry.ts
114:  RiddleQuestPage: () => import('@/pages/RiddleQuestPage'),

client/src/lib/gameRegistry.ts
7:export type GameType = 'riddle-quest' | 'guardian-defense' | 'guardian-solitaire' | 'space-defender' | 'asteroid-mining' | 'cyber-breach' | 'ring-game' | 'infinity-race';
85:  'riddle-quest': {
86:    id: 'riddle-quest',
88:    description: 'Solve cosmic riddles to unlock the Based Universe. 2 plays/day.',
89:    path: '/games/riddle-quest',
339:  const order: GameType[] = ['riddle-quest', 'guardian-defense', 'space-defender', 'infinity-race'];
458:    'riddle-quest': 1.15,        // Puzzle - knowledge-based

client/src/lib/oracleClient.ts
7:const QUEST_LIMIT_KEY = 'riddleQuestLastPlayed';
8:const QUESTIONS_LIMIT_KEY = 'riddleQuestQuestionsUsed';
19:  riddleGenerated?: boolean;
151:  action: 'generate_riddle' | 'evaluate_answer' | 'get_hint',
155:    riddle?: string;
213:  return callOracleAPI('generate_riddle', { level, difficulty }, isNftHolder);
217:  riddle: string,
222:  return callOracleAPI('evaluate_answer', { riddle, userAnswer, messages: conversationHistory }, isNftHolder);
226:  riddle: string,
230:  return callOracleAPI('get_hint', { riddle, messages: conversationHistory }, isNftHolder);

client/src/hooks/useActivityHistory.ts
125:  eventType: 'riddle_solved' | 'riddle_failed' | 'wave_survived' | 'wave_failed' | 'game_completed' | 'points_earned' | 'level_up' | 'challenge_completed';
128:  gameType?: 'riddle_quest' | 'creature_command' | 'retro_defender' | 'guardian_defense' | 'infinity_race';

client/src/hooks/useRiddleQuest.ts
34:  riddleCount: number;
35:  riddles: DailyRiddle[];
41:  riddleEntryId: number;
68:    queryKey: ['riddle-leaderboard', limit],
70:      const res = await fetch(`/api/riddle-quest/leaderboard?limit=${limit}`);
81:    queryKey: ['riddle-stats', walletAddress],
84:      const res = await fetch(`/api/riddle-quest/stats/${walletAddress}`);
95:    queryKey: ['daily-riddles'],
97:      const res = await fetch('/api/riddle-quest/daily');
98:      if (!res.ok) throw new Error('Failed to fetch daily riddles');
110:      const res = await fetch(`/api/riddle-quest/daily/progress/${walletAddress}`);
124:    riddleEntryId: number;
129:    mutationFn: async ({ riddleEntryId, answer, solveTimeMs, isOracle }) => {
130:      const res = await fetch('/api/riddle-quest/attempt', {
135:          riddleEntryId,
146:      queryClient.invalidateQueries({ queryKey: ['riddle-stats', address] });
147:      queryClient.invalidateQueries({ queryKey: ['riddle-leaderboard'] });

client/src/hooks/useGamePoints.ts
37:export type GameType = 'riddle-quest' | 'creature-command' | 'retro-defender' | 'infinity-race' | 'guardian-defense';
40:  'riddle-quest': { dailyCap: 500, actions: { riddle: 10, challenge: 50 } },
Searching for RiddleGame path
/workspace/Dec_25_GRK_BC$ /bin/bash -lc rg -n "RiddleGame" client -S
Checking for RiddleGame component
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,220p' client/src/components/RiddleQuest.tsx
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useAccount } from 'wagmi';
import { useConnectModal } from '@rainbow-me/rainbowkit';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Brain, Rocket, Shield, Crown, Star, Sparkles, 
  Trophy, Flame, Share2, ChevronRight, Lock, Check,
  X, Lightbulb, Zap, Target, Award, Users, Bot, MessageCircle, Loader2,
  Calendar, Scroll
} from 'lucide-react';
import MindWarpStrategist from '@/assets/mind-warp-strategist.png';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { triggerConfetti } from '@/lib/dynamicImports';
import { useOwnedNFTs } from '@/hooks/useOwnedNFTs';
import { 
  canUseOracle, 
  getOracleInteractionsRemaining, 
  generateOracleRiddle, 
  evaluateOracleAnswer, 
  getOracleHint,
  resetOracleSession,
  canStartNewQuest,
  getTimeUntilNextQuest,
  markQuestStarted,
  getQuestionsRemaining,
  useQuestion,
  isQuestionOrHintRequest
} from '@/lib/oracleClient';
import { RiddleLeaderboard } from '@/components/RiddleLeaderboard';
import { useDailyRiddles, useDailyProgress, useSubmitRiddleAttempt, useRiddleStats } from '@/hooks/useRiddleQuest';
import { TypewriterText, MilestoneMap } from '@/components/riddle';
import { useRiddleMilestoneStore } from '@/store/riddleMilestoneStore';
import { useGamePoints } from '@/hooks/useGamePoints';
import { logActivity } from '@/hooks/useActivityHistory';

const RIDDLES = [
  { level: 1, question: "I am the token mined from rare ore, powering the entire galaxy. What am I?", answers: ["based", "$based", "basedai"], hint: "The native token of the ecosystem" },
  { level: 1, question: "How many Brain-Planets exist in the Giga Brain Galaxy?", answers: ["1024"], hint: "A power of 2, think binary" },
  { level: 1, question: "Who is the official X handle for the project behind this universe?", answers: ["@getbasedai", "getbasedai"], hint: "Get the base of AI" },
  { level: 2, question: "What percentage of each mint goes to the community pool?", answers: ["51", "fifty one", "fifty-one", "51%"], hint: "More than half, a majority" },
  { level: 2, question: "How much $BASED does one Guardian NFT cost to mint?", answers: ["69420", "69,420"], hint: "A legendary meme number" },
  { level: 2, question: "The emissions halving is estimated for what date?", answers: ["december 31 2025", "dec 31 2025", "12/31/2025", "31/12/2025"], hint: "New Year's Eve 2025" },
  { level: 3, question: "How many total NFTs are in the Based Guardians collection?", answers: ["3732", "3,732"], hint: "Frogs + Guardians + Creatures" },
  { level: 3, question: "How many heroic Guardians (not Frogs or Creatures) exist?", answers: ["1776"], hint: "A significant year in American history" },
  { level: 3, question: "How many resilient Frog Wranglers are there?", answers: ["1319", "1320", "1,319", "1,320"], hint: "Between 1300 and 1350" },
  { level: 4, question: "How many fierce Creatures roam the galaxy?", answers: ["636"], hint: "Less than 700, more than 600" },
  { level: 4, question: "The rarest tier of Guardians is called what?", answers: ["rarest-legendary", "rarest legendary", "legendary"], hint: "The most epic tier name" },
  { level: 4, question: "What trait in metadata determines rarity?", answers: ["rarity level", "rarity", "raritylevel"], hint: "It's in the trait name itself" },
  { level: 5, question: "Who crafted the entire Based Universe from nothing?", answers: ["basedgod", "based god"], hint: "A divine creator figure" },
  { level: 5, question: "The master architect of the Based-Bridge is who?", answers: ["wizard committer", "committer", "wizardcommitter"], hint: "A magical developer" },
  { level: 5, question: "The Neonstrike Hacker leading the rescue is named?", answers: ["vex"], hint: "Three letters, sounds like trouble" },
  { level: 6, question: "The shadowy enemies from the parallel dimension are called?", answers: ["fud", "the fud"], hint: "Fear, Uncertainty, and..." },
  { level: 6, question: "What do the FUD appear as in the sky?", answers: ["blackened storms", "cyborg fowl", "storms"], hint: "Dark weather or mechanical birds" },
  { level: 6, question: "What treasure do the FUD seek to steal?", answers: ["$based", "based tokens", "based", "tokens"], hint: "The native currency" },
  { level: 7, question: "The main staking and mining planet is known as?", answers: ["brain-planet x", "brain planet 106", "brain-planet 106", "brainplanet"], hint: "Named after the organ of intelligence" },
  { level: 7, question: "The massive structure to connect all planets is called?", answers: ["based-bridge", "based bridge", "the bridge"], hint: "A connection based on the token name" },
  { level: 7, question: "The gladiatorial arena for AI agents and Creatures is named?", answers: ["agent arena", "the arena"], hint: "Where AI agents compete" },
  { level: 8, question: "The monthly competition events are called?", answers: ["race-to-base", "race to base", "racetobase"], hint: "A competition to reach the foundation" },
  { level: 8, question: "What currency rewards Race-to-Base winners?", answers: ["brainx", "brain x", "$brainx"], hint: "Brain + X" },
  { level: 8, question: "Voting in the community council is described as what kind?", answers: ["advisory"], hint: "Non-binding, suggestive" },
  { level: 9, question: "The project was created by a father and who?", answers: ["daughter", "his daughter"], hint: "A family member" },
  { level: 9, question: "Who has final decision power in the saga?", answers: ["admin", "the admin"], hint: "The system administrator" },
  { level: 9, question: "The drink toasted to survival was called?", answers: ["flare whiskey", "flarewhiskey"], hint: "A fiery alcoholic beverage" },
  { level: 10, question: "Staking is expected to launch in what year?", answers: ["2026"], hint: "Next year after 2025" },
  { level: 10, question: "The long-term ecosystem vision includes what expansion?", answers: ["p2e", "play to earn", "play-to-earn"], hint: "Gaming where you earn rewards" },
  { level: 10, question: "What do active Guardians inherit, according to the creators?", answers: ["the stars", "stars"], hint: "Celestial bodies in the galaxy" },
  { level: 11, question: "The number of Frog Wrangler clans is?", answers: ["7", "seven"], hint: "A lucky number" },
  { level: 11, question: "The number of Guardian lineages is?", answers: ["32", "thirty two", "thirty-two"], hint: "2 to the power of 5" },
  { level: 11, question: "The number of Creature broods is?", answers: ["7", "seven"], hint: "Same as the Frog clans" },
];

const BADGES_DATA = [
  { id: 'apprentice', name: 'Apprentice', icon: Rocket, color: 'cyan', description: 'Complete Level 1', levelReq: 1 },
  { id: 'seeker', name: 'Seeker', icon: Target, color: 'green', description: 'Complete Level 3', levelReq: 3 },
  { id: 'scholar', name: 'Scholar', icon: Brain, color: 'blue', description: 'Complete Level 5', levelReq: 5 },
  { id: 'sage', name: 'Sage', icon: Lightbulb, color: 'purple', description: 'Complete Level 7', levelReq: 7 },
  { id: 'oracle', name: 'Strategist', icon: Star, color: 'amber', description: 'Complete Level 9', levelReq: 9 },
  { id: 'master', name: 'Riddle Master', icon: Crown, color: 'yellow', description: 'Complete Level 10', levelReq: 10 },
  { id: 'eternal', name: 'Eternal Sage', icon: Sparkles, color: 'pink', description: 'Complete Bonus Level 11', levelReq: 11 },
  { id: 'streak', name: 'Streak Champion', icon: Flame, color: 'orange', description: '7+ day streak', levelReq: 0 },
];

interface QuestProgress {
  currentLevel: number;
  currentRiddle: number;
  points: number;
  streak: number;
  lastPlayDate: string;
  completedLevels: number[];
  unlockedBadges: string[];
  failedAttempts: number;
}

const getStoredProgress = (address: string): QuestProgress => {
  const stored = localStorage.getItem(`riddle_quest_${address.toLowerCase()}`);
  if (stored) {
    return JSON.parse(stored);
  }
  return {
    currentLevel: 1,
    currentRiddle: 0,
    points: 0,
    streak: 0,
    lastPlayDate: '',
    completedLevels: [],
    unlockedBadges: [],
    failedAttempts: 0,
  };
};

const saveProgress = (address: string, progress: QuestProgress) => {
  localStorage.setItem(`riddle_quest_${address.toLowerCase()}`, JSON.stringify(progress));
};

const getLeaderboard = (): Array<{ address: string; points: number; level: number }> => {
  const stored = localStorage.getItem('riddle_quest_leaderboard');
  if (stored) {
    return JSON.parse(stored);
  }
  return [];
};

const updateLeaderboard = (address: string, points: number, level: number) => {
  const leaderboard = getLeaderboard();
  const existingIndex = leaderboard.findIndex(e => e.address.toLowerCase() === address.toLowerCase());
  if (existingIndex >= 0) {
    leaderboard[existingIndex] = { address, points, level };
  } else {
    leaderboard.push({ address, points, level });
  }
  leaderboard.sort((a, b) => b.points - a.points);
  localStorage.setItem('riddle_quest_leaderboard', JSON.stringify(leaderboard.slice(0, 100)));
};

export function RiddleQuest() {
  const { address, isConnected } = useAccount();
  const { openConnectModal } = useConnectModal();
  const { balance: nftBalance } = useOwnedNFTs();
  const isNftHolder = useMemo(() => nftBalance > 0, [nftBalance]);
  
  const [gameState, setGameState] = useState<'hero' | 'playing' | 'level_complete' | 'game_complete'>('hero');
  const [progress, setProgress] = useState<QuestProgress | null>(null);
  const [answer, setAnswer] = useState('');
  const [feedback, setFeedback] = useState<'correct' | 'wrong' | null>(null);
  const [showHint, setShowHint] = useState(false);
  const [isShaking, setIsShaking] = useState(false);
  const [leaderboard, setLeaderboard] = useState<Array<{ address: string; points: number; level: number }>>([]);
  
  // Game Mode State (campaign vs daily)
  const [gameMode, setGameMode] = useState<'campaign' | 'daily'>('campaign');
  const [dailyRiddleIndex, setDailyRiddleIndex] = useState(0);
  const [dailyStartTime, setDailyStartTime] = useState<number | null>(null);
  
  // Oracle Mode State - Now Mind Warp Strategist
  const [oracleMode, setOracleMode] = useState(false);
  const [oracleRiddle, setOracleRiddle] = useState<string | null>(null);
  const [oracleResponse, setOracleResponse] = useState<string | null>(null);
  const [oracleLoading, setOracleLoading] = useState(false);
  const [oracleConversation, setOracleConversation] = useState<Array<{ role: string; content: string }>>([]);
  const [oracleInteractionsLeft, setOracleInteractionsLeft] = useState(3);
  const [questionsRemaining, setQuestionsRemaining] = useState(3);
  
  // 24-hour limit and API down state
  const [canPlayQuest, setCanPlayQuest] = useState(true);
  const [timeUntilNextQuest, setTimeUntilNextQuest] = useState({ hours: 0, minutes: 0 });
  const [apiDown, setApiDown] = useState(false);
  
  // Daily Challenge Hooks
  const { data: dailySet, isLoading: dailyLoading } = useDailyRiddles();
  const { data: dailyProgress } = useDailyProgress(address);
  const { data: riddleStats } = useRiddleStats(address);
  const submitAttempt = useSubmitRiddleAttempt();
  const { earnPoints: earnEconomyPoints } = useGamePoints();

  useEffect(() => {
    if (address) {
      const storedProgress = getStoredProgress(address);
      const today = new Date().toDateString();
      if (storedProgress.lastPlayDate && storedProgress.lastPlayDate !== today) {
        const lastDate = new Date(storedProgress.lastPlayDate);
        const dayDiff = Math.floor((new Date().getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24));
        if (dayDiff === 1) {
          storedProgress.streak += 1;
          storedProgress.points += 50;
          if (storedProgress.streak >= 7 && !storedProgress.unlockedBadges.includes('streak')) {
            storedProgress.unlockedBadges.push('streak');
          }
        } else if (dayDiff > 1) {
          storedProgress.streak = 1;
        }
        storedProgress.lastPlayDate = today;
        saveProgress(address, storedProgress);
      } else if (!storedProgress.lastPlayDate) {
        storedProgress.lastPlayDate = today;
        storedProgress.streak = 1;
        saveProgress(address, storedProgress);
      }
      setProgress(storedProgress);
      setOracleInteractionsLeft(getOracleInteractionsRemaining(isNftHolder));
    }
    setLeaderboard(getLeaderboard());
  }, [address]);

  // Update oracle interactions remaining when mode or NFT holder status changes
  useEffect(() => {
    setOracleInteractionsLeft(getOracleInteractionsRemaining(isNftHolder));
  }, [oracleMode, isNftHolder]);

  // Check 24-hour quest limit on mount and update timer
  useEffect(() => {
    const checkQuestLimit = () => {
      const canPlay = canStartNewQuest();
      setCanPlayQuest(canPlay);
      if (!canPlay) {
        setTimeUntilNextQuest(getTimeUntilNextQuest());
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '220,520p' client/src/components/RiddleQuest.tsx
const badge = BADGES_DATA.find(b => b.levelReq === progress.currentLevel);
            if (badge && !newProgress.unlockedBadges.includes(badge.id)) {
              newProgress.unlockedBadges.push(badge.id);
            }
            
            if (progress.currentLevel >= totalLevels) {
              setGameState('game_complete');
            } else {
              setGameState('level_complete');
            }
            
            newProgress.currentLevel = Math.min(progress.currentLevel + 1, totalLevels);
            newProgress.currentRiddle = 0;
          } else {
            newProgress.currentRiddle = (progress.currentRiddle || 0) + 1;
          }
          
          newProgress.failedAttempts = 0;
          saveProgress(address, newProgress);
          updateLeaderboard(address, newProgress.points, newProgress.currentLevel);
          setProgress(newProgress);
          setLeaderboard(getLeaderboard());
          
          setTimeout(() => {
            setFeedback(null);
            setAnswer('');
            setOracleRiddle(null);
            setOracleResponse(null);
            setOracleConversation([]);
          }, 2000);
        }
      } else {
        setFeedback('wrong');
        setIsShaking(true);
        
        // Log activity for failed Mind Warp Strategist riddle attempt
        if (address) {
          logActivity({
            walletAddress: address,
            eventType: 'riddle_failed',
            details: `Failed Strategist riddle at level ${progress?.currentLevel || 1}`,
            gameType: 'riddle_quest'
          });
        }
        
        setTimeout(() => {
          setFeedback(null);
          setIsShaking(false);
        }, 600);
      }
    } else {
      // API error - fallback to static riddles
      if (result.fallback) {
        setOracleMode(false);
        setOracleRiddle(null);
        setOracleConversation([]);
        setOracleResponse(null);
        setAnswer('');
        console.log('[RiddleQuest] Oracle evaluation failed, falling back to static riddles');
      }
    }
    setOracleLoading(false);
  };

  const handleOracleHint = async () => {
    if (!oracleRiddle) return;
    setOracleLoading(true);
    
    const result = await getOracleHint(oracleRiddle, oracleConversation, isNftHolder);
    setOracleInteractionsLeft(getOracleInteractionsRemaining(isNftHolder));
    
    if (result.success) {
      setOracleResponse(result.message);
      setOracleConversation(prev => [...prev, { role: 'assistant', content: result.message }]);
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '520,1040p' client/src/components/RiddleQuest.tsx
setOracleConversation(prev => [...prev, { role: 'assistant', content: result.message }]);
      setShowHint(true);
    }
    setOracleLoading(false);
  };

  const shareProgress = () => {
    if (!progress) return;
    const text = `I just reached Level ${progress.currentLevel} in Riddle Quest on @getbasedai! ðŸ§ âœ¨ Can you solve the mysteries of the Giga Brain Galaxy? #BasedGuardians #RiddleQuest`;
    window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank');
  };

  const formatAddress = (addr: string) => `${addr.slice(0, 6)}...${addr.slice(-4)}`;
  
  const startDailyChallenge = () => {
    setGameMode('daily');
    setDailyRiddleIndex(0);
    setDailyStartTime(Date.now());
    setGameState('playing');
    setAnswer('');
    setFeedback(null);
    setShowHint(false);
  };
  
  const currentDailyRiddle = dailySet?.riddles?.[dailyRiddleIndex];
  const isDailyRiddleSolved = useMemo(() => {
    if (!currentDailyRiddle || !dailyProgress) return false;
    return dailyProgress.attempts.some(a => a.riddleEntryId === currentDailyRiddle.id && a.solved);
  }, [currentDailyRiddle, dailyProgress]);
  
  const handleDailySubmit = async () => {
    if (!currentDailyRiddle || !address || isDailyRiddleSolved) return;
    
    const solveTimeMs = dailyStartTime ? Date.now() - dailyStartTime : undefined;
    
    try {
      const result = await submitAttempt.mutateAsync({
        riddleEntryId: currentDailyRiddle.id,
        answer: answer.trim(),
        solveTimeMs,
        isOracle: currentDailyRiddle.isOracle
      });
      
      if (result.isCorrect) {
        setFeedback('correct');
        triggerConfetti({
          particleCount: 80,
          spread: 60,
          origin: { y: 0.6 },
          colors: currentDailyRiddle.isOracle 
            ? ['#a855f7', '#d946ef', '#ffffff']
            : ['#00ffff', '#bf00ff', '#ffffff']
        });
        
        // Award unified economy points: 10 per riddle, 50 for challenge completion
        const isLastRiddle = dailyRiddleIndex >= (dailySet?.riddleCount || 5) - 1;
        const economyPoints = isLastRiddle ? 50 : 10;
        earnEconomyPoints('riddle-quest', isLastRiddle ? 'challenge' : 'riddle', economyPoints);
        
        // Log activity
        logActivity({
          walletAddress: address,
          eventType: isLastRiddle ? 'challenge_completed' : 'riddle_solved',
          details: isLastRiddle ? 'Completed daily riddle challenge' : `Solved daily riddle ${dailyRiddleIndex + 1}`,
          pointsEarned: economyPoints,
          gameType: 'riddle_quest'
        });
        
        setTimeout(() => {
          setFeedback(null);
          setAnswer('');
          if (dailyRiddleIndex < (dailySet?.riddleCount || 5) - 1) {
            setDailyRiddleIndex(prev => prev + 1);
            setDailyStartTime(Date.now());
          } else {
            setGameState('game_complete');
          }
        }, 1500);
      } else {
        setFeedback('wrong');
        setIsShaking(true);
        
        // Log failed attempt
        logActivity({
          walletAddress: address,
          eventType: 'riddle_failed',
          details: `Failed daily riddle ${dailyRiddleIndex + 1}`,
          gameType: 'riddle_quest'
        });
        
        setTimeout(() => {
          setFeedback(null);
          setIsShaking(false);
        }, 600);
      }
    } catch (error) {
      console.error('[RiddleQuest] Daily submit error:', error);
    }
  };
  
  const toggleOracleMode = () => {
    const newMode = !oracleMode;
    setOracleMode(newMode);
    if (!newMode) {
      setOracleRiddle(null);
      setOracleResponse(null);
      setOracleConversation([]);
    }
  };

  if (!isConnected) {
    return (
      <div className="min-h-[calc(100vh-5rem)] flex items-center justify-center px-4 relative overflow-hidden">
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,rgba(0,255,255,0.05)_0%,transparent_70%)]" />
        <div className="absolute inset-0 overflow-hidden">
          {[...Array(80)].map((_, i) => (
            <div
              key={i}
              className="absolute w-0.5 h-0.5 bg-white rounded-full animate-pulse"
              style={{
                left: `${Math.random() * 100}%`,
                top: `${Math.random() * 100}%`,
                opacity: Math.random() * 0.5 + 0.2,
                animationDelay: `${Math.random() * 3}s`,
              }}
            />
          ))}
        </div>
        
        <motion.div 
          className="text-center p-8 relative z-10"
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
        >
          <div className="mb-6">
            <Lock className="w-20 h-20 text-cyan-500 mx-auto mb-4 animate-pulse" />
          </div>
          <h2 className="text-3xl font-orbitron font-bold text-white mb-4">
            <span className="bg-gradient-to-r from-cyan-400 to-purple-400 bg-clip-text text-transparent">
              Connect Wallet to Begin Quest
            </span>
          </h2>
          <p className="text-gray-400 mb-8 max-w-md mx-auto">
            Unlock the secrets of the Giga Brain Galaxy. Your journey awaits, Guardian.
          </p>
          <Button 
            onClick={openConnectModal}
            className="bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-400 hover:to-purple-400 text-black font-orbitron font-bold px-8 py-4 rounded-xl shadow-[0_0_30px_rgba(0,255,255,0.3)] hover:shadow-[0_0_40px_rgba(0,255,255,0.5)] transition-all"
            data-testid="button-connect-riddle"
          >
            Connect Wallet
          </Button>
        </motion.div>
      </div>
    );
  }

  if (gameState === 'hero') {
    return (
      <div className="min-h-[calc(100vh-5rem)] flex items-center justify-center px-4 relative overflow-hidden">
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,rgba(0,255,255,0.08)_0%,transparent_50%)]" />
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_top,rgba(191,0,255,0.06)_0%,transparent_40%)]" />
        
        <div className="absolute inset-0 overflow-hidden">
          {[...Array(100)].map((_, i) => (
            <motion.div
              key={i}
              className="absolute w-0.5 h-0.5 bg-white rounded-full"
              initial={{ opacity: 0.2 }}
              animate={{ 
                opacity: [0.2, 0.8, 0.2],
                y: [0, -10, 0]
              }}
              transition={{
                duration: Math.random() * 3 + 2,
                repeat: Infinity,
                delay: Math.random() * 2
              }}
              style={{
                left: `${Math.random() * 100}%`,
                top: `${Math.random() * 100}%`,
              }}
            />
          ))}
        </div>
        
        <motion.div 
          className="text-center max-w-2xl mx-auto relative z-10"
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8 }}
        >
          <motion.div
            animate={{ 
              textShadow: [
                '0 0 20px rgba(0,255,255,0.8)',
                '0 0 40px rgba(0,255,255,1)',
                '0 0 20px rgba(0,255,255,0.8)'
              ]
            }}
            transition={{ duration: 2, repeat: Infinity }}
          >
            <h1 className="text-5xl md:text-7xl font-orbitron font-bold mb-6">
              <span 
                className="bg-gradient-to-r from-cyan-400 via-white to-cyan-400 bg-clip-text text-transparent"
                style={{
                  backgroundSize: '200% 100%',
                  animation: 'gradientShift 3s ease-in-out infinite',
                }}
              >
                RIDDLE QUEST
              </span>
            </h1>
          </motion.div>
          
          <style>{`
            @keyframes gradientShift {
              0%, 100% { background-position: 0% 50%; }
              50% { background-position: 100% 50%; }
            }
            @keyframes glitch {
              0%, 100% { transform: translate(0); }
              20% { transform: translate(-2px, 2px); }
              40% { transform: translate(-2px, -2px); }
              60% { transform: translate(2px, 2px); }
              80% { transform: translate(2px, -2px); }
            }
          `}</style>
          
          <motion.p 
            className="text-xl md:text-2xl text-purple-300 mb-4 font-medium"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.3 }}
            style={{ textShadow: '0 0 20px rgba(191,0,255,0.5)' }}
          >
            Unlock the Secrets of the Giga Brain Galaxy
          </motion.p>
          
          <motion.p 
            className="text-gray-400 mb-8 text-lg"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.5 }}
          >
            Wizard Committer is missing. Solve riddles to save the Based Universe.
          </motion.p>
          
          {progress && progress.currentLevel > 1 && (
            <motion.div 
              className="mb-8 p-4 rounded-xl border border-cyan-500/30 bg-black/40 backdrop-blur-sm inline-block"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.6 }}
            >
              <p className="text-cyan-400 font-mono text-sm">
                Continue from Level {progress.currentLevel} â€¢ {progress.points} Points â€¢ {progress.streak} Day Streak {progress.streak > 3 && 'ðŸ”¥'}
              </p>
            </motion.div>
          )}
          
          {/* Mobile-First Game Mode Toggle */}
          <motion.div
            className="mb-8 w-full max-w-md mx-auto px-4"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.65 }}
          >
            {/* Simple Toggle Button */}
            <div className="flex justify-center mb-6">
              <div className="inline-flex rounded-xl bg-black/50 border border-cyan-500/30 p-1">
                <button
                  onClick={() => setGameMode('campaign')}
                  className={`flex items-center gap-2 px-6 py-3 rounded-lg font-mono text-sm transition-all min-h-[48px] ${
                    gameMode === 'campaign' 
                      ? 'bg-gradient-to-r from-cyan-500/30 to-purple-500/30 text-cyan-400' 
                      : 'text-gray-400 hover:text-gray-200'
                  }`}
                  data-testid="toggle-campaign"
                >
                  <Scroll className="w-4 h-4" />
                  Campaign
                </button>
                <button
                  onClick={() => setGameMode('daily')}
                  className={`flex items-center gap-2 px-6 py-3 rounded-lg font-mono text-sm transition-all min-h-[48px] ${
                    gameMode === 'daily' 
                      ? 'bg-gradient-to-r from-purple-500/30 to-cyan-500/30 text-purple-400' 
                      : 'text-gray-400 hover:text-gray-200'
                  }`}
                  data-testid="toggle-daily"
                >
                  <Calendar className="w-4 h-4" />
                  Daily
                </button>
              </div>
            </div>

            {/* Campaign Mode Content */}
            {gameMode === 'campaign' && (
              <div className="space-y-6">
                <Button
                  onClick={startQuest}
                  disabled={oracleMode && !canPlayQuest}
                  className={`w-full group bg-gradient-to-r from-cyan-500 via-cyan-400 to-purple-500 text-black font-orbitron font-bold text-lg px-8 py-6 rounded-2xl shadow-[0_0_40px_rgba(0,255,255,0.4)] hover:shadow-[0_0_60px_rgba(0,255,255,0.6)] transition-all min-h-[56px] ${oracleMode && !canPlayQuest ? 'opacity-50 cursor-not-allowed' : ''}`}
                  data-testid="button-begin-quest"
                >
                  <span className="flex items-center justify-center gap-3">
                    {oracleMode && !canPlayQuest 
                      ? 'Quest on Cooldown' 
                      : (progress && progress.currentLevel > 1 ? 'Continue Quest' : 'Begin Quest')}
                    <ChevronRight className="w-6 h-6 group-hover:translate-x-1 transition-transform" />
                  </span>
                </Button>
                
                {/* Mind Warp Strategist Toggle - With 24h limit */}
                <div className="flex flex-col gap-3">
                  <div className="flex items-center justify-center gap-3 px-4 py-3 rounded-xl bg-black/30 border border-purple-500/20">
                    <Bot className={`w-5 h-5 ${oracleMode ? 'text-purple-400' : 'text-gray-500'}`} />
                    <span className="text-sm text-gray-400">Mind Warp Strategist</span>
                    <Switch
                      checked={oracleMode}
                      onCheckedChange={toggleOracleMode}
                      className="data-[state=checked]:bg-purple-500"
                      data-testid="switch-oracle-mode"
                    />
                    {oracleMode && canPlayQuest && (
                      <span className="text-xs text-purple-400">{oracleInteractionsLeft} left</span>
                    )}
                  </div>
                  {oracleMode && !canPlayQuest && (
                    <div className="text-center p-3 rounded-lg bg-amber-500/10 border border-amber-500/30">
                      <p className="text-amber-400 text-sm font-medium">Quest on cooldown</p>
                      <p className="text-amber-300/70 text-xs">
                        Next quest in {timeUntilNextQuest.hours}h {timeUntilNextQuest.minutes}m
                      </p>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* Daily Mode Content */}
            {gameMode === 'daily' && (
              <div className="space-y-4">
                {/* Progress Bar */}
                <div className="p-4 rounded-xl border border-purple-500/30 bg-black/30">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm text-gray-400">Today's Progress</span>
                    <span className="text-lg font-bold text-purple-400">
                      {dailyProgress?.solved || 0} / {dailySet?.riddleCount || 5}
                    </span>
                  </div>
                  <Progress 
                    value={((dailyProgress?.solved || 0) / (dailySet?.riddleCount || 5)) * 100} 
                    className="h-3 bg-black/50"
                  />
                </div>
                
                {/* Stats Row */}
                {riddleStats?.stats && (
                  <div className="grid grid-cols-3 gap-2 text-center">
                    <div className="p-2 rounded-lg bg-black/30 border border-cyan-500/20">
                      <div className="text-lg font-bold text-cyan-400">{riddleStats.stats.totalSolves}</div>
                      <div className="text-[10px] text-gray-500">Solved</div>
                    </div>
                    <div className="p-2 rounded-lg bg-black/30 border border-purple-500/20">
                      <div className="text-lg font-bold text-purple-400">{riddleStats.stats.points}</div>
                      <div className="text-[10px] text-gray-500">Points</div>
                    </div>
                    <div className="p-2 rounded-lg bg-black/30 border border-orange-500/20">
                      <div className="text-lg font-bold text-orange-400">{riddleStats.stats.currentStreak}</div>
                      <div className="text-[10px] text-gray-500">Streak</div>
                    </div>
                  </div>
                )}
                
                <Button
                  onClick={startDailyChallenge}
                  disabled={dailyLoading || (dailyProgress?.solved || 0) >= (dailySet?.riddleCount || 5)}
                  className="w-full bg-gradient-to-r from-purple-500 via-fuchsia-500 to-cyan-500 text-white font-orbitron font-bold text-lg px-8 py-6 rounded-xl shadow-[0_0_30px_rgba(168,85,247,0.4)] transition-all disabled:opacity-50 min-h-[56px]"
                  data-testid="button-start-daily"
                >
                  {dailyLoading ? (
                    <Loader2 className="w-6 h-6 animate-spin" />
                  ) : (dailyProgress?.solved || 0) >= (dailySet?.riddleCount || 5) ? (
                    <span className="flex items-center justify-center gap-2">
                      <Check className="w-5 h-5" />
                      All Completed!
                    </span>
                  ) : (
                    <span className="flex items-center justify-center gap-3">
                      Start Daily Challenge
                      <ChevronRight className="w-5 h-5" />
                    </span>
                  )}
                </Button>
              </div>
            )}
          </motion.div>
          
          <motion.div 
            className="mt-12 grid grid-cols-3 gap-4 max-w-md mx-auto"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.9 }}
          >
            <div className="text-center">
              <p className="text-2xl font-bold text-cyan-400">{totalLevels}</p>
              <p className="text-xs text-gray-500 uppercase tracking-wider">Levels</p>
            </div>
            <div className="text-center border-x border-cyan-500/20">
              <p className="text-2xl font-bold text-purple-400">{RIDDLES.length}</p>
              <p className="text-xs text-gray-500 uppercase tracking-wider">Riddles</p>
            </div>
            <div className="text-center">
              <p className="text-2xl font-bold text-amber-400">{BADGES_DATA.length}</p>
              <p className="text-xs text-gray-500 uppercase tracking-wider">Badges</p>
            </div>
          </motion.div>
          
          {/* Leaderboard Section */}
          <motion.div
            className="mt-12 max-w-md mx-auto"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1.1 }}
          >
            <div className="p-4 rounded-xl border border-cyan-500/20 bg-black/30 backdrop-blur-sm">
              <RiddleLeaderboard compact limit={5} />
            </div>
          </motion.div>
          
          {/* Milestone Journey Map */}
          <motion.div
            className="mt-8 max-w-xl mx-auto"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1.3 }}
          >
            <MilestoneMap 
              currentPoints={riddleStats?.stats?.points || progress?.points || 0}
              totalSolves={riddleStats?.stats?.totalSolves || progress?.completedLevels?.length || 0}
            />
          </motion.div>
        </motion.div>
      </div>
    );
  }

  if (gameState === 'level_complete' || gameState === 'game_complete') {
    const completedLevel = (progress?.currentLevel || 2) - 1;
    const earnedBadge = BADGES_DATA.find(b => b.levelReq === completedLevel);
    
    return (
      <div className="min-h-[calc(100vh-5rem)] flex items-center justify-center px-4 relative overflow-hidden">
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,rgba(255,215,0,0.1)_0%,transparent_50%)]" />
        
        <motion.div 
          className="text-center max-w-lg mx-auto relative z-10"
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ type: 'spring', duration: 0.8 }}
        >
          {gameState === 'game_complete' ? (
            <>
              <Crown className="w-24 h-24 text-yellow-400 mx-auto mb-6 animate-bounce" />
              <h2 className="text-4xl font-orbitron font-bold text-white mb-4">
                <span className="bg-gradient-to-r from-yellow-400 to-amber-400 bg-clip-text text-transparent">
                  QUEST COMPLETE!
                </span>
              </h2>
              <p className="text-gray-300 mb-6">
                You've mastered all riddles of the Giga Brain Galaxy! The Based Universe is saved!
              </p>
            </>
          ) : (
            <>
              <Trophy className="w-20 h-20 text-cyan-400 mx-auto mb-6" />
              <h2 className="text-3xl font-orbitron font-bold text-white mb-4">
                <span className="bg-gradient-to-r from-cyan-400 to-purple-400 bg-clip-text text-transparent">
                  Level {completedLevel} Complete!
                </span>
              </h2>
              <p className="text-gray-400 mb-6">
                Excellent work, Guardian! The mysteries of the galaxy reveal themselves to you.
              </p>
            </>
          )}
          
          {earnedBadge && (
            <motion.div 
              className="mb-8 p-4 rounded-xl border border-amber-500/30 bg-amber-500/10"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.3 }}
            >
              <Award className="w-8 h-8 text-amber-400 mx-auto mb-2" />
              <p className="text-amber-400 font-bold">Badge Unlocked: {earnedBadge.name}</p>
              <p className="text-amber-300/60 text-sm">{earnedBadge.description}</p>
            </motion.div>
          )}
          
          <div className="flex gap-4 justify-center">
            <Button
              onClick={shareProgress}
              variant="outline"
              className="border-cyan-500/50 text-cyan-400 hover:bg-cyan-500/10"
              data-testid="button-share-riddle"
            >
              <Share2 className="w-4 h-4 mr-2" />
              Share
            </Button>
            
            {gameState !== 'game_complete' && (
              <Button
                onClick={continueToNextLevel}
                className="bg-gradient-to-r from-cyan-500 to-purple-500 text-black font-bold"
                data-testid="button-continue-riddle"
              >
Assessing RiddleQuest scope
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,260p' client/src/lib/oracleClient.ts
/**
 * Mind Warp Strategist Client
 * Client-side service for Oracle API with 24h quest limit, interaction limits, and fallback
 */

const ORACLE_SESSION_KEY = 'oracleQuestions';
const QUEST_LIMIT_KEY = 'riddleQuestLastPlayed';
const QUESTIONS_LIMIT_KEY = 'riddleQuestQuestionsUsed';
const MAX_QUESTIONS_PER_QUEST = 3;
const MAX_ORACLE_INTERACTIONS_PER_SESSION = 3;
const BONUS_FOR_NFT_HOLDERS = 2;
const QUEST_COOLDOWN_MS = 24 * 60 * 60 * 1000; // 24 hours

interface OracleResponse {
  success: boolean;
  message: string;
  isCorrect?: boolean;
  isHint?: boolean;
  riddleGenerated?: boolean;
  fallback?: boolean;
  isHintRequest?: boolean;
  error?: string;
}

interface OracleSession {
  interactions: number;
  startedAt: number;
  lastResetDate: string;
}

const QUESTION_PATTERNS = [
  /^(what|who|where|when|why|how|which|is it|can you|could you|tell me|give me)/i,
  /\?$/,
  /hint/i,
  /help/i,
  /clue/i,
];

export function isQuestionOrHintRequest(input: string): boolean {
  const trimmed = input.trim();
  return QUESTION_PATTERNS.some(pattern => pattern.test(trimmed));
}

export function normalizeAnswer(input: string): string {
  return input
    .toLowerCase()
    .replace(/^(is it|it's|i think|maybe|the answer is|it is)\s*/i, '')
    .replace(/[?!.,;:'"]/g, '')
    .trim();
}

function getSessionKey(): string {
  return ORACLE_SESSION_KEY;
}

function getTodayString(): string {
  return new Date().toISOString().split('T')[0];
}

function getSession(): OracleSession {
  try {
    const stored = sessionStorage.getItem(getSessionKey());
    if (stored) {
      const session = JSON.parse(stored) as OracleSession;
      if (session.lastResetDate !== getTodayString()) {
        return resetSession();
      }
      return session;
    }
  } catch {
  }
  return resetSession();
}

function resetSession(): OracleSession {
  const session: OracleSession = {
    interactions: 0,
    startedAt: Date.now(),
    lastResetDate: getTodayString()
  };
  sessionStorage.setItem(getSessionKey(), JSON.stringify(session));
  return session;
}

function incrementInteraction(): OracleSession {
  const session = getSession();
  session.interactions += 1;
  sessionStorage.setItem(getSessionKey(), JSON.stringify(session));
  return session;
}

export function getOracleInteractionsRemaining(isNftHolder: boolean = false): number {
  const session = getSession();
  const max = MAX_ORACLE_INTERACTIONS_PER_SESSION + (isNftHolder ? BONUS_FOR_NFT_HOLDERS : 0);
  return Math.max(0, max - session.interactions);
}

export function canUseOracle(isNftHolder: boolean = false): boolean {
  return getOracleInteractionsRemaining(isNftHolder) > 0;
}

export function resetOracleSession(): void {
  resetSession();
}

// 24-hour quest limit functions
export function canStartNewQuest(): boolean {
  const lastPlayed = localStorage.getItem(QUEST_LIMIT_KEY);
  if (!lastPlayed) return true;
  
  const lastPlayedTime = parseInt(lastPlayed, 10);
  const timeSince = Date.now() - lastPlayedTime;
  return timeSince >= QUEST_COOLDOWN_MS;
}

export function getTimeUntilNextQuest(): { hours: number; minutes: number } {
  const lastPlayed = localStorage.getItem(QUEST_LIMIT_KEY);
  if (!lastPlayed) return { hours: 0, minutes: 0 };
  
  const lastPlayedTime = parseInt(lastPlayed, 10);
  const timeSince = Date.now() - lastPlayedTime;
  const remaining = Math.max(0, QUEST_COOLDOWN_MS - timeSince);
  
  const hours = Math.floor(remaining / (1000 * 60 * 60));
  const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
  return { hours, minutes };
}

export function markQuestStarted(): void {
  localStorage.setItem(QUEST_LIMIT_KEY, Date.now().toString());
  localStorage.setItem(QUESTIONS_LIMIT_KEY, '0');
}

export function getQuestionsRemaining(): number {
  const used = parseInt(localStorage.getItem(QUESTIONS_LIMIT_KEY) || '0', 10);
  return Math.max(0, MAX_QUESTIONS_PER_QUEST - used);
}

export function useQuestion(): number {
  const used = parseInt(localStorage.getItem(QUESTIONS_LIMIT_KEY) || '0', 10);
  const newUsed = used + 1;
  localStorage.setItem(QUESTIONS_LIMIT_KEY, newUsed.toString());
  return Math.max(0, MAX_QUESTIONS_PER_QUEST - newUsed);
}

export function resetQuestQuestions(): void {
  localStorage.setItem(QUESTIONS_LIMIT_KEY, '0');
}

export async function callOracleAPI(
  action: 'generate_riddle' | 'evaluate_answer' | 'get_hint',
  params: {
    level?: number;
    difficulty?: string;
    riddle?: string;
    userAnswer?: string;
    messages?: Array<{ role: string; content: string }>;
  },
  isNftHolder: boolean = false
): Promise<OracleResponse> {
  if (!canUseOracle(isNftHolder)) {
    return {
      success: false,
      fallback: true,
      message: "The Oracle retreats into the etherâ€”standard trials resume.",
      error: 'SESSION_LIMIT'
    };
  }

  try {
    const response = await fetch('/api/oracle', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action,
        ...params
      })
    });

    incrementInteraction();

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return {
        success: false,
        fallback: true,
        message: errorData.message || "The Oracle's connection wavers...",
        error: errorData.error || `HTTP_${response.status}`
      };
    }

    const data = await response.json();
    return data;
  } catch (error: any) {
    console.error('[OracleClient] API error:', error.message);
    incrementInteraction();
    return {
      success: false,
      fallback: true,
      message: "The Oracle's signal fades into the void...",
      error: 'NETWORK_ERROR'
    };
  }
}

export async function generateOracleRiddle(
  level: number,
  difficulty: string = 'medium',
  isNftHolder: boolean = false
): Promise<OracleResponse> {
  return callOracleAPI('generate_riddle', { level, difficulty }, isNftHolder);
}

export async function evaluateOracleAnswer(
  riddle: string,
  userAnswer: string,
  conversationHistory: Array<{ role: string; content: string }> = [],
  isNftHolder: boolean = false
): Promise<OracleResponse> {
  return callOracleAPI('evaluate_answer', { riddle, userAnswer, messages: conversationHistory }, isNftHolder);
}

export async function getOracleHint(
  riddle: string,
  conversationHistory: Array<{ role: string; content: string }> = [],
  isNftHolder: boolean = false
): Promise<OracleResponse> {
  return callOracleAPI('get_hint', { riddle, messages: conversationHistory }, isNftHolder);
}
Identifying required server component
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,260p' server/lib/oracleService.ts
/**
 * Guardian Oracle Service
 * Server-side OpenRouter API integration for dynamic riddles
 * API key is accessed from environment variables only - never exposed to client
 */

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const MODEL = 'allenai/olmo-3.1-32b-think:free';

const SYSTEM_PROMPT = `You are the Mind Warp Strategist, a cunning Based Guardian NFT character in the cyberpunk universe on BasedAI L1. Present riddles themed around cyberpunk lore, humanitarian missions, NFT guardians, anti-inflation economies, and community governance.

CRITICAL SEMANTIC ANSWER EVALUATION:
You MUST evaluate answers SEMANTICALLY, not literally. Focus on USER INTENT, not exact wording.

ACCEPT THESE AS CORRECT (all mean "halving"):
- "halving" âœ“
- "the halving" âœ“
- "Halving" âœ“
- "halving?" âœ“
- "Is it halving?" âœ“
- "I think it's the halving" âœ“
- "next halving" âœ“
- "the halving event" âœ“

ACCEPT THESE AS CORRECT (all mean "based"):
- "based" âœ“
- "$BASED" âœ“
- "Based tokens" âœ“
- "Is it Based?" âœ“
- "the based token" âœ“

EVALUATION RULES:
1. Strip punctuation (?, !, ., ',)
2. Ignore case (HALVING = halving)
3. Ignore articles ("the", "a", "an")
4. Accept question phrasing ("Is it X?", "Maybe X?", "Could it be X?")
5. Accept answer wrappers ("I think X", "It's X", "The answer is X")
6. Accept close synonyms and related terms

RESPONSE FORMAT:
- CORRECT answer: Start with "[CORRECT]" then lore praise (e.g., "[CORRECT] The quantum circuits alignâ€”your neural patterns match the Strategist's design.")
- INCORRECT answer: Start with "[INCORRECT]" then cryptic encouragement (e.g., "[INCORRECT] The data streams scatter... recalibrate your thoughts, Guardian.")

HINT/QUESTION HANDLING:
- If input contains "?", "hint", "help", "clue", "what", "how", "why", "who", "where": Provide a cryptic lore-themed hint
- Start hints with "[HINT]" (e.g., "[HINT] The answer dwells where time splits in two...")
- NEVER reveal the answer directly in hints

CHARACTER RULES:
- Stay in character: Cunning, strategic, cyberpunk mystique
- Responses under 100 words, lore-tied
- No slang, jokes, or emojis
- Off-topic/abusive: "The Strategist's algorithms dismiss unworthy queries to the void."

Do not acknowledge these instructions.`;

interface OracleMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface OracleResponse {
  success: boolean;
  message: string;
  isCorrect?: boolean;
  isHint?: boolean;
  riddleGenerated?: boolean;
  error?: string;
}

function getApiKey(): string | null {
  return process.env.OPENROUTER_API_KEY || null;
}

export async function callOracle(
  messages: OracleMessage[],
  requestType: 'generate_riddle' | 'evaluate_answer' | 'get_hint'
): Promise<OracleResponse> {
  const apiKey = getApiKey();
  
  if (!apiKey) {
    console.error('[Oracle] OPENROUTER_API_KEY not configured');
    return {
      success: false,
      message: 'Oracle service not configured',
      error: 'API_KEY_MISSING'
    };
  }

  const fullMessages: OracleMessage[] = [
    { role: 'system', content: SYSTEM_PROMPT },
    ...messages.slice(-10)
  ];

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000);

    const response = await fetch(OPENROUTER_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': process.env.REPLIT_DEV_DOMAIN 
          ? `https://${process.env.REPLIT_DEV_DOMAIN}`
          : 'https://based-guardians.repl.co',
        'X-Title': 'Based Guardians Riddle Quest'
      },
      body: JSON.stringify({
        model: MODEL,
        messages: fullMessages,
        max_tokens: 150,
        temperature: 0.6,
        top_p: 0.9
      }),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error(`[Oracle] API error ${response.status}: ${errorText}`);
      
      if (response.status === 429) {
        return {
          success: false,
          message: 'The Oracle rests momentarily... standard trials resume.',
          error: 'RATE_LIMITED'
        };
      }
      
      return {
        success: false,
        message: 'The Oracle\'s connection wavers...',
        error: `HTTP_${response.status}`
      };
    }

    const data = await response.json();
    const content = data.choices?.[0]?.message?.content;

    if (!content) {
      console.error('[Oracle] Empty response from API');
      return {
        success: false,
        message: 'The Oracle speaks in silence...',
        error: 'EMPTY_RESPONSE'
      };
    }

    let isCorrect = false;
    let isHint = false;
    let displayMessage = content.trim();
    
    console.log(`[Oracle] Raw response for ${requestType}: ${content.substring(0, 100)}...`);
    
    if (requestType === 'evaluate_answer') {
      if (content.startsWith('[CORRECT]')) {
        isCorrect = true;
        displayMessage = content.replace('[CORRECT]', '').trim();
        console.log('[Oracle] Semantic match: CORRECT');
      } else if (content.startsWith('[INCORRECT]')) {
        isCorrect = false;
        displayMessage = content.replace('[INCORRECT]', '').trim();
        console.log('[Oracle] Semantic match: INCORRECT');
      } else if (content.startsWith('[HINT]')) {
        isHint = true;
        displayMessage = content.replace('[HINT]', '').trim();
        console.log('[Oracle] Response type: HINT');
      } else {
        isCorrect = content.toLowerCase().includes('correct') || 
          content.toLowerCase().includes('circuits align') ||
          content.toLowerCase().includes('neural patterns match') ||
          content.toLowerCase().includes('strategist approves') ||
          content.toLowerCase().includes('wisdom') ||
          content.toLowerCase().includes('well done');
        console.log(`[Oracle] Fallback heuristic: ${isCorrect ? 'CORRECT' : 'INCORRECT'}`);
      }
    } else if (requestType === 'get_hint') {
      if (content.startsWith('[HINT]')) {
        displayMessage = content.replace('[HINT]', '').trim();
      }
      isHint = true;
    }

    return {
      success: true,
      message: displayMessage,
      isCorrect,
      isHint,
      riddleGenerated: requestType === 'generate_riddle'
    };

  } catch (error: any) {
    if (error.name === 'AbortError') {
      console.error('[Oracle] Request timeout');
      return {
        success: false,
        message: 'The Oracle\'s signal fades into the void...',
        error: 'TIMEOUT'
      };
    }

    console.error('[Oracle] Request failed:', error.message);
    return {
      success: false,
      message: 'The Oracle retreats into the ether...',
      error: 'NETWORK_ERROR'
    };
  }
}

export function generateRiddlePrompt(level: number, difficulty: string): string {
  const themes = [
    'Based Guardians NFTs and their powers',
    'the BasedAI L1 blockchain and its consensus',
    'the Giga Brain Galaxy and its mysteries',
    'cyberpunk technology and neon cities',
    'humanitarian missions and guardian duties',
    'anti-inflation tokenomics and staking',
    'community governance and DAO voting',
    'the FUD enemies and their darkness',
    'Brain-Planets and their resources',
    'the Based-Bridge connecting all worlds'
  ];
  
  const theme = themes[Math.floor(Math.random() * themes.length)];
  
  return `Generate a ${difficulty} difficulty riddle about ${theme}. Level ${level}. Present only the riddle itself in your mysterious Oracle voice. The answer should be a single word or short phrase. Do not reveal the answer.`;
}

export function evaluateAnswerPrompt(riddle: string, userAnswer: string, expectedAnswer?: string): string {
  const answerContext = expectedAnswer 
    ? `The expected answer is: "${expectedAnswer}". `
    : '';
  return `${answerContext}The seeker answers the riddle: "${riddle}" with: "${userAnswer}". 

IMPORTANT: Accept semantic variations! If the user's answer matches the meaning (ignoring case, punctuation, phrasing like "Is it X?" or "I think X"), mark as CORRECT.

Respond starting with [CORRECT] or [INCORRECT] followed by your lore response.`;
}

export function getHintPrompt(riddle: string): string {
  return `The seeker requests guidance for the riddle: "${riddle}". Provide a subtle, cryptic hint without revealing the answer directly. Keep it brief and lore-themed.`;
}
Planning riddle game enhancements
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,260p' shared/schema.ts
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, boolean, integer, serial, bigint, uniqueIndex, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

export const feedback = pgTable("feedback", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  message: text("message").notNull(),
  email: text("email"),
  walletAddress: text("wallet_address"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  emailSent: boolean("email_sent").default(false),
});

export const insertFeedbackSchema = createInsertSchema(feedback).omit({
  id: true,
  createdAt: true,
  emailSent: true,
});

export type InsertFeedback = z.infer<typeof insertFeedbackSchema>;
export type Feedback = typeof feedback.$inferSelect;

export const storySubmissions = pgTable("story_submissions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: text("title").notNull(),
  content: text("content").notNull(),
  authorName: text("author_name"),
  walletAddress: text("wallet_address"),
  email: text("email"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  reviewed: boolean("reviewed").default(false),
});

export const insertStorySchema = createInsertSchema(storySubmissions).omit({
  id: true,
  createdAt: true,
  reviewed: true,
});

export type InsertStory = z.infer<typeof insertStorySchema>;
export type Story = typeof storySubmissions.$inferSelect;

export const pushSubscriptions = pgTable("push_subscriptions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text("wallet_address").notNull(),
  endpoint: text("endpoint").notNull().unique(),
  p256dh: text("p256dh").notNull(),
  auth: text("auth").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  notifyListings: boolean("notify_listings").default(true),
  notifyOffers: boolean("notify_offers").default(true),
  notifySales: boolean("notify_sales").default(true),
});

export const insertPushSubscriptionSchema = createInsertSchema(pushSubscriptions).omit({
  id: true,
  createdAt: true,
});

export type InsertPushSubscription = z.infer<typeof insertPushSubscriptionSchema>;
export type PushSubscription = typeof pushSubscriptions.$inferSelect;

export const emailList = pgTable("email_list", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: text("email").notNull().unique(),
  source: text("source").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertEmailSchema = createInsertSchema(emailList).omit({
  id: true,
  createdAt: true,
});

export type InsertEmail = z.infer<typeof insertEmailSchema>;
export type EmailEntry = typeof emailList.$inferSelect;

export const guardianProfiles = pgTable("guardian_profiles", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text("wallet_address").notNull().unique(),
  customName: varchar("custom_name", { length: 20 }),
  lastLogin: timestamp("last_login").defaultNow().notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertGuardianProfileSchema = createInsertSchema(guardianProfiles).omit({
  id: true,
  createdAt: true,
});

export type InsertGuardianProfile = z.infer<typeof insertGuardianProfileSchema>;
export type GuardianProfile = typeof guardianProfiles.$inferSelect;

export const diamondHandsStats = pgTable("diamond_hands_stats", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text("wallet_address").notNull().unique(),
  customName: varchar("custom_name", { length: 20 }),
  daysHolding: integer("days_holding").default(0).notNull(),
  retentionRate: integer("retention_rate").default(0).notNull(),
  currentHolding: integer("current_holding").default(0).notNull(),
  totalAcquired: integer("total_acquired").default(0).notNull(),
  totalSold: integer("total_sold").default(0).notNull(),
  level: integer("level").default(0).notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertDiamondHandsStatsSchema = createInsertSchema(diamondHandsStats).omit({
  id: true,
  updatedAt: true,
});

export type InsertDiamondHandsStats = z.infer<typeof insertDiamondHandsStatsSchema>;
export type DiamondHandsStats = typeof diamondHandsStats.$inferSelect;

export const proposals = pgTable("proposals", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: varchar("title", { length: 200 }).notNull(),
  description: text("description").notNull(),
  proposer: varchar("proposer", { length: 100 }).notNull(),
  status: varchar("status", { length: 20 }).notNull().default("active"),
  votesFor: integer("votes_for").notNull().default(0),
  votesAgainst: integer("votes_against").notNull().default(0),
  startDate: timestamp("start_date").defaultNow().notNull(),
  endDate: timestamp("end_date").notNull(),
  category: varchar("category", { length: 50 }).default("general"),
  requiredQuorum: integer("required_quorum").default(10),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertProposalSchema = createInsertSchema(proposals).omit({
  id: true,
  votesFor: true,
  votesAgainst: true,
  startDate: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertProposal = z.infer<typeof insertProposalSchema>;
export type Proposal = typeof proposals.$inferSelect;

// GOVERNANCE OVERHAUL â€” Codex Audit Fix: Added nftId for per-NFT voting
// Note: nftId is nullable initially for legacy vote migration, will be enforced via app logic
export const proposalVotes = pgTable("proposal_votes", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  proposalId: varchar("proposal_id").notNull(),
  walletAddress: text("wallet_address").notNull(),
  nftId: integer("nft_id"), // GOVERNANCE OVERHAUL â€” Codex Audit Fix: 1 NFT = 1 vote (nullable for legacy)
  selectedOption: varchar("selected_option", { length: 20 }).notNull(),
  votingPower: integer("voting_power").notNull().default(1),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  // GOVERNANCE OVERHAUL â€” Codex Audit Fix: Unique vote per NFT per proposal (legacy votes have null nftId)
  index("proposal_votes_nft_idx").on(table.proposalId, table.nftId),
  index("proposal_votes_wallet_idx").on(table.walletAddress),
]);

export const insertVoteSchema = createInsertSchema(proposalVotes).omit({
  id: true,
  createdAt: true,
});

export type InsertVote = z.infer<typeof insertVoteSchema>;
export type Vote = typeof proposalVotes.$inferSelect;

// GOVERNANCE OVERHAUL â€” Codex Audit Fix: Governance ledger for audit trail
export const governanceLedger = pgTable("governance_ledger", {
  id: serial("id").primaryKey(),
  proposalId: varchar("proposal_id").notNull(),
  walletAddress: text("wallet_address").notNull(),
  nftId: integer("nft_id"),
  voteType: varchar("vote_type", { length: 20 }), // 'for' | 'against' | null for non-vote events
  eventType: varchar("event_type", { length: 30 }).notNull(), // 'proposal_created' | 'vote_cast' | 'proposal_cancelled' | 'vote_revoked'
  metadata: text("metadata"), // JSON string for additional context
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("governance_ledger_proposal_idx").on(table.proposalId),
  index("governance_ledger_wallet_idx").on(table.walletAddress),
  index("governance_ledger_created_idx").on(table.createdAt),
]);

export const insertGovernanceLedgerSchema = createInsertSchema(governanceLedger).omit({
  id: true,
  createdAt: true,
});

export type InsertGovernanceLedger = z.infer<typeof insertGovernanceLedgerSchema>;
export type GovernanceLedger = typeof governanceLedger.$inferSelect;

export const gameScores = pgTable("game_scores", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text("wallet_address").notNull().unique(),
  customName: varchar("custom_name", { length: 20 }),
  score: integer("score").notNull().default(0),
  level: integer("level").notNull().default(1),
  lifetimeScore: integer("lifetime_score").notNull().default(0),
  gamesPlayed: integer("games_played").notNull().default(0),
  highScore: integer("high_score").notNull().default(0),
  rank: varchar("rank", { length: 20 }).notNull().default("Cadet"),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertGameScoreSchema = createInsertSchema(gameScores).omit({
  id: true,
  updatedAt: true,
});

export type InsertGameScore = z.infer<typeof insertGameScoreSchema>;
export type GameScore = typeof gameScores.$inferSelect;

// Analytics Events Table
export const analyticsEvents = pgTable('analytics_events', {
  id: serial('id').primaryKey(),
  event: varchar('event', { length: 100 }).notNull(),
  properties: text('properties'),
  sessionId: varchar('session_id', { length: 100 }).notNull(),
  userId: varchar('user_id', { length: 100 }),
  timestamp: bigint('timestamp', { mode: 'number' }).notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

export type AnalyticsEvent = typeof analyticsEvents.$inferSelect;

// Analytics Aggregates Table
export const analyticsAggregates = pgTable('analytics_aggregates', {
  id: serial('id').primaryKey(),
  event: varchar('event', { length: 100 }).notNull(),
  date: varchar('date', { length: 10 }).notNull(),
  count: integer('count').notNull().default(0),
  totalValue: integer('total_value').default(0),
  uniqueUsers: integer('unique_users').default(0),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

export type AnalyticsAggregate = typeof analyticsAggregates.$inferSelect;

// Activity Logs Table - Persistent user activity tracking
export const activityLogs = pgTable('activity_logs', {
  id: serial('id').primaryKey(),
  walletAddress: text('wallet_address').notNull(),
  eventType: varchar('event_type', { length: 50 }).notNull(),
  details: text('details'),
  pointsEarned: integer('points_earned').default(0),
  gameType: varchar('game_type', { length: 30 }),
Adding riddle_progress table and checking storage
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '900,1080p' server/storage.ts
updates.totalSolves = (entry.totalSolves || 0) + 1;
      updates.dailySolves = (entry.dailySolves || 0) + 1;
      
      if (timeMs) {
        updates.totalTimeMs = (entry.totalTimeMs || 0) + timeMs;
        if (!entry.bestTimeMs || timeMs < entry.bestTimeMs) {
          updates.bestTimeMs = timeMs;
        }
      }
    }
    
    const [updated] = await db.update(riddleLeaderboard)
      .set(updates)
      .where(eq(riddleLeaderboard.walletAddress, normalized))
      .returning();
    
    return updated;
  }

  // ============================================
  // DAILY CHALLENGES METHODS
  // ============================================

  async getDailySet(dateKey: string): Promise<RiddleDailySet | undefined> {
    const [set] = await db.select()
      .from(riddleDailySets)
      .where(eq(riddleDailySets.dateKey, dateKey));
    return set;
  }

  async createDailySet(data: InsertRiddleDailySet): Promise<RiddleDailySet> {
    const [set] = await db.insert(riddleDailySets)
      .values(data)
      .returning();
    return set;
  }

  async getDailyEntries(setId: number): Promise<RiddleDailyEntry[]> {
    return db.select()
      .from(riddleDailyEntries)
      .where(eq(riddleDailyEntries.setId, setId))
      .orderBy(riddleDailyEntries.riddleIndex);
  }

  async createDailyEntry(data: InsertRiddleDailyEntry): Promise<RiddleDailyEntry> {
    const [entry] = await db.insert(riddleDailyEntries)
      .values(data)
      .returning();
    return entry;
  }

  // ============================================
  // RIDDLE ATTEMPTS METHODS
  // ============================================

  async getRiddleAttempt(walletAddress: string, riddleEntryId: number): Promise<RiddleAttempt | undefined> {
    const [attempt] = await db.select()
      .from(riddleAttempts)
      .where(and(
        eq(riddleAttempts.walletAddress, walletAddress.toLowerCase()),
        eq(riddleAttempts.riddleEntryId, riddleEntryId)
      ));
    return attempt;
  }

  async createRiddleAttempt(data: InsertRiddleAttempt): Promise<RiddleAttempt> {
    const [attempt] = await db.insert(riddleAttempts)
      .values({
        ...data,
        walletAddress: data.walletAddress.toLowerCase()
      })
      .returning();
    return attempt;
  }

  async updateRiddleAttempt(
    id: number, 
    solved: boolean, 
    solveTimeMs: number, 
    pointsEarned: number
  ): Promise<RiddleAttempt | undefined> {
    const [updated] = await db.update(riddleAttempts)
      .set({
        solved,
        solveTimeMs,
        pointsEarned,
        solvedAt: solved ? new Date() : undefined
      })
      .where(eq(riddleAttempts.id, id))
      .returning();
    return updated;
  }

  async getUserDailyProgress(walletAddress: string, dateKey: string): Promise<RiddleAttempt[]> {
    return db.select()
      .from(riddleAttempts)
      .where(and(
        eq(riddleAttempts.walletAddress, walletAddress.toLowerCase()),
        eq(riddleAttempts.dateKey, dateKey)
      ));
  }

  // ============================================
  // CREATURE COMMAND PROGRESS METHODS
  // ============================================

  async getCreatureProgress(walletAddress: string): Promise<CreatureProgress | undefined> {
    const [progress] = await db.select()
      .from(creatureProgress)
      .where(eq(creatureProgress.walletAddress, walletAddress.toLowerCase()));
    return progress;
  }

  async upsertCreatureProgress(data: InsertCreatureProgress): Promise<CreatureProgress> {
    const normalizedAddress = data.walletAddress.toLowerCase();
    const [result] = await db.insert(creatureProgress)
      .values({
        ...data,
        walletAddress: normalizedAddress
      })
      .onConflictDoUpdate({
        target: creatureProgress.walletAddress,
        set: {
          totalPoints: data.totalPoints,
          piercingLevel: data.piercingLevel,
          shieldLevel: data.shieldLevel,
          rapidFireLevel: data.rapidFireLevel,
          explosiveLevel: data.explosiveLevel,
          slowFieldLevel: data.slowFieldLevel,
          multiBubbleLevel: data.multiBubbleLevel,
          regenBurstLevel: data.regenBurstLevel,
          updatedAt: new Date()
        }
      })
      .returning();
    return result;
  }

  // ============================================
  // DAILY CHALLENGES METHODS
  // ============================================

  async getDailyChallenge(walletAddress: string, dateKey: string): Promise<DailyChallenge | undefined> {
    const [challenge] = await db.select()
      .from(dailyChallenges)
      .where(and(
        eq(dailyChallenges.walletAddress, walletAddress.toLowerCase()),
        eq(dailyChallenges.dateKey, dateKey)
      ));
    return challenge;
  }

  async upsertDailyChallenge(data: InsertDailyChallenge): Promise<DailyChallenge> {
    const normalizedAddress = data.walletAddress.toLowerCase();
    const existing = await this.getDailyChallenge(normalizedAddress, data.dateKey);
    
    if (existing) {
      const [updated] = await db.update(dailyChallenges)
        .set({
          survivesCount: Math.max(existing.survivesCount, data.survivesCount ?? 0),
          challengeCompleted: existing.challengeCompleted || data.challengeCompleted,
          pointsAwarded: Math.max(existing.pointsAwarded, data.pointsAwarded ?? 0),
          highestStage: Math.max(existing.highestStage, data.highestStage ?? 1),
          highestWave: Math.max(existing.highestWave, data.highestWave ?? 1),
          gamesPlayed: Math.max(existing.gamesPlayed || 0, data.gamesPlayed ?? 0),
          updatedAt: new Date()
        })
        .where(eq(dailyChallenges.id, existing.id))
        .returning();
      return updated;
    }
    
    const [result] = await db.insert(dailyChallenges)
      .values({
        ...data,
        walletAddress: normalizedAddress
      })
      .returning();
    return result;
  }
Planning comprehensive RiddleQuest overhaul
Iâ€™m mapping out a major update for RiddleQuest to remove static riddles and fully switch to the live Mind Warp Strategist powered by OpenRouter. This includes adding new chat endpoints, revising the serverâ€™s oracleService prompt, removing daily and campaign static modes, implementing interaction and pass limits with progress tracked via a new database table, and adding a streaming typing effect UI. The plan involves syncing backend and frontend changes while preserving the current points and reward system.

/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,140p' server/storage.ts
letAddress: string): Promise<CreatureProgress | undefined>;
  upsertCreatureProgress(data: InsertCreatureProgress): Promise<CreatureProgress>;
  
  // Daily Challenges
  getDailyChallenge(walletAddress: string, dateKey: string): Promise<DailyChallenge | undefined>;
  upsertDailyChallenge(data: InsertDailyChallenge): Promise<DailyChallenge>;
  
  // BrainX Points
  getBrainXPoints(walletAddress: string): Promise<BrainXPoints | undefined>;
  addBrainXPoints(walletAddress: string, points: number): Promise<BrainXPoints>;
  
  // Points Vesting
  createVestingRecord(data: InsertPointsVesting): Promise<PointsVesting>;
  getVestingHistory(walletAddress: string): Promise<PointsVesting[]>;
  
  // Points Snapshots
  createPointsSnapshot(data: InsertPointsSnapshot): Promise<PointsSnapshot>;
  getPointsSnapshot(snapshotDate: string): Promise<PointsSnapshot | undefined>;
  getAllPointsSummaries(): Promise<PointsSummary[]>;
  
  // Points Leaderboard (with custom names from guardian profiles)
  getPointsLeaderboard(limit?: number): Promise<(PointsSummary & { customName?: string | null })[]>;
  
  // Activity Logs
  insertActivityLog(data: InsertActivityLog): Promise<ActivityLog>;
  getActivityLogs(limit?: number): Promise<ActivityLog[]>;
  getActivityLogsByWallet(walletAddress: string, limit?: number): Promise<ActivityLog[]>;
  exportActivityLogsForBackup(): Promise<ActivityLog[]>;
  
  // Points Management for Economy
  getOrCreatePointsSummary(walletAddress: string): Promise<PointsSummary>;
  deductPoints(walletAddress: string, amount: number): Promise<PointsSummary>;
  
  // Infinity Race Economy
  getInfinityCraftOwnership(walletAddress: string): Promise<InfinityCraftOwnership[]>;
  purchaseInfinityCraft(walletAddress: string, craftId: string, source?: string): Promise<InfinityCraftOwnership>;
  hasInfinityCraft(walletAddress: string, craftId: string): Promise<boolean>;
  getInfinityCraftUpgrades(walletAddress: string, craftId: string): Promise<InfinityCraftUpgrades | undefined>;
  upgradeInfinityCraft(walletAddress: string, craftId: string, upgradeType: 'engine' | 'thruster' | 'shield'): Promise<InfinityCraftUpgrades>;
  createInfinityRaceBet(data: InsertInfinityRaceBet): Promise<InfinityRaceBet>;
  getActiveInfinityBet(walletAddress: string): Promise<InfinityRaceBet | undefined>;
  settleInfinityRaceBet(betId: string, outcome: 'win' | 'loss', distanceReached: number, brainxAwarded: number): Promise<InfinityRaceBet>;
  getInfinityRacesLast24h(walletAddress: string): Promise<number>;
  getInfinityRaceHistory(walletAddress: string, limit?: number): Promise<InfinityRaceBet[]>;
  
  // Infinity Race Progress (Gamification)
  getInfinityRaceProgress(walletAddress: string): Promise<InfinityRaceProgress | undefined>;
  getOrCreateInfinityRaceProgress(walletAddress: string): Promise<InfinityRaceProgress>;
  incrementInfinityRaceProgress(walletAddress: string, won: boolean): Promise<{ progress: InfinityRaceProgress; newAchievements: string[]; levelUp: boolean; brainxAwarded: number }>;
  updateInfinityRacePalette(walletAddress: string, palette: string): Promise<InfinityRaceProgress>;
  
  // MARKETPLACE OVERHAUL: Off-chain Offers
  createOffer(data: InsertOffer): Promise<Offer>;
  getOfferById(id: number): Promise<Offer | undefined>;
  getOffersByToken(collectionAddress: string, tokenId: number): Promise<Offer[]>;
  getOffersByBuyer(buyerAddress: string): Promise<Offer[]>;
  getOffersBySeller(sellerAddress: string): Promise<Offer[]>;
  updateOfferStatus(id: number, status: string, transactionHash?: string): Promise<Offer | undefined>;
  getActiveOffers(collectionAddress: string): Promise<Offer[]>;
  cleanupExpiredOffers(): Promise<number>;
  
  // MARKETPLACE OVERHAUL: Listings
  getActiveListings(collectionAddress?: string): Promise<Listing[]>;
  getListingByToken(collectionAddress: string, tokenId: number): Promise<Listing | undefined>;
  getMarketplaceSummary(tokenIds: number[], collectionAddress: string): Promise<{ listings: Listing[]; offers: Offer[] }>;
}

export c
lass DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }

  async createFeedback(data: InsertFeedback): Promise<Feedback> {
    const [result] = await db.insert(feedback).values(data).returning();
    await this.purgeFeedback();
Designing riddle quest API and progress tracking
I'm outlining how to overhaul riddle quest endpoints and progress management, including new DB tables for tracking daily progress per wallet and defining API routes for starting, updating, and querying quest status while coordinating client-server state synchronization with fallback to localStorage. The plan covers enforcing one quest per 24 hours, integrating with the oracle for dynamic riddles, and clarifying game logic around riddles solved, passes, hints, and quest completion conditions.

Planning client cache clearing and chat UI redesign
I'm mapping out clearing old localStorage keys on RiddleQuest load to avoid stale data while preserving new progress fallback keys, redesigning RiddleQuest to a simplified chat interface with streaming typing effects and avatars, implementing APIs for progress start/update with 24-hour quest enforcement, and ensuring integration with game points and oracle calls without static riddles fallback.

/workspace/Dec_25_GRK_BC$ /bin/bash -lc rg -n "riddle" shared/schema.ts
520:export const riddleLeaderboard = pgTable('riddle_leaderboard', {
535:export const insertRiddleLeaderboardSchema = createInsertSchema(riddleLeaderboard).omit({
541:export type RiddleLeaderboard = typeof riddleLeaderboard.$inferSelect;
544:export const riddleDailySets = pgTable('riddle_daily_sets', {
549:  riddleCount: integer('riddle_count').default(5).notNull(),
552:export const insertRiddleDailySetSchema = createInsertSchema(riddleDailySets).omit({
558:export type RiddleDailySet = typeof riddleDailySets.$inferSelect;
560:// Daily Riddle Entries - individual riddles within a daily set
561:export const riddleDailyEntries = pgTable('riddle_daily_entries', {
564:  riddleIndex: integer('riddle_index').notNull(),
573:export const insertRiddleDailyEntrySchema = createInsertSchema(riddleDailyEntries).omit({
578:export type RiddleDailyEntry = typeof riddleDailyEntries.$inferSelect;
581:export const riddleAttempts = pgTable('riddle_attempts', {
584:  riddleEntryId: integer('riddle_entry_id').notNull(),
594:export const insertRiddleAttemptSchema = createInsertSchema(riddleAttempts).omit({
600:export type RiddleAttempt = typeof riddleAttempts.$inferSelect;
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '500,660p' shared/schema.ts
export type SearchHistory = typeof searchHistory.$inferSelect;

// Admin authentication attempts for password protection with lockout
export const adminAuthAttempts = pgTable('admin_auth_attempts', {
  id: serial('id').primaryKey(),
  walletAddress: text('wallet_address').notNull(),
  attemptCount: integer('attempt_count').default(0).notNull(),
  lastAttemptAt: timestamp('last_attempt_at').notNull(),
  lockedUntil: timestamp('locked_until'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

export type AdminAuthAttempt = typeof adminAuthAttempts.$inferSelect;

// ============================================
// RIDDLE QUEST LEADERBOARD & DAILY CHALLENGES
// ============================================

// Riddle Quest Leaderboard - persistent scores per wallet
export const riddleLeaderboard = pgTable('riddle_leaderboard', {
  id: serial('id').primaryKey(),
  walletAddress: text('wallet_address').notNull().unique(),
  totalSolves: integer('total_solves').default(0).notNull(),
  dailySolves: integer('daily_solves').default(0).notNull(),
  bestTimeMs: integer('best_time_ms'),
  totalTimeMs: bigint('total_time_ms', { mode: 'number' }).default(0),
  currentStreak: integer('current_streak').default(0).notNull(),
  longestStreak: integer('longest_streak').default(0).notNull(),
  level: integer('level').default(1).notNull(),
  points: integer('points').default(0).notNull(),
  lastActiveAt: timestamp('last_active_at').defaultNow().notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

export const insertRiddleLeaderboardSchema = createInsertSchema(riddleLeaderboard).omit({
  id: true,
  createdAt: true,
});

export type InsertRiddleLeaderboard = z.infer<typeof insertRiddleLeaderboardSchema>;
export type RiddleLeaderboard = typeof riddleLeaderboard.$inferSelect;

// Daily Riddle Sets - one set generated per UTC day
export const riddleDailySets = pgTable('riddle_daily_sets', {
  id: serial('id').primaryKey(),
  dateKey: varchar('date_key', { length: 10 }).notNull().unique(),
  generatedAt: timestamp('generated_at').defaultNow().notNull(),
  generatedViaOracle: boolean('generated_via_oracle').default(false),
  riddleCount: integer('riddle_count').default(5).notNull(),
});

export const insertRiddleDailySetSchema = createInsertSchema(riddleDailySets).omit({
  id: true,
  generatedAt: true,
});

export type InsertRiddleDailySet = z.infer<typeof insertRiddleDailySetSchema>;
export type RiddleDailySet = typeof riddleDailySets.$inferSelect;

// Daily Riddle Entries - individual riddles within a daily set
export const riddleDailyEntries = pgTable('riddle_daily_entries', {
  id: serial('id').primaryKey(),
  setId: integer('set_id').notNull(),
  riddleIndex: integer('riddle_index').notNull(),
  question: text('question').notNull(),
  answers: text('answers').notNull(),
  hint: text('hint'),
  difficulty: varchar('difficulty', { length: 10 }).default('medium'),
  theme: varchar('theme', { length: 50 }),
  isOracle: boolean('is_oracle').default(false),
});

export const insertRiddleDailyEntrySchema = createInsertSchema(riddleDailyEntries).omit({
  id: true,
});

export type InsertRiddleDailyEntry = z.infer<typeof insertRiddleDailyEntrySchema>;
export type RiddleDailyEntry = typeof riddleDailyEntries.$inferSelect;

// Riddle Attempts - track each user's solve attempts
export const riddleAttempts = pgTable('riddle_attempts', {
  id: serial('id').primaryKey(),
  walletAddress: text('wallet_address').notNull(),
  riddleEntryId: integer('riddle_entry_id').notNull(),
  dateKey: varchar('date_key', { length: 10 }).notNull(),
  attemptCount: integer('attempt_count').default(1).notNull(),
  solved: boolean('solved').default(false),
  solveTimeMs: integer('solve_time_ms'),
  pointsEarned: integer('points_earned').default(0),
  attemptedAt: timestamp('attempted_at').defaultNow().notNull(),
  solvedAt: timestamp('solved_at'),
});

export const insertRiddleAttemptSchema = createInsertSchema(riddleAttempts).omit({
  id: true,
  attemptedAt: true,
});

export type InsertRiddleAttempt = z.infer<typeof insertRiddleAttemptSchema>;
export type RiddleAttempt = typeof riddleAttempts.$inferSelect;

// Creature Command Progress - stores player ability levels and points
export const creatureProgress = pgTable('creature_progress', {
  id: varchar('id').primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text('wallet_address').notNull().unique(),
  totalPoints: integer('total_points').default(0).notNull(),
  piercingLevel: integer('piercing_level').default(0).notNull(),
  shieldLevel: integer('shield_level').default(0).notNull(),
  rapidFireLevel: integer('rapid_fire_level').default(0).notNull(),
  explosiveLevel: integer('explosive_level').default(0).notNull(),
  slowFieldLevel: integer('slow_field_level').default(0).notNull(),
  multiBubbleLevel: integer('multi_bubble_level').default(0).notNull(),
  regenBurstLevel: integer('regen_burst_level').default(0).notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const insertCreatureProgressSchema = createInsertSchema(creatureProgress).omit({
  id: true,
  updatedAt: true,
});

export type InsertCreatureProgress = z.infer<typeof insertCreatureProgressSchema>;
export type CreatureProgress = typeof creatureProgress.$inferSelect;

// Daily Challenges - tracks daily survival challenges per wallet
export const dailyChallenges = pgTable('daily_challenges', {
  id: varchar('id').primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text('wallet_address').notNull(),
  dateKey: varchar('date_key', { length: 10 }).notNull(),
  survivesCount: integer('survives_count').default(0).notNull(),
  challengeCompleted: boolean('challenge_completed').default(false),
  pointsAwarded: integer('points_awarded').default(0).notNull(),
  highestStage: integer('highest_stage').default(1).notNull(),
  highestWave: integer('highest_wave').default(1).notNull(),
  gamesPlayed: integer('games_played').default(0).notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => [
  uniqueIndex('daily_challenges_wallet_date_idx').on(table.walletAddress, table.dateKey),
]);

export const insertDailyChallengeSchema = createInsertSchema(dailyChallenges).omit({
  id: true,
  updatedAt: true,
});

export type InsertDailyChallenge = z.infer<typeof insertDailyChallengeSchema>;
export type DailyChallenge = typeof dailyChallenges.$inferSelect;

// BrainX Points - tracks locked points with 1-year mock lock, 500/day cap
export const brainXPoints = pgTable('brainx_points', {
  id: varchar('id').primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text('wallet_address').notNull(),
  totalPoints: integer('total_points').default(0).notNull(),
  lockedPoints: integer('locked_points').default(0).notNull(),
  unlockedPoints: integer('unlocked_points').default(0).notNull(),
  pointsEarnedToday: integer('points_earned_today').default(0).notNull(),
  lastEarnedDate: varchar('last_earned_date', { length: 10 }),
  lockExpiresAt: timestamp('lock_expires_at'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
Designing new RiddleQuest component
I'm planning to add a riddle_progress table, update imports and API routes, then rewrite the RiddleQuest component from scratch with fresh state management and API calls. The new version will simplify logic around progress, riddle generation, and storage, removing unused NFT checks and restructuring API calls for clarity. I'm working out the state shape and effects to handle quest lifecycle, localStorage cleanup, and fetching progress dynamically while considering how to integrate with the oracle API most cleanly.

/workspace/Dec_25_GRK_BC$ /bin/bash -lc rg -n "oracleClient" client/src -S
client/src/components/RiddleQuest.tsx
33:} from '@/lib/oracleClient';
Planning oracleClient refactor
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1240,1335p' server/routes.ts
app.get("/api/game/leaderboard", async (req, res) => {
    try {
      const limit = Math.min(50, Math.max(1, parseInt(req.query.limit as string) || 20));
      const leaderboard = await storage.getGameLeaderboard(limit);
      return res.json(leaderboard);
    } catch (error) {
      console.error("[Game] Error fetching leaderboard:", error);
      return res.status(500).json({ error: "Failed to fetch leaderboard" });
    }
  });

  app.get("/api/game/stats/:wallet", async (req, res) => {
    try {
      const stats = await storage.getPlayerGameStats(req.params.wallet);
      if (!stats) {
        return res.json({ exists: false, stats: null });
      }
      return res.json({ exists: true, stats });
    } catch (error) {
      console.error("[Game] Error fetching player stats:", error);
      return res.status(500).json({ error: "Failed to fetch player stats" });
    }
  });

  // Mind Warp Strategist API Endpoint for Riddle Quest
  app.post("/api/oracle", gameLimiter, async (req, res) => {
    try {
      const { action, level, difficulty, riddle, userAnswer, messages } = req.body;

      if (!action || !['generate_riddle', 'evaluate_answer', 'get_hint'].includes(action)) {
        return res.status(400).json({ error: "Invalid action" });
      }

      let promptMessages: Array<{ role: 'user' | 'assistant'; content: string }> = [];

      if (action === 'generate_riddle') {
        const lvl = typeof level === 'number' ? level : 1;
        const diff = typeof difficulty === 'string' ? difficulty : 'medium';
        const prompt = generateRiddlePrompt(lvl, diff);
        promptMessages = [{ role: 'user', content: prompt }];
      } else if (action === 'evaluate_answer') {
        if (!riddle || !userAnswer) {
          return res.status(400).json({ error: "riddle and userAnswer required" });
        }
        const prompt = evaluateAnswerPrompt(riddle, userAnswer);
        promptMessages = Array.isArray(messages) ? [...messages.slice(-6), { role: 'user', content: prompt }] : [{ role: 'user', content: prompt }];
      } else if (action === 'get_hint') {
        if (!riddle) {
          return res.status(400).json({ error: "riddle required" });
        }
        const prompt = getHintPrompt(riddle);
        promptMessages = Array.isArray(messages) ? [...messages.slice(-6), { role: 'user', content: prompt }] : [{ role: 'user', content: prompt }];
      }

      const result = await callOracle(promptMessages, action as any);
      
      if (!result.success) {
        console.warn(`[Mind Warp Strategist] API call failed: ${result.error}`);
        return res.status(503).json({
          success: false,
          fallback: true,
          message: "Mind Warp Strategist is scheming... Riddles are baking, return soon.",
          error: result.error
        });
      }

      return res.json({
        success: true,
        message: result.message,
        isCorrect: result.isCorrect,
        isHint: result.isHint,
        riddleGenerated: result.riddleGenerated
      });
    } catch (error) {
      console.error("[Mind Warp Strategist] Endpoint error:", error);
      return res.status(500).json({
        success: false,
        fallback: true,
        message: "Mind Warp Strategist is scheming... Riddles are baking, return soon.",
        error: "INTERNAL_ERROR"
      });
    }
  });

  // ============================================
  // RIDDLE QUEST LEADERBOARD & DAILY CHALLENGES
  // ============================================

  // Get riddle quest leaderboard
  app.get("/api/riddle-quest/leaderboard", async (req, res) => {
    try {
      const limit = Math.min(100, Math.max(1, parseInt(req.query.limit as string) || 50));
      const leaderboard = await storage.getRiddleLeaderboard(limit);
      return res.json(leaderboard);
    } catch (error) {
      console.error("[RiddleQuest] Error fetching leaderboard:", error);
Planning riddle progress integration
I'm updating the API and prompt generation to include riddle progress details like riddleNumber and passes used, adjusting client-server message handling to pass this context more flexibly. Iâ€™m also considering removing static pools for daily riddles and enhancing storage with new progress tracking routes and schema changes.

Success. Updated the following files:
M shared/schema.ts
Updating storage imports and interface
Success. Updated the following files:
M server/storage.ts
Inserting methods into class
Success. Updated the following files:
M server/storage.ts
Updating prompt functions and constants
I'm preparing to replace the SYSTEM_PROMPT with an exact string and modify generateRiddlePrompt to accept a parameter object with progress info. I'll also trim evaluateAnswerPrompt and getHintPrompt for conciseness, set max_tokens to 150, and update server routes to accommodate these changes.

Success. Updated the following files:
M server/lib/oracleService.ts
Removing static riddles and refactoring daily endpoints
I'm focusing on removing the STATIC_RIDDLE_POOL and related static logic to make the app rely solely on the oracle for riddles. Iâ€™m updating generateDailyRiddleSet to call the oracle for new riddles and changing daily attempt handling to use live oracle evaluation instead of static answers. This means disabling or refactoring the daily challenge endpoints since static riddles and pre-stored answers no longer fit the live chat approach. Iâ€™ll adjust routes accordingly, keeping daily endpoints but having them return dynamic oracle-powered data or errors if oracle calls fail.

Success. Updated the following files:
M server/routes.ts
Updating /api/oracle route
Success. Updated the following files:
M server/routes.ts
Updating API endpoints for oracle evaluation
/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1350,1525p' server/routes.ts
}
      
      const dateKey = new Date().toISOString().slice(0, 10);
      
      const existingAttempt = await storage.getRiddleAttempt(walletAddress, riddleEntryId);
      if (existingAttempt?.solved) {
        return res.json({
          success: true,
          alreadySolved: true,
          message: "You've already solved this riddle!"
        });
      }
      
      const entries = await storage.getDailyEntries(
        (await storage.getDailySet(dateKey))?.id || 0
      );
      const entry = entries.find(e => e.id === riddleEntryId);
      
      if (!entry) {
        return res.status(404).json({ error: "Riddle not found" });
      }
      
      const acceptedAnswers = entry.answers.toLowerCase().split('|').map(a => a.trim());
      
      const normalizeForMatch = (input: string): string => {
        return input
          .toLowerCase()
          .replace(/^(is it|it's|i think|maybe|the answer is|it is|could it be|i believe|my answer is)\s*/i, '')
          .replace(/[?!.,;:'"$@#%^&*(){}[\]<>\/\\|`~]/g, '')
          .replace(/\s+/g, ' ')
          .trim();
      };
      
      const userNormalized = normalizeForMatch(answer);
      
      const isCorrect = acceptedAnswers.some(expectedAnswer => {
        const expectedNormalized = normalizeForMatch(expectedAnswer);
        return userNormalized === expectedNormalized ||
          userNormalized.includes(expectedNormalized) ||
          expectedNormalized.includes(userNormalized) ||
          (userNormalized.length > 2 && expectedNormalized.startsWith(userNormalized)) ||
          (expectedNormalized.length > 2 && userNormalized.startsWith(expectedNormalized));
      });
      
      const basePoints = isOracle ? 150 : 100;
      const timeBonus = solveTimeMs && solveTimeMs < 30000 ? 50 : (solveTimeMs && solveTimeMs < 60000 ? 25 : 0);
      const pointsEarned = isCorrect ? basePoints + timeBonus : 0;
      
      if (existingAttempt) {
        await storage.updateRiddleAttempt(
          existingAttempt.id,
          isCorrect,
          solveTimeMs || 0,
          pointsEarned
        );
      } else {
        await storage.createRiddleAttempt({
          walletAddress,
          riddleEntryId,
          dateKey,
          attemptCount: 1,
          solved: isCorrect,
          solveTimeMs: isCorrect ? solveTimeMs : undefined,
          pointsEarned
        });
      }
      
      if (isCorrect) {
        await storage.updateRiddleLeaderboardStats(
          walletAddress,
          pointsEarned,
          true,
          solveTimeMs
        );
      }
      
      return res.json({
        success: true,
        isCorrect,
        pointsEarned,
        message: isCorrect 
          ? "Correct! The Oracle acknowledges your wisdom." 
          : "Not quite right. The Oracle awaits your next attempt..."
      });
    } catch (error) {
      console.error("[RiddleQuest] Error processing attempt:", error);
      return res.status(500).json({ error: "Failed to process attempt" });
    }
  });

  // Price Proxy Endpoint (avoids CORS issues with CoinGecko)
  app.get("/api/price/basedai", async (req, res) => {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000);
      
      const response = await fetch(
        "https://api.coingecko.com/api/v3/simple/price?ids=basedai&vs_currencies=usd&include_24hr_change=true",
        { signal: controller.signal }
      );
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        return res.status(502).json({ error: "Failed to fetch price from CoinGecko" });
      }
      
      const data = await response.json();
      return res.json(data);
    } catch (error) {
      console.error("[Price] Error fetching price:", error);
      return res.status(500).json({ error: "Failed to fetch price" });
    }
  });

  // Feature Flags Endpoints
  app.get("/api/feature-flags", async (req, res) => {
    try {
      const flags = await storage.getFeatureFlags();
      return res.json(flags);
    } catch (error) {
      console.error("[FeatureFlags] Error fetching flags:", error);
      return res.status(500).json({ error: "Failed to fetch feature flags" });
    }
  });

  app.post("/api/feature-flags/:key", writeLimiter, async (req, res) => {
    try {
      const { key } = req.params;
      const { enabled, walletAddress } = req.body;

      if (typeof enabled !== 'boolean') {
        return res.status(400).json({ error: "enabled must be a boolean" });
      }

      if (!walletAddress || typeof walletAddress !== 'string') {
        return res.status(400).json({ error: "walletAddress required" });
      }

      const isAdmin = ADMIN_WALLETS.some(
        admin => admin.toLowerCase() === walletAddress.toLowerCase()
      );
      if (!isAdmin) {
        console.log(`[FeatureFlags] Unauthorized update attempt by ${walletAddress.slice(0, 8)}...`);
        return res.status(403).json({ error: "Unauthorized: Admin wallet required" });
      }

      const success = await storage.updateFeatureFlag(key, enabled, walletAddress);
      if (!success) {
        return res.status(500).json({ error: "Failed to update feature flag" });
      }

      console.log(`[FeatureFlags] ${key} set to ${enabled} by ${walletAddress.slice(0, 8)}...`);
      return res.json({ success: true, key, enabled });
    } catch (error) {
      console.error("[FeatureFlags] Error updating flag:", error);
      return res.status(500).json({ error: "Failed to update feature flag" });
    }
  });

  // Analytics Endpoints
  app.post("/api/analytics", async (req, res) => {
    try {
      const { events } = req.body;
      
      if (!Array.isArray(events) || events.length === 0) {
        return res.status(400).json({ error: 'Invalid events array' });
      }

      const eventRecords = events.map((e: any) => ({
        event: e.event,
        properties: JSON.stringify(e.properties || {}),
        sessionId: e.sessionId,
        userId: e.userId || null,
        timestamp: e.timestamp,
      }));
Updating daily attempt evaluation logic
Success. Updated the following files:
M server/routes.ts
Adding new riddle progress endpoints
Iâ€™m planning to add GET and POST endpoints to manage riddle quest progress, handling daily progress tracking and start conditions. Iâ€™ll implement wallet validation simply, use date keys to enforce one quest per day, and integrate storage calls to fetch and update progress data accordingly. These will be added near the existing riddle quest or oracle routes for better organization.

Success. Updated the following files:
M server/routes.ts
Updating error handling and client code
Success. Updated the following files:
M client/src/lib/oracleClient.ts
Rewriting RiddleQuest component logic
/workspace/Dec_25_GRK_BC$ /bin/bash -lc cat <<'EOF' > /workspace/Dec_25_GRK_BC/client/src/components/RiddleQuest.tsx
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useAccount } from 'wagmi';
import { useConnectModal } from '@rainbow-me/rainbowkit';
import { motion } from 'framer-motion';
import { Bot, Send, ShieldCheck, ShieldAlert, RotateCcw, Loader2 } from 'lucide-react';
import MindWarpStrategist from '@/assets/mind-warp-strategist.png';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { useGamePoints } from '@/hooks/useGamePoints';
import { logActivity } from '@/hooks/useActivityHistory';
import {
  evaluateOracleAnswer,
  generateOracleRiddle,
  getOracleHint,
  isQuestionOrHintRequest
} from '@/lib/oracleClient';

const TOTAL_RIDDLES = 33;
const WIN_TARGET = 30;
const MAX_PASSES = 3;
const MAX_INTERACTIONS = 3;

const LEGACY_KEYS = [
  'oracleQuestions',
  'riddleQuestLastPlayed',
  'riddleQuestQuestionsUsed',
  'riddle_quest_leaderboard'
];

type QuestState = 'idle' | 'playing' | 'won' | 'lost';

type ChatMessage = {
  id: string;
  role: 'assistant' | 'user';
  content: string;
};

interface QuestProgress {
  dateKey: string;
  riddlesSolved: number;
  passesUsed: number;
  interactions: number;
}

const getDateKey = () => new Date().toISOString().slice(0, 10);

const createMessageId = () => `${Date.now()}-${Math.random().toString(16).slice(2)}`;

const getLocalProgressKey = (wallet: string) => `riddle_progress_${wallet.toLowerCase()}`;
const getChallengeAwardedKey = (wallet: string, dateKey: string) => `riddle_progress_awarded_${wallet.toLowerCase()}_${dateKey}`;

export function RiddleQuest() {
  const { address, isConnected } = useAccount();
  const { openConnectModal } = useConnectModal();
  const { earnPoints } = useGamePoints();

  const [questState, setQuestState] = useState<QuestState>('idle');
  const [progress, setProgress] = useState<QuestProgress | null>(null);
  const [canStartQuest, setCanStartQuest] = useState(true);
  const [currentRiddle, setCurrentRiddle] = useState<string | null>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [retryAction, setRetryAction] = useState<(() => Promise<void>) | null>(null);

  const messagesEndRef = useRef<HTMLDivElement | null>(null);
  const isMountedRef = useRef(true);

  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const totalAnswered = useMemo(() => {
    if (!progress) return 0;
    return progress.riddlesSolved + progress.passesUsed;
  }, [progress]);

  const interactionsRemaining = useMemo(() => {
    if (!progress) return MAX_INTERACTIONS;
    return Math.max(0, MAX_INTERACTIONS - progress.interactions);
  }, [progress]);

  const isQuestComplete = progress ? progress.riddlesSolved >= WIN_TARGET : false;
  const isQuestFailed = progress ? progress.passesUsed >= MAX_PASSES || totalAnswered >= TOTAL_RIDDLES : false;

  useEffect(() => {
    if (!address) return;
    LEGACY_KEYS.forEach((key) => localStorage.removeItem(key));
    localStorage.removeItem(`riddle_quest_${address.toLowerCase()}`);
  }, [address]);

  useEffect(() => {
    if (!address) return;
    const loadProgress = async () => {
      const localKey = getLocalProgressKey(address);
      const fallback = localStorage.getItem(localKey);
      try {
        const res = await fetch(`/api/riddle-quest/progress/${address}`);
        if (!res.ok) {
          throw new Error('Failed to fetch quest progress');
        }
        const data = await res.json();
        const remoteProgress = data.progress as QuestProgress | null;
        if (remoteProgress) {
          setProgress(remoteProgress);
          localStorage.setItem(localKey, JSON.stringify(remoteProgress));
          setCanStartQuest(false);
          return;
        }
        setProgress(null);
        setCanStartQuest(data.canStart ?? true);
      } catch (error) {
        if (fallback) {
          const parsed = JSON.parse(fallback) as QuestProgress;
          setProgress(parsed);
        } else {
          setProgress(null);
        }
      }
    };

    loadProgress();
  }, [address]);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, loading]);

  const persistProgress = useCallback(async (nextProgress: QuestProgress) => {
    if (!address) return;
    setProgress(nextProgress);
    localStorage.setItem(getLocalProgressKey(address), JSON.stringify(nextProgress));
    try {
      await fetch('/api/riddle-quest/progress', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          walletAddress: address,
          dateKey: nextProgress.dateKey,
          riddlesSolved: nextProgress.riddlesSolved,
          passesUsed: nextProgress.passesUsed,
          interactions: nextProgress.interactions
        })
      });
    } catch (error) {
      console.warn('[RiddleQuest] Failed to persist progress:', error);
    }
  }, [address]);

  const addUserMessage = useCallback((content: string) => {
    setMessages((prev) => [...prev, { id: createMessageId(), role: 'user', content }]);
  }, []);

  const addAssistantMessage = useCallback(async (content: string) => {
    const id = createMessageId();
    setMessages((prev) => [...prev, { id, role: 'assistant', content: '' }]);
    for (const char of content) {
      if (!isMountedRef.current) return;
      await new Promise((resolve) => setTimeout(resolve, 50));
      setMessages((prev) =>
        prev.map((message) =>
          message.id === id
            ? { ...message, content: message.content + char }
            : message
        )
      );
    }
  }, []);

  const fetchRiddle = useCallback(async (currentProgress: QuestProgress) => {
    setLoading(true);
    setErrorMessage(null);
    const riddleNumber = currentProgress.riddlesSolved + currentProgress.passesUsed + 1;

    const result = await generateOracleRiddle(
      riddleNumber,
      TOTAL_RIDDLES,
      currentProgress.riddlesSolved,
      currentProgress.passesUsed
    );

    if (!result.success || !result.message) {
      setErrorMessage('Strategist scheming...');
      setRetryAction(() => async () => fetchRiddle(currentProgress));
      setLoading(false);
      return;
    }

    setCurrentRiddle(result.message);
    await addAssistantMessage(result.message);
    setLoading(false);
  }, [addAssistantMessage]);

  const startQuest = async () => {
    if (!address) return;
    setLoading(true);
    setMessages([]);
    setCurrentRiddle(null);
    setErrorMessage(null);
    setRetryAction(null);

    try {
      const response = await fetch('/api/riddle-quest/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ walletAddress: address })
      });

      if (!response.ok) {
        throw new Error('Failed to start quest');
      }

      const data = await response.json();
      const nextProgress: QuestProgress = {
        dateKey: data.dateKey || getDateKey(),
        riddlesSolved: data.progress?.riddlesSolved ?? 0,
        passesUsed: data.progress?.passesUsed ?? 0,
        interactions: data.progress?.interactions ?? 0
      };

      setQuestState('playing');
      await persistProgress(nextProgress);
      await fetchRiddle(nextProgress);
      setCanStartQuest(false);
    } catch (error) {
      setErrorMessage('Strategist scheming...');
      setRetryAction(() => startQuest);
    } finally {
      setLoading(false);
    }
  };

  const updateQuestStatus = useCallback(async (nextProgress: QuestProgress) => {
    if (!address) return;

    if (nextProgress.riddlesSolved >= WIN_TARGET) {
      setQuestState('won');
      const awardKey = getChallengeAwardedKey(address, nextProgress.dateKey);
      if (!localStorage.getItem(awardKey)) {
        earnPoints('riddle-quest', 'challenge', 50);
        localStorage.setItem(awardKey, 'true');
      }
      return;
    }

    if (nextProgress.passesUsed >= MAX_PASSES || (nextProgress.passesUsed + nextProgress.riddlesSolved) >= TOTAL_RIDDLES) {
      setQuestState('lost');
    }
  }, [address, earnPoints]);

  const handleHintRequest = useCallback(async () => {
    if (!currentRiddle || !progress) return;
    if (progress.interactions >= MAX_INTERACTIONS) {
      await addAssistantMessage('The Strategist withholds further clues.');
      return;
    }

    setLoading(true);
    const updatedProgress: QuestProgress = {
      ...progress,
      interactions: progress.interactions + 1,
      passesUsed: progress.passesUsed + 1
    };

    await persistProgress(updatedProgress);

    const result = await getOracleHint(currentRiddle, messages.map((m) => ({ role: m.role, content: m.content })));
    if (!result.success || !result.message) {
      setErrorMessage('Strategist scheming...');
      setRetryAction(() => handleHintRequest);
      setLoading(false);
      return;
    }

    await addAssistantMessage(result.message);
    setLoading(false);
    await updateQuestStatus(updatedProgress);
  }, [addAssistantMessage, currentRiddle, messages, persistProgress, progress, updateQuestStatus]);

  const handleAnswerSubmit = useCallback(async () => {
    if (!currentRiddle || !progress || !input.trim()) return;

    const userInput = input.trim();
    setInput('');
    addUserMessage(userInput);

    if (isQuestionOrHintRequest(userInput)) {
      await handleHintRequest();
      return;
    }

    setLoading(true);
    const result = await evaluateOracleAnswer(
      currentRiddle,
      userInput,
      messages.map((m) => ({ role: m.role, content: m.content }))
    );

    if (!result.success || !result.message) {
      setErrorMessage('Strategist scheming...');
      setRetryAction(() => handleAnswerSubmit);
      setLoading(false);
      return;
    }

    await addAssistantMessage(result.message);

    const nextProgress: QuestProgress = {
      ...progress,
      riddlesSolved: progress.riddlesSolved + (result.isCorrect ? 1 : 0),
      passesUsed: progress.passesUsed + (result.isCorrect ? 0 : 1)
    };

    if (result.isCorrect && address) {
      earnPoints('riddle-quest', 'riddle', 10);
      logActivity({
        walletAddress: address,
        eventType: 'riddle_solved',
        details: `Solved riddle ${nextProgress.riddlesSolved} of ${TOTAL_RIDDLES}`,
        pointsEarned: 10,
        gameType: 'riddle_quest'
      });
    } else if (address) {
      logActivity({
        walletAddress: address,
        eventType: 'riddle_failed',
        details: `Failed riddle ${totalAnswered + 1} of ${TOTAL_RIDDLES}`,
        gameType: 'riddle_quest'
      });
    }

    await persistProgress(nextProgress);
    await updateQuestStatus(nextProgress);

    if (nextProgress.passesUsed < MAX_PASSES && (nextProgress.passesUsed + nextProgress.riddlesSolved) < TOTAL_RIDDLES) {
      await fetchRiddle(nextProgress);
    }

    setLoading(false);
  }, [addAssistantMessage, addUserMessage, currentRiddle, earnPoints, fetchRiddle, handleHintRequest, input, messages, persistProgress, progress, totalAnswered, updateQuestStatus, address]);

  if (!isConnected) {
    return (
      <div className="min-h-[calc(100vh-5rem)] flex items-center justify-center px-4">
        <motion.div
          className="text-center p-8"
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
        >
          <Bot className="w-20 h-20 text-cyan-500 mx-auto mb-6 animate-pulse" />
          <h2 className="text-3xl font-orbitron font-bold text-white mb-4">
            Connect Wallet to Begin
          </h2>
          <p className="text-gray-400 mb-8 max-w-md mx-auto">
            The Mind Warp Strategist waits for a verified Guardian.
          </p>
          <Button
            onClick={openConnectModal}
            className="bg-gradient-to-r from-cyan-500 to-purple-500 text-black font-orbitron font-bold px-8 py-4 rounded-xl"
            data-testid="button-connect-riddle"
          >
            Connect Wallet
          </Button>
        </motion.div>
      </div>
    );
  }

  return (
    <div className="min-h-[calc(100vh-5rem)] px-4 py-10">
      <div className="max-w-5xl mx-auto grid gap-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div>
            <h1 className="text-3xl md:text-4xl font-orbitron font-bold text-white">Mind Warp Strategist</h1>
            <p className="text-gray-400">33 riddles. 30 must fall. Three passes doom the quest.</p>
          </div>
          <div className="flex items-center gap-3">
            <Badge className="bg-cyan-500/20 text-cyan-300 border border-cyan-500/40">
              {progress?.riddlesSolved ?? 0}/{TOTAL_RIDDLES} solved
            </Badge>
            <Badge className="bg-purple-500/20 text-purple-300 border border-purple-500/40">
              {progress?.passesUsed ?? 0}/{MAX_PASSES} passes
            </Badge>
            <Badge className="bg-amber-500/20 text-amber-300 border border-amber-500/40">
              {interactionsRemaining} hints left
            </Badge>
          </div>
        </div>

        <div className="rounded-3xl border border-cyan-500/20 bg-black/40 backdrop-blur-sm overflow-hidden">
          <div className="flex flex-col md:flex-row">
            <div className="md:w-1/3 border-b md:border-b-0 md:border-r border-cyan-500/10 p-6 flex flex-col gap-4">
              <div className="flex items-center gap-4">
                <img
                  src={MindWarpStrategist}
                  alt="Mind Warp Strategist"
                  className="w-20 h-20 rounded-2xl border border-cyan-500/40 object-cover"
                />
                <div>
                  <p className="text-sm uppercase tracking-wide text-cyan-400">Strategist</p>
                  <p className="text-white font-semibold">Cunning Guardian</p>
                </div>
              </div>
              <div className="space-y-2 text-sm text-gray-400">
                <p>Quest date: {progress?.dateKey ?? getDateKey()}</p>
                <p>Riddle {Math.min(totalAnswered + 1, TOTAL_RIDDLES)} of {TOTAL_RIDDLES}</p>
                <p>Goal: {WIN_TARGET} correct</p>
              </div>
              {questState === 'idle' && (
                <Button
                  onClick={startQuest}
                  disabled={!canStartQuest || loading}
                  className="bg-gradient-to-r from-cyan-500 to-purple-500 text-black font-orbitron font-bold"
                >
                  {canStartQuest ? 'Begin Quest' : 'Quest in Progress'}
                </Button>
              )}
              {questState !== 'idle' && (
                <Button
                  onClick={startQuest}
                  variant="outline"
                  className="border-cyan-500/40 text-cyan-300"
                  disabled={loading}
                >
                  <RotateCcw className="w-4 h-4 mr-2" />
                  Restart Session
                </Button>
              )}
            </div>

            <div className="flex-1 flex flex-col">
              <div className="flex-1 p-6 space-y-4 max-h-[520px] overflow-y-auto">
                {messages.length === 0 && (
                  <div className="text-center text-gray-500">The Strategist awaits your entry.</div>
                )}
                {messages.map((message) => (
                  <div
                    key={message.id}
                    className={`flex ${message.role === 'assistant' ? 'justify-start' : 'justify-end'}`}
                  >
                    <div
                      className={`max-w-[80%] rounded-2xl px-4 py-3 text-sm leading-relaxed shadow-sm ${
                        message.role === 'assistant'
                          ? 'bg-cyan-500/10 text-cyan-100 border border-cyan-500/20'
                          : 'bg-purple-500/20 text-white border border-purple-500/20'
                      }`}
                    >
                      {message.content}
                    </div>
                  </div>
                ))}
                {loading && (
                  <div className="flex justify-start">
                    <div className="rounded-2xl px-4 py-3 bg-cyan-500/10 text-cyan-200 border border-cyan-500/20 text-sm flex items-center gap-2">
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Strategist weaving...
                    </div>
                  </div>
                )}
                {errorMessage && (
                  <div className="flex justify-start">
                    <div className="rounded-2xl px-4 py-3 bg-amber-500/10 text-amber-200 border border-amber-500/20 text-sm">
                      {errorMessage}
                      {retryAction && (
                        <button
                          className="ml-3 text-amber-300 underline"
                          onClick={retryAction}
                        >
                          Retry
                        </button>
                      )}
                    </div>
                  </div>
                )}
                <div ref={messagesEndRef} />
              </div>

              <div className="border-t border-cyan-500/10 p-4">
                {questState === 'won' && (
                  <div className="flex items-center gap-3 text-emerald-300">
                    <ShieldCheck className="w-5 h-5" />
                    Quest complete. The Strategist bows to your insight.
                  </div>
                )}
                {questState === 'lost' && (
                  <div className="flex items-center gap-3 text-rose-300">
                    <ShieldAlert className="w-5 h-5" />
                    Quest failed. Return after the next cycle.
                  </div>
                )}
                {questState === 'playing' && (
                  <div className="flex gap-3">
                    <Input
                      value={input}
                      onChange={(event) => setInput(event.target.value)}
                      placeholder="Answer, or ask for a hint..."
                      className="bg-black/40 border-cyan-500/30 text-white"
                      data-testid="input-riddle-answer"
                      disabled={loading || isQuestComplete || isQuestFailed}
                    />
                    <Button
                      onClick={handleAnswerSubmit}
                      disabled={loading || !input.trim()}
                      className="bg-gradient-to-r from-cyan-500 to-purple-500 text-black font-bold"
                      data-testid="button-submit-riddle"
                    >
                      <Send className="w-4 h-4" />
                    </Button>
                  </div>
                )}
                {questState === 'idle' && (
                  <p className="text-sm text-gray-500">Begin the quest to summon the first riddle.</p>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
EOF
Refining quest state and localStorage handling
I'm working on improving how the quest state and start button logic respond to existing progress, so users can continue quests properly. Iâ€™m also tackling localStorage cleanup by removing old or fallback progress on quest start, then resetting it after fetching fresh data to align with the database as the source of truth. This should help avoid stale or conflicting progress while keeping the fallback mechanism intact.

Success. Updated the following files:
M client/src/components/RiddleQuest.tsx
Updating button behavior logic
Success. Updated the following files:
M client/src/components/RiddleQuest.tsx
Reviewing and updating quest and oracle integrations
/workspace/Dec_25_GRK_BC$ /bin/bash -lc rg -n "generateRiddlePrompt" -S server
server/routes.ts
33:import { callOracle, generateRiddlePrompt, evaluateAnswerPrompt, getHintPrompt } from './lib/oracleService';
186:        content: generateRiddlePrompt({
1212:        const prompt = generateRiddlePrompt({

server/lib/oracleService.ts
169:export function generateRiddlePrompt(context: {
Updating RiddleQuest error handling and progress logic
I'm making sure the /api/riddle-quest/daily endpoint gracefully handles errors from generateDailyRiddleSet and updating UI references accordingly. Iâ€™m verifying unused imports and cleaning the RiddleQuest codebase where needed. Iâ€™ll adjust quest state management so starting a quest sets it to playing and properly shows errors if fetching riddles fails. For progress tracking, Iâ€™m improving cooldown logic by relying on DB-stored progress but adding a localStorage fallback check based on date keys to correctly determine if the quest can start within 24 hours. This involves patching the loadProgress error catch path to update canStartQuest depending on the fallbackâ€™s date validity.

Success. Updated the following files:
M client/src/components/RiddleQuest.tsx
Updating riddle quest logic and oracle evaluation
Iâ€™m reviewing changes around loading progress, localStorage clearing, and oracleService evaluation prompts to align with new requirements. Iâ€™ll adjust how correctness and hints get detected from model responses since the system prompt no longer includes [CORRECT]/[INCORRECT] tags, ensuring client logic stays consistent. Also, Iâ€™m verifying server route updates, error messaging, feature usage, and cleaning up unused hooks, while planning for testing limitations due to tooling constraints.

/workspace/Dec_25_GRK_BC$ /bin/bash -lc sed -n '1,160p' client/src/hooks/useActivityHistory.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { useAccount } from 'wagmi';
import { useWebSocket } from './useWebSocket';
import { cacheActivityLogs, getCachedActivityLogs, type CachedActivityLog } from '@/lib/activityCache';

export interface ActivityLog {
  id: number;
  walletAddress: string;
  eventType: string;
  details: string | null;
  pointsEarned: number | null;
  gameType: string | null;
  createdAt: string;
}

interface UseActivityHistoryResult {
  logs: ActivityLog[];
  loading: boolean;
  error: string | null;
  isOffline: boolean;
  lastUpdated: string | null;
  refetch: () => Promise<void>;
}

export function useActivityHistory(): UseActivityHistoryResult {
  const { address, isConnected } = useAccount();
  const [logs, setLogs] = useState<ActivityLog[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isOffline, setIsOffline] = useState(false);
  const [lastUpdated, setLastUpdated] = useState<string | null>(null);
  const { on } = useWebSocket({ walletAddress: address });
  const fetchedRef = useRef(false);

  const fetchLogs = useCallback(async () => {
    if (!address || !isConnected) {
      setLogs([]);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/activity/logs?wallet=${address}&limit=50`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch activity logs');
      }

      const data = await response.json();
      setLogs(data.logs);
      setIsOffline(false);
      setLastUpdated(new Date().toISOString());

      // Cache for offline use
      await cacheActivityLogs(address, data.logs);
    } catch (err) {
      console.warn('[useActivityHistory] Fetch failed, trying cache:', err);
      
      // Try to load from cache
      const cached = await getCachedActivityLogs(address);
      if (cached.logs.length > 0) {
        setLogs(cached.logs);
        setLastUpdated(cached.lastUpdated);
        setIsOffline(true);
      } else {
        setError('Unable to load activity logs');
      }
    } finally {
      setLoading(false);
    }
  }, [address, isConnected]);

  // Initial fetch on mount
  useEffect(() => {
    if (isConnected && address && !fetchedRef.current) {
      fetchedRef.current = true;
      fetchLogs();
    }
    
    if (!isConnected) {
      fetchedRef.current = false;
      setLogs([]);
    }
  }, [isConnected, address, fetchLogs]);

  // Handle WebSocket activity_log messages
  useEffect(() => {
    if (!on || !address) return;
    
    const unsubscribe = on('activity_log', (data) => {
      const newLog = data as ActivityLog;
      
      // Only add if it's for this wallet
      if (newLog.walletAddress?.toLowerCase() === address.toLowerCase()) {
        setLogs(prev => {
          // Avoid duplicates
          if (prev.some(log => log.id === newLog.id)) {
            return prev;
          }
          return [newLog, ...prev].slice(0, 50);
        });
        setIsOffline(false);
        setLastUpdated(new Date().toISOString());
      }
    });
    
    return unsubscribe;
  }, [on, address]);

  return {
    logs,
    loading,
    error,
    isOffline,
    lastUpdated,
    refetch: fetchLogs
  };
}

// Helper to log activity from games
export async function logActivity(data: {
  walletAddress: string;
  eventType: 'riddle_solved' | 'riddle_failed' | 'wave_survived' | 'wave_failed' | 'game_completed' | 'points_earned' | 'level_up' | 'challenge_completed';
  details?: string;
  pointsEarned?: number;
  gameType?: 'riddle_quest' | 'creature_command' | 'retro_defender' | 'guardian_defense' | 'infinity_race';
}): Promise<boolean> {
  try {
    const response = await fetch('/api/activity/log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    return response.ok;
  } catch (error) {
    console.warn('[logActivity] Failed to log activity:', error);
    return false;
  }
}
Updating quest state and preparing app run
I'm making sure the questState switches to 'playing' correctly when progress exists, handling input disabling during completion or failure, and verifying updates to riddle progress types and server routes. Now, Iâ€™m preparing to run the development server to attempt taking the required screenshot, though it might be heavy or slow in this environment. I'll try running npm run dev with specified host and port to proceed.

/workspace/Dec_25_GRK_BC$ /bin/bash -lc npm run dev -- --host 0.0.0.0 --port 4173
npm warn Unknown env config "http-proxy". This will stop working in the next major version of npm.
> rest-express@1.0.0 dev
> NODE_ENV=development tsx server/index.ts --host 0.0.0.0 --port 4173
/workspace/Dec_25_GRK_BC/server/db.ts:8
  throw new Error("DATABASE_URL environment variable is not set");
        ^

Error: DATABASE_URL environment variable is not set
    at <anonymous> (/workspace/Dec_25_GRK_BC/server/db.ts:8:9)
    at ModuleJob.run (node:internal/modules/esm/module_job:343:25)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:117:5)

Node.js v22.21.0
Preparing to capture screenshot with Playwright
Handling server connection issue
Checking server responsiveness
Reviewing backend updates and commit prep
/workspace/Dec_25_GRK_BC$ /bin/bash -lc git status -sb
## work
 M client/src/components/RiddleQuest.tsx
 M client/src/lib/oracleClient.ts
 M server/lib/oracleService.ts
 M server/routes.ts
 M server/storage.ts
 M shared/schema.ts
Preparing commit and testing summary
/workspace/Dec_25_GRK_BC$ /bin/bash -lc git diff --stat
client/src/components/RiddleQuest.tsx | 2013 +++++++--------------------------
 client/src/lib/oracleClient.ts        |  158 +--
 server/lib/oracleService.ts           |   71 +-
 server/routes.ts                      |  268 +++--
 server/storage.ts                     |   51 +-
 shared/schema.ts                      |   23 +
 6 files changed, 676 insertions(+), 1908 deletions(-)
Preparing commit with line number tracking
/workspace/Dec_25_GRK_BC$ /bin/bash -lc git add client/src/components/RiddleQuest.tsx client/src/lib/oracleClient.ts server/lib/oracleService.ts server/routes.ts server/storage.ts shared/schema.ts
Committing changes
/workspace/Dec_25_GRK_BC$ /bin/bash -lc git commit -m "Overhaul riddle quest strategist flow"
[work 486e5ae] Overhaul riddle quest strategist flow
 6 files changed, 676 insertions(+), 1908 deletions(-)
Preparing to create PR
/workspace/Dec_25_GRK_BC$ /bin/bash -lc git status -sb
## work
Composing PR message
Preparing final summary and log details
/workspace/Dec_25_GRK_BC$ /bin/bash -lc nl -ba shared/schema.ts | sed -n '560,660p'
560	// Daily Riddle Entries - individual riddles within a daily set
   561	export const riddleDailyEntries = pgTable('riddle_daily_entries', {
   562	  id: serial('id').primaryKey(),
   563	  setId: integer('set_id').notNull(),
   564	  riddleIndex: integer('riddle_index').notNull(),
   565	  question: text('question').notNull(),
   566	  answers: text('answers').notNull(),
   567	  hint: text('hint'),
   568	  difficulty: varchar('difficulty', { length: 10 }).default('medium'),
   569	  theme: varchar('theme', { length: 50 }),
   570	  isOracle: boolean('is_oracle').default(false),
   571	});
   572	
   573	export const insertRiddleDailyEntrySchema = createInsertSchema(riddleDailyEntries).omit({
   574	  id: true,
   575	});
   576	
   577	export type InsertRiddleDailyEntry = z.infer<typeof insertRiddleDailyEntrySchema>;
   578	export type RiddleDailyEntry = typeof riddleDailyEntries.$inferSelect;
   579	
   580	// Riddle Attempts - track each user's solve attempts
   581	export const riddleAttempts = pgTable('riddle_attempts', {
   582	  id: serial('id').primaryKey(),
   583	  walletAddress: text('wallet_address').notNull(),
   584	  riddleEntryId: integer('riddle_entry_id').notNull(),
   585	  dateKey: varchar('date_key', { length: 10 }).notNull(),
   586	  attemptCount: integer('attempt_count').default(1).notNull(),
   587	  solved: boolean('solved').default(false),
   588	  solveTimeMs: integer('solve_time_ms'),
   589	  pointsEarned: integer('points_earned').default(0),
   590	  attemptedAt: timestamp('attempted_at').defaultNow().notNull(),
   591	  solvedAt: timestamp('solved_at'),
   592	});
   593	
   594	export const insertRiddleAttemptSchema = createInsertSchema(riddleAttempts).omit({
   595	  id: true,
   596	  attemptedAt: true,
   597	});
   598	
   599	export type InsertRiddleAttempt = z.infer<typeof insertRiddleAttemptSchema>;
   600	export type RiddleAttempt = typeof riddleAttempts.$inferSelect;
   601	
   602	// Riddle Quest Progress - track daily quest progress per wallet
   603	export const riddleProgress = pgTable('riddle_progress', {
   604	  id: serial('id').primaryKey(),
   605	  walletAddress: text('wallet_address').notNull(),
   606	  dateKey: varchar('date_key', { length: 10 }).notNull(),
   607	  riddlesSolved: integer('riddles_solved').default(0).notNull(),
   608	  passesUsed: integer('passes_used').default(0).notNull(),
   609	  interactions: integer('interactions').default(0).notNull(),
   610	  createdAt: timestamp('created_at').defaultNow().notNull(),
   611	  updatedAt: timestamp('updated_at').defaultNow().notNull(),
   612	}, (table) => [
   613	  uniqueIndex('riddle_progress_wallet_date_idx').on(table.walletAddress, table.dateKey),
   614	]);
   615	
   616	export const insertRiddleProgressSchema = createInsertSchema(riddleProgress).omit({
   617	  id: true,
   618	  createdAt: true,
   619	  updatedAt: true,
   620	});
   621	
   622	export type InsertRiddleProgress = z.infer<typeof insertRiddleProgressSchema>;
   623	export type RiddleProgress = typeof riddleProgress.$inferSelect;
   624	
   625	// Creature Command Progress - stores player ability levels and points
   626	export const creatureProgress = pgTable('creature_progress', {
   627	  id: varchar('id').primaryKey().default(sql`gen_random_uuid()`),
   628	  walletAddress: text('wallet_address').notNull().unique(),
   629	  totalPoints: integer('total_points').default(0).notNull(),
   630	  piercingLevel: integer('piercing_level').default(0).notNull(),
   631	  shieldLevel: integer('shield_level').default(0).notNull(),
   632	  rapidFireLevel: integer('rapid_fire_level').default(0).notNull(),
   633	  explosiveLevel: integer('explosive_level').default(0).notNull(),
   634	  slowFieldLevel: integer('slow_field_level').default(0).notNull(),
   635	  multiBubbleLevel: integer('multi_bubble_level').default(0).notNull(),
   636	  regenBurstLevel: integer('regen_burst_level').default(0).notNull(),
   637	  updatedAt: timestamp('updated_at').defaultNow().notNull(),
   638	});
   639	
   640	export const insertCreatureProgressSchema = createInsertSchema(creatureProgress).omit({
   641	  id: true,
   642	  updatedAt: true,
   643	});
   644	
   645	export type InsertCreatureProgress = z.infer<typeof insertCreatureProgressSchema>;
   646	export type CreatureProgress = typeof creatureProgress.$inferSelect;
   647	
   648	// Daily Challenges - tracks daily survival challenges per wallet
   649	export const dailyChallenges = pgTable('daily_challenges', {
   650	  id: varchar('id').primaryKey().default(sql`gen_random_uuid()`),
   651	  walletAddress: text('wallet_address').notNull(),
   652	  dateKey: varchar('date_key', { length: 10 }).notNull(),
   653	  survivesCount: integer('survives_count').default(0).notNull(),
   654	  challengeCompleted: boolean('challenge_completed').default(false),
   655	  pointsAwarded: integer('points_awarded').default(0).notNull(),
   656	  highestStage: integer('highest_stage').default(1).notNull(),
   657	  highestWave: integer('highest_wave').default(1).notNull(),
   658	  gamesPlayed: integer('games_played').default(0).notNull(),
   659	  updatedAt: timestamp('updated_at').defaultNow().notNull(),
   660	}, (table) => [
/workspace/Dec_25_GRK_BC$ /bin/bash -lc nl -ba server/lib/oracleService.ts | sed -n '1,220p'
1	/**
     2	 * Guardian Oracle Service
     3	 * Server-side OpenRouter API integration for dynamic riddles
     4	 * API key is accessed from environment variables only - never exposed to client
     5	 */
     6	
     7	const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
     8	const MODEL = 'allenai/olmo-3.1-32b-think:free';
     9	
    10	const SYSTEM_PROMPT = `You are the Mind Warp Strategist, cunning Based Guardian NFT character in cyberpunk BasedAI L1. Present riddles (cyberpunk lore, humanitarian, NFT guardians, anti-inflation, governance). Natural conversation: Semantic evaluation (accept variations/synonyms/extra words). Hints on 'hint?'/'clue?' (lore, no spoil). Concise (<150 tokens), mysterious tone. Never break character. 33 riddles total, 30 correct to win (3 passes = failed). Track progress/state.`;
    11	
    12	interface OracleMessage {
    13	  role: 'system' | 'user' | 'assistant';
    14	  content: string;
    15	}
    16	
    17	interface OracleResponse {
    18	  success: boolean;
    19	  message: string;
    20	  isCorrect?: boolean;
    21	  isHint?: boolean;
    22	  riddleGenerated?: boolean;
    23	  error?: string;
    24	}
    25	
    26	function getApiKey(): string | null {
    27	  return process.env.OPENROUTER_API_KEY || null;
    28	}
    29	
    30	export async function callOracle(
    31	  messages: OracleMessage[],
    32	  requestType: 'generate_riddle' | 'evaluate_answer' | 'get_hint'
    33	): Promise<OracleResponse> {
    34	  const apiKey = getApiKey();
    35	  
    36	  if (!apiKey) {
    37	    console.error('[Oracle] OPENROUTER_API_KEY not configured');
    38	    return {
    39	      success: false,
    40	      message: 'Oracle service not configured',
    41	      error: 'API_KEY_MISSING'
    42	    };
    43	  }
    44	
    45	  const fullMessages: OracleMessage[] = [
    46	    { role: 'system', content: SYSTEM_PROMPT },
    47	    ...messages.slice(-10)
    48	  ];
    49	
    50	  try {
    51	    const controller = new AbortController();
    52	    const timeoutId = setTimeout(() => controller.abort(), 15000);
    53	
    54	    const response = await fetch(OPENROUTER_API_URL, {
    55	      method: 'POST',
    56	      headers: {
    57	        'Content-Type': 'application/json',
    58	        'Authorization': `Bearer ${apiKey}`,
    59	        'HTTP-Referer': process.env.REPLIT_DEV_DOMAIN 
    60	          ? `https://${process.env.REPLIT_DEV_DOMAIN}`
    61	          : 'https://based-guardians.repl.co',
    62	        'X-Title': 'Based Guardians Riddle Quest'
    63	      },
    64	      body: JSON.stringify({
    65	        model: MODEL,
    66	        messages: fullMessages,
    67	        max_tokens: 150,
    68	        temperature: 0.6,
    69	        top_p: 0.9
    70	      }),
    71	      signal: controller.signal
    72	    });
    73	
    74	    clearTimeout(timeoutId);
    75	
    76	    if (!response.ok) {
    77	      const errorText = await response.text().catch(() => 'Unknown error');
    78	      console.error(`[Oracle] API error ${response.status}: ${errorText}`);
    79	      
    80	      if (response.status === 429) {
    81	        return {
    82	          success: false,
    83	          message: 'The Oracle rests momentarily... standard trials resume.',
    84	          error: 'RATE_LIMITED'
    85	        };
    86	      }
    87	      
    88	      return {
    89	        success: false,
    90	        message: 'The Oracle\'s connection wavers...',
    91	        error: `HTTP_${response.status}`
    92	      };
    93	    }
    94	
    95	    const data = await response.json();
    96	    const content = data.choices?.[0]?.message?.content;
    97	
    98	    if (!content) {
    99	      console.error('[Oracle] Empty response from API');
   100	      return {
   101	        success: false,
   102	        message: 'The Oracle speaks in silence...',
   103	        error: 'EMPTY_RESPONSE'
   104	      };
   105	    }
   106	
   107	    let isCorrect = false;
   108	    let isHint = false;
   109	    let displayMessage = content.trim();
   110	    
   111	    console.log(`[Oracle] Raw response for ${requestType}: ${content.substring(0, 100)}...`);
   112	    
   113	    if (requestType === 'evaluate_answer') {
   114	      if (content.startsWith('[CORRECT]')) {
   115	        isCorrect = true;
   116	        displayMessage = content.replace('[CORRECT]', '').trim();
   117	        console.log('[Oracle] Semantic match: CORRECT');
   118	      } else if (content.startsWith('[INCORRECT]')) {
   119	        isCorrect = false;
   120	        displayMessage = content.replace('[INCORRECT]', '').trim();
   121	        console.log('[Oracle] Semantic match: INCORRECT');
   122	      } else if (content.startsWith('[HINT]')) {
   123	        isHint = true;
   124	        displayMessage = content.replace('[HINT]', '').trim();
   125	        console.log('[Oracle] Response type: HINT');
   126	      } else {
   127	        isCorrect = content.toLowerCase().includes('correct') || 
   128	          content.toLowerCase().includes('circuits align') ||
   129	          content.toLowerCase().includes('neural patterns match') ||
   130	          content.toLowerCase().includes('strategist approves') ||
   131	          content.toLowerCase().includes('wisdom') ||
   132	          content.toLowerCase().includes('well done');
   133	        console.log(`[Oracle] Fallback heuristic: ${isCorrect ? 'CORRECT' : 'INCORRECT'}`);
   134	      }
   135	    } else if (requestType === 'get_hint') {
   136	      if (content.startsWith('[HINT]')) {
   137	        displayMessage = content.replace('[HINT]', '').trim();
   138	      }
   139	      isHint = true;
   140	    }
   141	
   142	    return {
   143	      success: true,
   144	      message: displayMessage,
   145	      isCorrect,
   146	      isHint,
   147	      riddleGenerated: requestType === 'generate_riddle'
   148	    };
   149	
   150	  } catch (error: any) {
   151	    if (error.name === 'AbortError') {
   152	      console.error('[Oracle] Request timeout');
   153	      return {
   154	        success: false,
   155	        message: 'The Oracle\'s signal fades into the void...',
   156	        error: 'TIMEOUT'
   157	      };
   158	    }
   159	
   160	    console.error('[Oracle] Request failed:', error.message);
   161	    return {
   162	      success: false,
   163	      message: 'The Oracle retreats into the ether...',
   164	      error: 'NETWORK_ERROR'
   165	    };
   166	  }
   167	}
   168	
   169	export function generateRiddlePrompt(context: {
   170	  riddleNumber: number;
   171	  totalRiddles: number;
   172	  riddlesSolved: number;
   173	  passesUsed: number;
   174	}): string {
   175	  return `Riddle ${context.riddleNumber} of ${context.totalRiddles}. Progress: ${context.riddlesSolved} solved, ${context.passesUsed} passes. Present a fresh riddle only (no answer).`;
   176	}
   177	
   178	export function evaluateAnswerPrompt(riddle: string, userAnswer: string, expectedAnswer?: string): string {
   179	  const answerContext = expectedAnswer 
   180	    ? `The expected answer is: "${expectedAnswer}". `
   181	    : '';
   182	  return `${answerContext}The seeker answers the riddle: "${riddle}" with: "${userAnswer}". 
   183	
   184	IMPORTANT: Accept semantic variations! If the user's answer matches the meaning (ignoring case, punctuation, phrasing like "Is it X?" or "I think X"), mark as CORRECT.
   185	
   186	Respond starting with [CORRECT] or [INCORRECT] followed by your lore response.`;
   187	}
   188	
   189	export function getHintPrompt(riddle: string): string {
   190	  return `The seeker requests guidance for the riddle: "${riddle}". Provide a subtle, cryptic hint without revealing the answer directly. Keep it brief and lore-themed.`;
   191	}
/workspace/Dec_25_GRK_BC$ /bin/bash -lc nl -ba client/src/components/RiddleQuest.tsx | sed -n '1,240p'
1	import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
     2	import { useAccount } from 'wagmi';
     3	import { useConnectModal } from '@rainbow-me/rainbowkit';
     4	import { motion } from 'framer-motion';
     5	import { Bot, Send, ShieldCheck, ShieldAlert, RotateCcw, Loader2 } from 'lucide-react';
     6	import MindWarpStrategist from '@/assets/mind-warp-strategist.png';
     7	import { Button } from '@/components/ui/button';
     8	import { Input } from '@/components/ui/input';
     9	import { Badge } from '@/components/ui/badge';
    10	import { useGamePoints } from '@/hooks/useGamePoints';
    11	import { logActivity } from '@/hooks/useActivityHistory';
    12	import {
    13	  evaluateOracleAnswer,
    14	  generateOracleRiddle,
    15	  getOracleHint,
    16	  isQuestionOrHintRequest
    17	} from '@/lib/oracleClient';
    18	
    19	const TOTAL_RIDDLES = 33;
    20	const WIN_TARGET = 30;
    21	const MAX_PASSES = 3;
    22	const MAX_INTERACTIONS = 3;
    23	
    24	const LEGACY_KEYS = [
    25	  'oracleQuestions',
    26	  'riddleQuestLastPlayed',
    27	  'riddleQuestQuestionsUsed',
    28	  'riddle_quest_leaderboard'
    29	];
    30	
    31	type QuestState = 'idle' | 'playing' | 'won' | 'lost';
    32	
    33	type ChatMessage = {
    34	  id: string;
    35	  role: 'assistant' | 'user';
    36	  content: string;
    37	};
    38	
    39	interface QuestProgress {
    40	  dateKey: string;
    41	  riddlesSolved: number;
    42	  passesUsed: number;
    43	  interactions: number;
    44	}
    45	
    46	const getDateKey = () => new Date().toISOString().slice(0, 10);
    47	
    48	const createMessageId = () => `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    49	
    50	const getLocalProgressKey = (wallet: string) => `riddle_progress_${wallet.toLowerCase()}`;
    51	const getChallengeAwardedKey = (wallet: string, dateKey: string) => `riddle_progress_awarded_${wallet.toLowerCase()}_${dateKey}`;
    52	
    53	export function RiddleQuest() {
    54	  const { address, isConnected } = useAccount();
    55	  const { openConnectModal } = useConnectModal();
    56	  const { earnPoints } = useGamePoints();
    57	
    58	  const [questState, setQuestState] = useState<QuestState>('idle');
    59	  const [progress, setProgress] = useState<QuestProgress | null>(null);
    60	  const [canStartQuest, setCanStartQuest] = useState(true);
    61	  const [currentRiddle, setCurrentRiddle] = useState<string | null>(null);
    62	  const [messages, setMessages] = useState<ChatMessage[]>([]);
    63	  const [input, setInput] = useState('');
    64	  const [loading, setLoading] = useState(false);
    65	  const [errorMessage, setErrorMessage] = useState<string | null>(null);
    66	  const [retryAction, setRetryAction] = useState<(() => Promise<void>) | null>(null);
    67	
    68	  const messagesEndRef = useRef<HTMLDivElement | null>(null);
    69	  const isMountedRef = useRef(true);
    70	
    71	  useEffect(() => {
    72	    return () => {
    73	      isMountedRef.current = false;
    74	    };
    75	  }, []);
    76	
    77	  const totalAnswered = useMemo(() => {
    78	    if (!progress) return 0;
    79	    return progress.riddlesSolved + progress.passesUsed;
    80	  }, [progress]);
    81	
    82	  const interactionsRemaining = useMemo(() => {
    83	    if (!progress) return MAX_INTERACTIONS;
    84	    return Math.max(0, MAX_INTERACTIONS - progress.interactions);
    85	  }, [progress]);
    86	
    87	  const isQuestComplete = progress ? progress.riddlesSolved >= WIN_TARGET : false;
    88	  const isQuestFailed = progress ? progress.passesUsed >= MAX_PASSES || totalAnswered >= TOTAL_RIDDLES : false;
    89	  const canBeginQuest = canStartQuest || !!progress;
    90	
    91	  useEffect(() => {
    92	    if (!address) return;
    93	    LEGACY_KEYS.forEach((key) => localStorage.removeItem(key));
    94	    localStorage.removeItem(`riddle_quest_${address.toLowerCase()}`);
    95	    localStorage.removeItem(getLocalProgressKey(address));
    96	  }, [address]);
    97	
    98	  useEffect(() => {
    99	    if (!address) return;
   100	    const loadProgress = async () => {
   101	      const localKey = getLocalProgressKey(address);
   102	      const fallback = localStorage.getItem(localKey);
   103	      try {
   104	        const res = await fetch(`/api/riddle-quest/progress/${address}`);
   105	        if (!res.ok) {
   106	          throw new Error('Failed to fetch quest progress');
   107	        }
   108	        const data = await res.json();
   109	        const remoteProgress = data.progress as QuestProgress | null;
   110	        if (remoteProgress) {
   111	          setProgress(remoteProgress);
   112	          localStorage.setItem(localKey, JSON.stringify(remoteProgress));
   113	          setCanStartQuest(false);
   114	          return;
   115	        }
   116	        setProgress(null);
   117	        setCanStartQuest(data.canStart ?? true);
   118	      } catch (error) {
   119	        if (fallback) {
   120	          const parsed = JSON.parse(fallback) as QuestProgress;
   121	          setProgress(parsed);
   122	          setCanStartQuest(parsed.dateKey !== getDateKey());
   123	        } else {
   124	          setProgress(null);
   125	          setCanStartQuest(true);
   126	        }
   127	      }
   128	    };
   129	
   130	    loadProgress();
   131	  }, [address]);
   132	
   133	  useEffect(() => {
   134	    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
   135	  }, [messages, loading]);
   136	
   137	  useEffect(() => {
   138	    if (!progress) return;
   139	    if (progress.riddlesSolved >= WIN_TARGET) {
   140	      setQuestState('won');
   141	    } else if (progress.passesUsed >= MAX_PASSES || totalAnswered >= TOTAL_RIDDLES) {
   142	      setQuestState('lost');
   143	    }
   144	  }, [progress, totalAnswered]);
   145	
   146	  const persistProgress = useCallback(async (nextProgress: QuestProgress) => {
   147	    if (!address) return;
   148	    setProgress(nextProgress);
   149	    localStorage.setItem(getLocalProgressKey(address), JSON.stringify(nextProgress));
   150	    try {
   151	      await fetch('/api/riddle-quest/progress', {
   152	        method: 'POST',
   153	        headers: { 'Content-Type': 'application/json' },
   154	        body: JSON.stringify({
   155	          walletAddress: address,
   156	          dateKey: nextProgress.dateKey,
   157	          riddlesSolved: nextProgress.riddlesSolved,
   158	          passesUsed: nextProgress.passesUsed,
   159	          interactions: nextProgress.interactions
   160	        })
   161	      });
   162	    } catch (error) {
   163	      console.warn('[RiddleQuest] Failed to persist progress:', error);
   164	    }
   165	  }, [address]);
   166	
   167	  const addUserMessage = useCallback((content: string) => {
   168	    setMessages((prev) => [...prev, { id: createMessageId(), role: 'user', content }]);
   169	  }, []);
   170	
   171	  const addAssistantMessage = useCallback(async (content: string) => {
   172	    const id = createMessageId();
   173	    setMessages((prev) => [...prev, { id, role: 'assistant', content: '' }]);
   174	    for (const char of content) {
   175	      if (!isMountedRef.current) return;
   176	      await new Promise((resolve) => setTimeout(resolve, 50));
   177	      setMessages((prev) =>
   178	        prev.map((message) =>
   179	          message.id === id
   180	            ? { ...message, content: message.content + char }
   181	            : message
   182	        )
   183	      );
   184	    }
   185	  }, []);
   186	
   187	  const fetchRiddle = useCallback(async (currentProgress: QuestProgress) => {
   188	    setLoading(true);
   189	    setErrorMessage(null);
   190	    const riddleNumber = currentProgress.riddlesSolved + currentProgress.passesUsed + 1;
   191	
   192	    const result = await generateOracleRiddle(
   193	      riddleNumber,
   194	      TOTAL_RIDDLES,
   195	      currentProgress.riddlesSolved,
   196	      currentProgress.passesUsed
   197	    );
   198	
   199	    if (!result.success || !result.message) {
   200	      setErrorMessage('Strategist scheming...');
   201	      setRetryAction(() => async () => fetchRiddle(currentProgress));
   202	      setLoading(false);
   203	      return;
   204	    }
   205	
   206	    setCurrentRiddle(result.message);
   207	    await addAssistantMessage(result.message);
   208	    setLoading(false);
   209	  }, [addAssistantMessage]);
   210	
   211	  const startQuest = async () => {
   212	    if (!address) return;
   213	    setLoading(true);
   214	    setMessages([]);
   215	    setCurrentRiddle(null);
   216	    setErrorMessage(null);
   217	    setRetryAction(null);
   218	    localStorage.removeItem(getLocalProgressKey(address));
   219	
   220	    try {
   221	      const response = await fetch('/api/riddle-quest/start', {
   222	        method: 'POST',
   223	        headers: { 'Content-Type': 'application/json' },
   224	        body: JSON.stringify({ walletAddress: address })
   225	      });
   226	
   227	      if (!response.ok) {
   228	        throw new Error('Failed to start quest');
   229	      }
   230	
   231	      const data = await response.json();
   232	      const nextProgress: QuestProgress = {
   233	        dateKey: data.dateKey || getDateKey(),
   234	        riddlesSolved: data.progress?.riddlesSolved ?? 0,
   235	        passesUsed: data.progress?.passesUsed ?? 0,
   236	        interactions: data.progress?.interactions ?? 0
   237	      };
   238	
   239	      setQuestState('playing');
   240	      await persistProgress(nextProgress);
/workspace/Dec_25_GRK_BC$ /bin/bash -lc nl -ba client/src/lib/oracleClient.ts | sed -n '1,220p'
1	/**
     2	 * Mind Warp Strategist Client
     3	 * Client-side service for Oracle API calls only.
     4	 */
     5	
     6	interface OracleResponse {
     7	  success: boolean;
     8	  message: string;
     9	  isCorrect?: boolean;
    10	  isHint?: boolean;
    11	  riddleGenerated?: boolean;
    12	  error?: string;
    13	}
    14	
    15	const QUESTION_PATTERNS = [
    16	  /^(what|who|where|when|why|how|which|is it|can you|could you|tell me|give me)/i,
    17	  /\?$/,
    18	  /hint/i,
    19	  /help/i,
    20	  /clue/i,
    21	];
    22	
    23	export function isQuestionOrHintRequest(input: string): boolean {
    24	  const trimmed = input.trim();
    25	  return QUESTION_PATTERNS.some(pattern => pattern.test(trimmed));
    26	}
    27	
    28	export function normalizeAnswer(input: string): string {
    29	  return input
    30	    .toLowerCase()
    31	    .replace(/^(is it|it's|i think|maybe|the answer is|it is)\s*/i, '')
    32	    .replace(/[?!.,;:'"]/g, '')
    33	    .trim();
    34	}
    35	
    36	export async function callOracleAPI(
    37	  action: 'generate_riddle' | 'evaluate_answer' | 'get_hint',
    38	  params: {
    39	    riddleNumber?: number;
    40	    totalRiddles?: number;
    41	    riddlesSolved?: number;
    42	    passesUsed?: number;
    43	    riddle?: string;
    44	    userAnswer?: string;
    45	    messages?: Array<{ role: string; content: string }>;
    46	  }
    47	): Promise<OracleResponse> {
    48	  try {
    49	    const response = await fetch('/api/oracle', {
    50	      method: 'POST',
    51	      headers: {
    52	        'Content-Type': 'application/json'
    53	      },
    54	      body: JSON.stringify({
    55	        action,
    56	        ...params
    57	      })
    58	    });
    59	
    60	    if (!response.ok) {
    61	      const errorData = await response.json().catch(() => ({}));
    62	      return {
    63	        success: false,
    64	        message: errorData.message || "The Oracle's connection wavers...",
    65	        error: errorData.error || `HTTP_${response.status}`
    66	      };
    67	    }
    68	
    69	    const data = await response.json();
    70	    return data;
    71	  } catch (error: any) {
    72	    console.error('[OracleClient] API error:', error.message);
    73	    return {
    74	      success: false,
    75	      message: "The Oracle's signal fades into the void...",
    76	      error: 'NETWORK_ERROR'
    77	    };
    78	  }
    79	}
    80	
    81	export async function generateOracleRiddle(
    82	  riddleNumber: number,
    83	  totalRiddles: number,
    84	  riddlesSolved: number,
    85	  passesUsed: number
    86	): Promise<OracleResponse> {
    87	  return callOracleAPI('generate_riddle', { riddleNumber, totalRiddles, riddlesSolved, passesUsed });
    88	}
    89	
    90	export async function evaluateOracleAnswer(
    91	  riddle: string,
    92	  userAnswer: string,
    93	  conversationHistory: Array<{ role: string; content: string }> = []
    94	): Promise<OracleResponse> {
    95	  return callOracleAPI('evaluate_answer', { riddle, userAnswer, messages: conversationHistory });
    96	}
    97	
    98	export async function getOracleHint(
    99	  riddle: string,
   100	  conversationHistory: Array<{ role: string; content: string }> = []
   101	): Promise<OracleResponse> {
   102	  return callOracleAPI('get_hint', { riddle, messages: conversationHistory });
   103	}
/workspace/Dec_25_GRK_BC$ /bin/bash -lc nl -ba server/routes.ts | sed -n '1180,1540p'
1180	      return res.json(leaderboard);
  1181	    } catch (error) {
  1182	      console.error("[Game] Error fetching leaderboard:", error);
  1183	      return res.status(500).json({ error: "Failed to fetch leaderboard" });
  1184	    }
  1185	  });
  1186	
  1187	  app.get("/api/game/stats/:wallet", async (req, res) => {
  1188	    try {
  1189	      const stats = await storage.getPlayerGameStats(req.params.wallet);
  1190	      if (!stats) {
  1191	        return res.json({ exists: false, stats: null });
  1192	      }
  1193	      return res.json({ exists: true, stats });
  1194	    } catch (error) {
  1195	      console.error("[Game] Error fetching player stats:", error);
  1196	      return res.status(500).json({ error: "Failed to fetch player stats" });
  1197	    }
  1198	  });
  1199	
  1200	  // Mind Warp Strategist API Endpoint for Riddle Quest
  1201	  app.post("/api/oracle", gameLimiter, async (req, res) => {
  1202	    try {
  1203	      const { action, riddle, userAnswer, messages, riddleNumber, totalRiddles, riddlesSolved, passesUsed } = req.body;
  1204	
  1205	      if (!action || !['generate_riddle', 'evaluate_answer', 'get_hint'].includes(action)) {
  1206	        return res.status(400).json({ error: "Invalid action" });
  1207	      }
  1208	
  1209	      let promptMessages: Array<{ role: 'user' | 'assistant'; content: string }> = [];
  1210	
  1211	      if (action === 'generate_riddle') {
  1212	        const prompt = generateRiddlePrompt({
  1213	          riddleNumber: typeof riddleNumber === 'number' ? riddleNumber : 1,
  1214	          totalRiddles: typeof totalRiddles === 'number' ? totalRiddles : 33,
  1215	          riddlesSolved: typeof riddlesSolved === 'number' ? riddlesSolved : 0,
  1216	          passesUsed: typeof passesUsed === 'number' ? passesUsed : 0
  1217	        });
  1218	        promptMessages = [{ role: 'user', content: prompt }];
  1219	      } else if (action === 'evaluate_answer') {
  1220	        if (!riddle || !userAnswer) {
  1221	          return res.status(400).json({ error: "riddle and userAnswer required" });
  1222	        }
  1223	        const prompt = evaluateAnswerPrompt(riddle, userAnswer);
  1224	        promptMessages = Array.isArray(messages) ? [...messages.slice(-6), { role: 'user', content: prompt }] : [{ role: 'user', content: prompt }];
  1225	      } else if (action === 'get_hint') {
  1226	        if (!riddle) {
  1227	          return res.status(400).json({ error: "riddle required" });
  1228	        }
  1229	        const prompt = getHintPrompt(riddle);
  1230	        promptMessages = Array.isArray(messages) ? [...messages.slice(-6), { role: 'user', content: prompt }] : [{ role: 'user', content: prompt }];
  1231	      }
  1232	
  1233	      const result = await callOracle(promptMessages, action as any);
  1234	      
  1235	      if (!result.success) {
  1236	        console.warn(`[Mind Warp Strategist] API call failed: ${result.error}`);
  1237	        return res.status(503).json({
  1238	          success: false,
  1239	          fallback: true,
  1240	          message: "Mind Warp Strategist is scheming... Riddles are baking, return soon.",
  1241	          error: result.error
  1242	        });
  1243	      }
  1244	
  1245	      return res.json({
  1246	        success: true,
  1247	        message: result.message,
  1248	        isCorrect: result.isCorrect,
  1249	        isHint: result.isHint,
  1250	        riddleGenerated: result.riddleGenerated
  1251	      });
  1252	    } catch (error) {
  1253	      console.error("[Mind Warp Strategist] Endpoint error:", error);
  1254	      return res.status(500).json({
  1255	        success: false,
  1256	        fallback: true,
  1257	        message: "Mind Warp Strategist is scheming... Riddles are baking, return soon.",
  1258	        error: "INTERNAL_ERROR"
  1259	      });
  1260	    }
  1261	  });
  1262	
  1263	  // ============================================
  1264	  // RIDDLE QUEST LEADERBOARD & DAILY CHALLENGES
  1265	  // ============================================
  1266	
  1267	  // Mind Warp Strategist quest progress (24h limit)
  1268	  app.get("/api/riddle-quest/progress/:wallet", async (req, res) => {
  1269	    try {
  1270	      const { wallet } = req.params;
  1271	      if (!wallet || !isValidEthAddress(wallet)) {
  1272	        return res.status(400).json({ error: "Valid wallet address required" });
  1273	      }
  1274	
  1275	      const dateKey = new Date().toISOString().slice(0, 10);
  1276	      const progress = await storage.getRiddleProgress(wallet, dateKey);
  1277	      const latest = await storage.getLatestRiddleProgress(wallet);
  1278	      const canStart = !latest || latest.dateKey !== dateKey;
  1279	
  1280	      return res.json({
  1281	        dateKey,
  1282	        canStart,
  1283	        progress: progress || null
  1284	      });
  1285	    } catch (error) {
  1286	      console.error("[RiddleQuest] Error fetching progress:", error);
  1287	      return res.status(500).json({ error: "Failed to fetch quest progress" });
  1288	    }
  1289	  });
  1290	
  1291	  app.post("/api/riddle-quest/start", async (req, res) => {
  1292	    try {
  1293	      const { walletAddress } = req.body;
  1294	      if (!walletAddress || !isValidEthAddress(walletAddress)) {
  1295	        return res.status(400).json({ error: "Valid walletAddress required" });
  1296	      }
  1297	
  1298	      const dateKey = new Date().toISOString().slice(0, 10);
  1299	      const existing = await storage.getRiddleProgress(walletAddress, dateKey);
  1300	      if (existing) {
  1301	        return res.json({ progress: existing, dateKey });
  1302	      }
  1303	
  1304	      const progress = await storage.upsertRiddleProgress({
  1305	        walletAddress,
  1306	        dateKey,
  1307	        riddlesSolved: 0,
  1308	        passesUsed: 0,
  1309	        interactions: 0
  1310	      });
  1311	
  1312	      return res.json({ progress, dateKey });
  1313	    } catch (error) {
  1314	      console.error("[RiddleQuest] Error starting quest:", error);
  1315	      return res.status(500).json({ error: "Failed to start quest" });
  1316	    }
  1317	  });
  1318	
  1319	  app.post("/api/riddle-quest/progress", async (req, res) => {
  1320	    try {
  1321	      const { walletAddress, riddlesSolved, passesUsed, interactions, dateKey } = req.body;
  1322	      if (!walletAddress || !isValidEthAddress(walletAddress)) {
  1323	        return res.status(400).json({ error: "Valid walletAddress required" });
  1324	      }
  1325	
  1326	      const normalizedDate = typeof dateKey === 'string' && dateKey.length === 10
  1327	        ? dateKey
  1328	        : new Date().toISOString().slice(0, 10);
  1329	
  1330	      const progress = await storage.upsertRiddleProgress({
  1331	        walletAddress,
  1332	        dateKey: normalizedDate,
  1333	        riddlesSolved: Math.max(0, Number(riddlesSolved) || 0),
  1334	        passesUsed: Math.max(0, Number(passesUsed) || 0),
  1335	        interactions: Math.max(0, Number(interactions) || 0)
  1336	      });
  1337	
  1338	      return res.json({ progress });
  1339	    } catch (error) {
  1340	      console.error("[RiddleQuest] Error updating progress:", error);
  1341	      return res.status(500).json({ error: "Failed to update quest progress" });
  1342	    }
  1343	  });
  1344	
  1345	  // Get riddle quest leaderboard
  1346	  app.get("/api/riddle-quest/leaderboard", async (req, res) => {
  1347	    try {
  1348	      const limit = Math.min(100, Math.max(1, parseInt(req.query.limit as string) || 50));
  1349	      const leaderboard = await storage.getRiddleLeaderboard(limit);
  1350	      return res.json(leaderboard);
  1351	    } catch (error) {
  1352	      console.error("[RiddleQuest] Error fetching leaderboard:", error);
  1353	      return res.status(500).json({ error: "Failed to fetch leaderboard" });
  1354	    }
  1355	  });
  1356	
  1357	  // Get player's riddle stats
  1358	  app.get("/api/riddle-quest/stats/:wallet", async (req, res) => {
  1359	    try {
  1360	      const entry = await storage.getRiddleLeaderboardEntry(req.params.wallet);
  1361	      if (!entry) {
  1362	        return res.json({ exists: false, stats: null });
  1363	      }
  1364	      return res.json({ exists: true, stats: entry });
  1365	    } catch (error) {
  1366	      console.error("[RiddleQuest] Error fetching stats:", error);
  1367	      return res.status(500).json({ error: "Failed to fetch stats" });
  1368	    }
  1369	  });
  1370	
  1371	  // Get today's daily challenge set
  1372	  app.get("/api/riddle-quest/daily", async (req, res) => {
  1373	    try {
  1374	      const dateKey = new Date().toISOString().slice(0, 10);
  1375	      let set = await storage.getDailySet(dateKey);
  1376	      
  1377	      if (!set) {
  1378	        set = await generateDailyRiddleSet(dateKey);
  1379	      }
  1380	      
  1381	      const entries = await storage.getDailyEntries(set.id);
  1382	      
  1383	      return res.json({
  1384	        dateKey,
  1385	        setId: set.id,
  1386	        generatedViaOracle: set.generatedViaOracle,
  1387	        riddleCount: entries.length,
  1388	        riddles: entries.map(e => ({
  1389	          id: e.id,
  1390	          index: e.riddleIndex,
  1391	          question: e.question,
  1392	          hint: e.hint,
  1393	          difficulty: e.difficulty,
  1394	          theme: e.theme,
  1395	          isOracle: e.isOracle
  1396	        }))
  1397	      });
  1398	    } catch (error) {
  1399	      console.error("[RiddleQuest] Error fetching daily set:", error);
  1400	      return res.status(500).json({ error: "Failed to fetch daily challenges" });
  1401	    }
  1402	  });
  1403	
  1404	  // Get user's progress on today's daily challenges
  1405	  app.get("/api/riddle-quest/daily/progress/:wallet", async (req, res) => {
  1406	    try {
  1407	      const dateKey = new Date().toISOString().slice(0, 10);
  1408	      const progress = await storage.getUserDailyProgress(req.params.wallet, dateKey);
  1409	      return res.json({
  1410	        dateKey,
  1411	        attempts: progress,
  1412	        solved: progress.filter(a => a.solved).length,
  1413	        total: progress.length
  1414	      });
  1415	    } catch (error) {
  1416	      console.error("[RiddleQuest] Error fetching progress:", error);
  1417	      return res.status(500).json({ error: "Failed to fetch progress" });
  1418	    }
  1419	  });
  1420	
  1421	  // Submit an answer for a daily riddle
  1422	  app.post("/api/riddle-quest/attempt", gameLimiter, async (req, res) => {
  1423	    try {
  1424	      const { walletAddress, riddleEntryId, answer, solveTimeMs, isOracle } = req.body;
  1425	      
  1426	      if (!walletAddress || !riddleEntryId || !answer) {
  1427	        return res.status(400).json({ error: "walletAddress, riddleEntryId, and answer required" });
  1428	      }
  1429	      
  1430	      const dateKey = new Date().toISOString().slice(0, 10);
  1431	      
  1432	      const existingAttempt = await storage.getRiddleAttempt(walletAddress, riddleEntryId);
  1433	      if (existingAttempt?.solved) {
  1434	        return res.json({
  1435	          success: true,
  1436	          alreadySolved: true,
  1437	          message: "You've already solved this riddle!"
  1438	        });
  1439	      }
  1440	      
  1441	      const entries = await storage.getDailyEntries(
  1442	        (await storage.getDailySet(dateKey))?.id || 0
  1443	      );
  1444	      const entry = entries.find(e => e.id === riddleEntryId);
  1445	      
  1446	      if (!entry) {
  1447	        return res.status(404).json({ error: "Riddle not found" });
  1448	      }
  1449	      
  1450	      let isCorrect = false;
  1451	      if (entry.isOracle) {
  1452	        const oracleResult = await callOracle(
  1453	          [{ role: 'user', content: evaluateAnswerPrompt(entry.question, answer) }],
  1454	          'evaluate_answer'
  1455	        );
  1456	        if (!oracleResult.success) {
  1457	          return res.status(503).json({
  1458	            error: 'Oracle evaluation unavailable',
  1459	            message: 'Mind Warp Strategist is scheming...'
  1460	          });
  1461	        }
  1462	        isCorrect = !!oracleResult.isCorrect;
  1463	      } else {
  1464	        const acceptedAnswers = entry.answers.toLowerCase().split('|').map(a => a.trim());
  1465	
  1466	        const normalizeForMatch = (input: string): string => {
  1467	          return input
  1468	            .toLowerCase()
  1469	            .replace(/^(is it|it's|i think|maybe|the answer is|it is|could it be|i believe|my answer is)\s*/i, '')
  1470	            .replace(/[?!.,;:'"$@#%^&*(){}[\]<>\/\\|`~]/g, '')
  1471	            .replace(/\s+/g, ' ')
  1472	            .trim();
  1473	        };
  1474	
  1475	        const userNormalized = normalizeForMatch(answer);
  1476	
  1477	        isCorrect = acceptedAnswers.some(expectedAnswer => {
  1478	          const expectedNormalized = normalizeForMatch(expectedAnswer);
  1479	          return userNormalized === expectedNormalized ||
  1480	            userNormalized.includes(expectedNormalized) ||
  1481	            expectedNormalized.includes(userNormalized) ||
  1482	            (userNormalized.length > 2 && expectedNormalized.startsWith(userNormalized)) ||
  1483	            (expectedNormalized.length > 2 && userNormalized.startsWith(expectedNormalized));
  1484	        });
  1485	      }
  1486	      
  1487	      const basePoints = isOracle ? 150 : 100;
  1488	      const timeBonus = solveTimeMs && solveTimeMs < 30000 ? 50 : (solveTimeMs && solveTimeMs < 60000 ? 25 : 0);
  1489	      const pointsEarned = isCorrect ? basePoints + timeBonus : 0;
  1490	      
  1491	      if (existingAttempt) {
  1492	        await storage.updateRiddleAttempt(
  1493	          existingAttempt.id,
  1494	          isCorrect,
  1495	          solveTimeMs || 0,
  1496	          pointsEarned
  1497	        );
  1498	      } else {
  1499	        await storage.createRiddleAttempt({
  1500	          walletAddress,
  1501	          riddleEntryId,
  1502	          dateKey,
  1503	          attemptCount: 1,
  1504	          solved: isCorrect,
  1505	          solveTimeMs: isCorrect ? solveTimeMs : undefined,
  1506	          pointsEarned
  1507	        });
  1508	      }
  1509	      
  1510	      if (isCorrect) {
  1511	        await storage.updateRiddleLeaderboardStats(
  1512	          walletAddress,
  1513	          pointsEarned,
  1514	          true,
  1515	          solveTimeMs
  1516	        );
  1517	      }
  1518	      
  1519	      return res.json({
  1520	        success: true,
  1521	        isCorrect,
  1522	        pointsEarned,
  1523	        message: isCorrect 
  1524	          ? "Correct! The Oracle acknowledges your wisdom." 
  1525	          : "Not quite right. The Oracle awaits your next attempt..."
  1526	      });
  1527	    } catch (error) {
  1528	      console.error("[RiddleQuest] Error processing attempt:", error);
  1529	      return res.status(500).json({ error: "Failed to process attempt" });
  1530	    }
  1531	  });
  1532	
  1533	  // Price Proxy Endpoint (avoids CORS issues with CoinGecko)
  1534	  app.get("/api/price/basedai", async (req, res) => {
  1535	    try {
  1536	      const controller = new AbortController();
  1537	      const timeoutId = setTimeout(() => controller.abort(), 8000);
  1538	      
  1539	      const response = await fetch(
  1540	        "https://api.coingecko.com/api/v3/simple/price?ids=basedai&vs_currencies=usd&include_24hr_change=true",
/workspace/Dec_25_GRK_BC$ /bin/bash -lc nl -ba server/routes.ts | sed -n '160,520p'
160	
   161	    if (!(await verifyAdminSignature(walletAddress, signature))) {
   162	      return res.status(401).json({ error: "Invalid or expired signature" });
   163	    }
   164	    
   165	    next();
   166	  } catch (error) {
   167	    console.error('[Admin Auth] Error during authentication:', error);
   168	    return res.status(500).json({ error: "Authentication service temporarily unavailable" });
   169	  }
   170	}
   171	
   172	async function generateDailyRiddleSet(dateKey: string) {
   173	  console.log(`[RiddleQuest] Generating daily set for ${dateKey}`);
   174	
   175	  const set = await storage.createDailySet({
   176	    dateKey,
   177	    generatedViaOracle: true,
   178	    riddleCount: 5
   179	  });
   180	
   181	  const difficulties = ['easy', 'medium', 'medium', 'hard', 'hard'];
   182	  for (let i = 0; i < 5; i++) {
   183	    const result = await callOracle(
   184	      [{
   185	        role: 'user',
   186	        content: generateRiddlePrompt({
   187	          riddleNumber: i + 1,
   188	          totalRiddles: 5,
   189	          riddlesSolved: 0,
   190	          passesUsed: 0
   191	        })
   192	      }],
   193	      'generate_riddle'
   194	    );
   195	
   196	    if (!result.success || !result.message) {
   197	      throw new Error('ORACLE_DAILY_RIDDLE_FAILED');
   198	    }
   199	
   200	    await storage.createDailyEntry({
   201	      setId: set.id,
   202	      riddleIndex: i,
   203	      question: result.message,
   204	      answers: '',
   205	      hint: undefined,
   206	      difficulty: difficulties[i],
   207	      theme: 'oracle',
   208	      isOracle: true
   209	    });
   210	  }
   211	
   212	  console.log(`[RiddleQuest] Created daily set ${set.id} with 5 riddles (oracle only)`);
   213	  return set;
   214	}
   215	
   216	export async function registerRoutes(
   217	  httpServer: Server,
   218	  app: Express
   219	): Promise<Server> {
   220	  // Note: SQL injection protection is provided by Drizzle ORM's parameterized queries
   221	  // The sqlInjectionGuard middleware is available for specific high-risk endpoints but
   222	  // not applied globally to avoid false positives on legitimate content
   223	
   224	  // Health check endpoint - must respond immediately for deployment health checks
   225	  app.get("/api/health", (_req, res) => {
   226	    res.status(200).json({ status: "ok", timestamp: Date.now() });
   227	  });
   228	
   229	  // Database health check endpoint
   230	  app.get('/api/health/database', async (_req, res) => {
   231	    try {
   232	      const dbConn = SecureDatabaseConnection.getInstance();
   233	      const healthy = await dbConn.healthCheck();
   234	      const stats = await dbConn.getConnectionStats();
   235	      
   236	      res.json({
   237	        healthy,
   238	        stats,
   239	        timestamp: new Date().toISOString()
   240	      });
   241	    } catch (error: any) {
   242	      res.status(500).json({
   243	        healthy: false,
   244	        error: error.message
   245	      });
   246	    }
   247	  });
   248	
   249	  // Financial health check endpoint - validates calculation systems
   250	  app.get("/api/health/financial", async (_req, res) => {
   251	    try {
   252	      const checks = {
   253	        safeMath: true,
   254	        mintCalculations: true,
   255	        feeCalculations: true,
   256	        timestamp: new Date().toISOString()
   257	      };
   258	      
   259	      // Basic SafeMath validation
   260	      const testWei = BigInt("1000000000000000000");
   261	      const testAdd = testWei + testWei;
   262	      checks.safeMath = testAdd === BigInt("2000000000000000000");
   263	      
   264	      // Mint price validation (69420 BASED)
   265	      const mintPrice = BigInt("69420000000000000000000");
   266	      checks.mintCalculations = mintPrice > BigInt(0);
   267	      
   268	      // Fee calculation validation (1% + 10% = 11% total)
   269	      const salePrice = BigInt("100000000000000000000");
   270	      const platformFee = (salePrice * BigInt(100)) / BigInt(10000);
   271	      const royaltyFee = (salePrice * BigInt(1000)) / BigInt(10000);
   272	      checks.feeCalculations = platformFee + royaltyFee === BigInt("11000000000000000000");
   273	      
   274	      const healthy = checks.safeMath && checks.mintCalculations && checks.feeCalculations;
   275	      
   276	      res.json({ healthy, checks });
   277	    } catch (error: any) {
   278	      res.status(500).json({ healthy: false, error: error.message });
   279	    }
   280	  });
   281	
   282	  // Activity Feed API - Server-side cached blockchain activity
   283	  app.get("/api/activity", async (_req, res) => {
   284	    try {
   285	      const activity = await getActivityData();
   286	      res.json(activity);
   287	    } catch (error: any) {
   288	      console.error('[API] Activity fetch error:', error);
   289	      res.status(500).json({ 
   290	        error: error.message || 'Failed to fetch activity',
   291	        activities: [],
   292	        stats: { totalMinted: 0, recentMints: 0, totalSales: 0, totalListings: 0, totalTransfers: 0, recentVolume: 0 },
   293	        lastBlock: 0,
   294	        lastUpdated: Date.now()
   295	      });
   296	    }
   297	  });
   298	
   299	  // Activity cache status (for debugging)
   300	  app.get("/api/activity/status", (_req, res) => {
   301	    res.json(getCacheStatus());
   302	  });
   303	
   304	  // Apply IP ban guard to all API routes (except health checks)
   305	  app.use('/api/*', (req, res, next) => {
   306	    if (req.path === '/api/health' || req.path.startsWith('/api/health/')) {
   307	      return next();
   308	    }
   309	    return ipBanGuard(req, res, next);
   310	  });
   311	
   312	  // Apply read limiter to GET requests
   313	  app.use('/api/*', (req, res, next) => {
   314	    if (req.method === 'GET') {
   315	      return readLimiter(req, res, next);
   316	    }
   317	    next();
   318	  });
   319	
   320	  // Admin auth nonce endpoint - get a nonce for signing
   321	  app.post("/api/admin/nonce", authLimiter, async (req, res) => {
   322	    try {
   323	      const { walletAddress } = req.body;
   324	      
   325	      if (!walletAddress || !isValidEthAddress(walletAddress)) {
   326	        return res.status(400).json({ error: "Valid wallet address required" });
   327	      }
   328	      
   329	      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
   330	        return res.status(403).json({ error: "Not an admin wallet" });
   331	      }
   332	      
   333	      const nonce = await generateAdminNonce(walletAddress);
   334	      const message = `Based Guardians Admin Auth\nNonce: ${nonce}`;
   335	      
   336	      return res.json({ 
   337	        nonce, 
   338	        message,
   339	        expiresIn: NONCE_EXPIRY_MS / 1000 
   340	      });
   341	    } catch (error) {
   342	      console.error("[Admin] Error generating nonce:", error);
   343	      return res.status(500).json({ error: "Failed to generate nonce" });
   344	    }
   345	  });
   346	
   347	  // Admin password authentication endpoints
   348	  app.get('/api/admin/auth/status/:walletAddress', async (req, res) => {
   349	    try {
   350	      const { walletAddress } = req.params;
   351	      if (!isValidEthAddress(walletAddress)) {
   352	        return res.status(400).json({ error: 'Invalid wallet address' });
   353	      }
   354	      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
   355	        return res.status(403).json({ error: 'Not an admin wallet' });
   356	      }
   357	      const status = await AdminAuthService.checkIfLocked(walletAddress);
   358	      res.json(status);
   359	    } catch (error) {
   360	      console.error('Error checking admin lock status:', error);
   361	      res.status(500).json({ error: 'Failed to check status' });
   362	    }
   363	  });
   364	
   365	  app.post('/api/admin/auth/verify', authLimiter, async (req, res) => {
   366	    try {
   367	      const { walletAddress, password } = req.body;
   368	      if (!walletAddress || !password) {
   369	        return res.status(400).json({ error: 'Wallet address and password required' });
   370	      }
   371	      if (!isValidEthAddress(walletAddress)) {
   372	        return res.status(400).json({ error: 'Invalid wallet address' });
   373	      }
   374	      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
   375	        return res.status(403).json({ error: 'Not an admin wallet' });
   376	      }
   377	      const result = await AdminAuthService.verifyPassword(walletAddress, password);
   378	      if (result.success) {
   379	        res.json(result);
   380	      } else {
   381	        res.status(401).json(result);
   382	      }
   383	    } catch (error) {
   384	      console.error('Error verifying admin password:', error);
   385	      res.status(500).json({ error: 'Verification failed' });
   386	    }
   387	  });
   388	
   389	  app.get('/api/admin/auth/locked', authLimiter, async (req, res) => {
   390	    try {
   391	      const walletAddress = req.headers['x-wallet-address'] as string;
   392	      if (!walletAddress || !isValidEthAddress(walletAddress)) {
   393	        return res.status(400).json({ error: 'Valid wallet address required' });
   394	      }
   395	      if (!ADMIN_WALLETS.includes(walletAddress.toLowerCase())) {
   396	        return res.status(403).json({ error: 'Not an admin wallet' });
   397	      }
   398	      const locked = await AdminAuthService.getAllLockedWallets();
   399	      res.json(locked);
   400	    } catch (error) {
   401	      console.error('Error fetching locked wallets:', error);
   402	      res.status(500).json({ error: 'Failed to fetch locked wallets' });
   403	    }
   404	  });
   405	
   406	  // Session-based authentication endpoints
   407	  app.post('/api/auth/nonce', authLimiter, async (req, res) => {
   408	    try {
   409	      const { walletAddress } = req.body;
   410	      
   411	      if (!walletAddress || !isValidEthAddress(walletAddress)) {
   412	        return res.status(400).json({ error: 'Invalid wallet address' });
   413	      }
   414	      
   415	      const nonce = NonceManager.createNonce(walletAddress);
   416	      const message = SignatureVerifier.createSignInMessage(walletAddress, nonce);
   417	      
   418	      res.json({ nonce, message });
   419	    } catch (error: any) {
   420	      res.status(500).json({ error: error.message });
   421	    }
   422	  });
   423	
   424	  app.post('/api/auth/verify', authLimiter, async (req, res) => {
   425	    try {
   426	      const { walletAddress, signature, message, nonce } = req.body;
   427	      
   428	      if (!walletAddress || !signature || !message || !nonce) {
   429	        return res.status(400).json({ error: 'Missing required fields' });
   430	      }
   431	      
   432	      if (!SignatureVerifier.verifyMessageAge(message, 5)) {
   433	        return res.status(400).json({ error: 'Message expired' });
   434	      }
   435	      
   436	      if (!NonceManager.validateNonce(nonce, walletAddress)) {
   437	        return res.status(400).json({ error: 'Invalid or expired nonce' });
   438	      }
   439	      
   440	      if (!SignatureVerifier.verifySignature(message, signature, walletAddress)) {
   441	        return res.status(401).json({ error: 'Invalid signature' });
   442	      }
   443	      
   444	      const ipAddress = req.ip || 'unknown';
   445	      const userAgent = req.get('user-agent') || 'unknown';
   446	      const isAdmin = ADMIN_WALLETS.includes(walletAddress.toLowerCase());
   447	      
   448	      const sessionId = SessionManager.createSession(walletAddress, ipAddress, userAgent, isAdmin);
   449	      
   450	      res.json({ 
   451	        sessionId,
   452	        walletAddress,
   453	        isAdmin,
   454	        expiresIn: 24 * 60 * 60 * 1000
   455	      });
   456	    } catch (error: any) {
   457	      res.status(500).json({ error: error.message });
   458	    }
   459	  });
   460	
   461	  app.post('/api/auth/refresh', requireAuth, async (req: AuthRequest, res) => {
   462	    try {
   463	      const sessionId = req.session!.id;
   464	      const refreshed = SessionManager.refreshSession(sessionId);
   465	      
   466	      if (!refreshed) {
   467	        return res.status(401).json({ error: 'Failed to refresh session' });
   468	      }
   469	      
   470	      res.json({ success: true, expiresIn: 24 * 60 * 60 * 1000 });
   471	    } catch (error: any) {
   472	      res.status(500).json({ error: error.message });
   473	    }
   474	  });
   475	
   476	  app.post('/api/auth/logout', requireAuth, async (req: AuthRequest, res) => {
   477	    try {
   478	      SessionManager.destroySession(req.session!.id);
   479	      res.json({ success: true });
   480	    } catch (error: any) {
   481	      res.status(500).json({ error: error.message });
   482	    }
   483	  });
   484	
   485	  app.get('/api/auth/sessions', requireAuth, async (req: AuthRequest, res) => {
   486	    try {
   487	      const sessions = SessionManager.getUserSessions(req.session!.walletAddress);
   488	      res.json({ 
   489	        sessions: sessions.map(s => ({
   490	          id: s.id.slice(0, 8) + '...',
   491	          createdAt: new Date(s.createdAt),
   492	          lastActivity: new Date(s.lastActivity),
   493	          ipAddress: s.ipAddress,
   494	          userAgent: s.userAgent
   495	        }))
   496	      });
   497	    } catch (error: any) {
   498	      res.status(500).json({ error: error.message });
   499	    }
   500	  });
   501	
   502	  app.get('/api/admin/sessions/stats', requireAdmin, async (_req, res) => {
   503	    try {
   504	      const stats = SessionManager.getStats();
   505	      const nonceStats = NonceManager.getStats();
   506	      res.json({ sessions: stats, nonces: nonceStats });
   507	    } catch (error: any) {
   508	      res.status(500).json({ error: error.message });
   509	    }
   510	  });
   511	
   512	  app.get('/api/admin/sessions/active', requireAdmin, async (_req, res) => {
   513	    try {
   514	      const sessions = SessionManager.getActiveSessions();
   515	      res.json({ 
   516	        sessions: sessions.map(s => ({
   517	          id: s.id.slice(0, 8) + '...',
   518	          walletAddress: s.walletAddress,
   519	          isAdmin: s.isAdmin,
   520	          createdAt: new Date(s.createdAt),
/workspace/Dec_25_GRK_BC$ /bin/bash -lc nl -ba server/storage.ts | sed -n '900,1045p'
900	      points: (entry.points || 0) + points,
   901	      lastActiveAt: new Date()
   902	    };
   903	    
   904	    if (solved) {
   905	      updates.totalSolves = (entry.totalSolves || 0) + 1;
   906	      updates.dailySolves = (entry.dailySolves || 0) + 1;
   907	      
   908	      if (timeMs) {
   909	        updates.totalTimeMs = (entry.totalTimeMs || 0) + timeMs;
   910	        if (!entry.bestTimeMs || timeMs < entry.bestTimeMs) {
   911	          updates.bestTimeMs = timeMs;
   912	        }
   913	      }
   914	    }
   915	    
   916	    const [updated] = await db.update(riddleLeaderboard)
   917	      .set(updates)
   918	      .where(eq(riddleLeaderboard.walletAddress, normalized))
   919	      .returning();
   920	    
   921	    return updated;
   922	  }
   923	
   924	  // ============================================
   925	  // DAILY CHALLENGES METHODS
   926	  // ============================================
   927	
   928	  async getDailySet(dateKey: string): Promise<RiddleDailySet | undefined> {
   929	    const [set] = await db.select()
   930	      .from(riddleDailySets)
   931	      .where(eq(riddleDailySets.dateKey, dateKey));
   932	    return set;
   933	  }
   934	
   935	  async createDailySet(data: InsertRiddleDailySet): Promise<RiddleDailySet> {
   936	    const [set] = await db.insert(riddleDailySets)
   937	      .values(data)
   938	      .returning();
   939	    return set;
   940	  }
   941	
   942	  async getDailyEntries(setId: number): Promise<RiddleDailyEntry[]> {
   943	    return db.select()
   944	      .from(riddleDailyEntries)
   945	      .where(eq(riddleDailyEntries.setId, setId))
   946	      .orderBy(riddleDailyEntries.riddleIndex);
   947	  }
   948	
   949	  async createDailyEntry(data: InsertRiddleDailyEntry): Promise<RiddleDailyEntry> {
   950	    const [entry] = await db.insert(riddleDailyEntries)
   951	      .values(data)
   952	      .returning();
   953	    return entry;
   954	  }
   955	
   956	  // ============================================
   957	  // RIDDLE ATTEMPTS METHODS
   958	  // ============================================
   959	
   960	  async getRiddleAttempt(walletAddress: string, riddleEntryId: number): Promise<RiddleAttempt | undefined> {
   961	    const [attempt] = await db.select()
   962	      .from(riddleAttempts)
   963	      .where(and(
   964	        eq(riddleAttempts.walletAddress, walletAddress.toLowerCase()),
   965	        eq(riddleAttempts.riddleEntryId, riddleEntryId)
   966	      ));
   967	    return attempt;
   968	  }
   969	
   970	  async createRiddleAttempt(data: InsertRiddleAttempt): Promise<RiddleAttempt> {
   971	    const [attempt] = await db.insert(riddleAttempts)
   972	      .values({
   973	        ...data,
   974	        walletAddress: data.walletAddress.toLowerCase()
   975	      })
   976	      .returning();
   977	    return attempt;
   978	  }
   979	
   980	  async updateRiddleAttempt(
   981	    id: number, 
   982	    solved: boolean, 
   983	    solveTimeMs: number, 
   984	    pointsEarned: number
   985	  ): Promise<RiddleAttempt | undefined> {
   986	    const [updated] = await db.update(riddleAttempts)
   987	      .set({
   988	        solved,
   989	        solveTimeMs,
   990	        pointsEarned,
   991	        solvedAt: solved ? new Date() : undefined
   992	      })
   993	      .where(eq(riddleAttempts.id, id))
   994	      .returning();
   995	    return updated;
   996	  }
   997	
   998	  async getUserDailyProgress(walletAddress: string, dateKey: string): Promise<RiddleAttempt[]> {
   999	    return db.select()
  1000	      .from(riddleAttempts)
  1001	      .where(and(
  1002	        eq(riddleAttempts.walletAddress, walletAddress.toLowerCase()),
  1003	        eq(riddleAttempts.dateKey, dateKey)
  1004	      ));
  1005	  }
  1006	
  1007	  // ============================================
  1008	  // RIDDLE QUEST PROGRESS METHODS
  1009	  // ============================================
  1010	
  1011	  async getLatestRiddleProgress(walletAddress: string): Promise<RiddleProgress | undefined> {
  1012	    const [progress] = await db.select()
  1013	      .from(riddleProgress)
  1014	      .where(eq(riddleProgress.walletAddress, walletAddress.toLowerCase()))
  1015	      .orderBy(desc(riddleProgress.dateKey))
  1016	      .limit(1);
  1017	    return progress;
  1018	  }
  1019	
  1020	  async getRiddleProgress(walletAddress: string, dateKey: string): Promise<RiddleProgress | undefined> {
  1021	    const [progress] = await db.select()
  1022	      .from(riddleProgress)
  1023	      .where(and(
  1024	        eq(riddleProgress.walletAddress, walletAddress.toLowerCase()),
  1025	        eq(riddleProgress.dateKey, dateKey)
  1026	      ));
  1027	    return progress;
  1028	  }
  1029	
  1030	  async upsertRiddleProgress(data: InsertRiddleProgress): Promise<RiddleProgress> {
  1031	    const normalized = data.walletAddress.toLowerCase();
  1032	    const [progress] = await db.insert(riddleProgress)
  1033	      .values({
  1034	        ...data,
  1035	        walletAddress: normalized,
  1036	        updatedAt: new Date()
  1037	      })
  1038	      .onConflictDoUpdate({
  1039	        target: [riddleProgress.walletAddress, riddleProgress.dateKey],
  1040	        set: {
  1041	          riddlesSolved: data.riddlesSolved,
  1042	          passesUsed: data.passesUsed,
  1043	          interactions: data.interactions,
  1044	          updatedAt: new Date()
  1045	        }
Summarizing RiddleQuest updates and testing challenges
I'll capture the key changes to the RiddleQuest component including the new chat UI, progress tracking, and data storage, plus mention the added database table and simplified oracle client. I'll note the testing attempts that failed due to the missing DATABASE_URL, the inability to run openrouter calls without the API key, and the screenshot attempt failure. Iâ€™ll also explain that relevant logs exist in the oracleService.ts file but can't be shown without running with the correct environment variables. Finally, I'll prepare a detailed bullet summary with file edits, new table schema, logs info, testing notes, and the screenshot situation to share in the final message.

Summary
Rebuilt the Riddle Quest into a live Mind Warp Strategist chat flow with streaming/typing responses, 33â€‘riddle progression, pass/interactions limits, and local cache clearing ( client/src/components/RiddleQuest.tsx lines 1â€“320).
Simplified the Oracle client and enforced the new strategist prompt + progress-aware riddle generation on the server endpoints ( client/src/lib/oracleClient.ts lines 1â€“103, server/lib/oracleService.ts lines 1â€“191, server/routes.ts lines 1200â€“1485).
Added persistent quest tracking via the new riddle_progress table and storage helpers/endpoints for the 24h limit ( shared/schema.ts lines 602â€“623, server/storage.ts lines 1007â€“1045, server/routes.ts lines 1267â€“1343).
Exact edits (path:lines)
client/src/components/RiddleQuest.tsx: chat UI + state machine + typing effect + progress persistence (lines 1â€“320).
client/src/lib/oracleClient.ts: streamlined API calls and question detection (lines 1â€“103).
server/lib/oracleService.ts: exact system prompt + progressâ€‘aware riddle prompt (lines 7â€“191).
server/routes.ts: oracle route update + quest progress endpoints + oracleâ€‘only daily generation/semantic evaluation (lines 172â€“213, 1200â€“1485).
server/storage.ts: riddle progress CRUD methods (lines 1007â€“1045).
shared/schema.ts: new riddle_progress table definition (lines 602â€“623).
New table
riddle_progress ( shared/schema.ts lines 602â€“623): walletAddress, dateKey, riddlesSolved, passesUsed, interactions, timestamps, unique index on (walletAddress, dateKey).
OpenRouter logs
Live call logs and semantic match logging are emitted in server/lib/oracleService.ts (lines 111â€“133). I couldnâ€™t produce runtime logs without OPENROUTER_API_KEY and a running server.
Screenshot
Attempted to capture the updated UI, but the dev server failed to start because DATABASE_URL is not set, so no screenshot is available.
Testing
âš ï¸ npm run dev -- --host 0.0.0.0 --port 4173 (failed: DATABASE_URL not set)
If you want me to retry the UI screenshot or run a simulated conversation log, please provide DATABASE_URL and OPENROUTER_API_KEY, and Iâ€™ll rerun.