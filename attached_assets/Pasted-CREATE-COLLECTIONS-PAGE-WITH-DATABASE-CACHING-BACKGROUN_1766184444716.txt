CREATE COLLECTIONS PAGE WITH DATABASE CACHING & BACKGROUND SYNC

GOAL: Build a fast, scalable Collections page that displays all BasedAI L1 NFT collections with proper caching, background data sync, and marketplace integration.

CONTEXT: 23 NFT collections exist on BasedAI L1. Current section is called "Collections" (not "All Collections").

ARCHITECTURE:
- Database stores collection data (updated hourly via cron)
- API returns cached data instantly (< 100ms)
- Background job syncs blockchain data
- Progressive loading for images
- Marketplace stats integration

═══════════════════════════════════════════════════════════════════
STEP 1: ADD COLLECTIONS TABLE TO DATABASE
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: shared/schema.ts

Add new table after existing tables:

export const collections = pgTable('collections', {
  id: serial('id').primaryKey(),
  address: text('address').notNull().unique(),
  name: text('name').notNull(),
  symbol: text('symbol').notNull(),
  totalSupply: integer('total_supply').notNull().default(0),
  floorPrice: text('floor_price').default('0'),
  volume24h: text('volume_24h').default('0'),
  totalVolume: text('total_volume').default('0'),
  imageUrl: text('image_url'),
  verified: boolean('verified').default(false),
  lastSyncedAt: timestamp('last_synced_at').defaultNow(),
  createdAt: timestamp('created_at').defaultNow(),
  metadata: text('metadata'), // JSON string for extra data
});

2. Run database migration:

npm run db:push


═══════════════════════════════════════════════════════════════════
STEP 2: ADD DATABASE METHODS FOR COLLECTIONS
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: server/storage.ts

Add these methods at the end:

// Collections
export async function getAllCollections() {
  return db.select().from(collections).orderBy(desc(collections.totalVolume));
}

export async function getCollectionByAddress(address: string) {
  const result = await db.select()
    .from(collections)
    .where(eq(collections.address, address.toLowerCase()))
    .limit(1);
  return result[0] || null;
}

export async function upsertCollection(data: {
  address: string;
  name: string;
  symbol: string;
  totalSupply: number;
  floorPrice?: string;
  volume24h?: string;
  totalVolume?: string;
  imageUrl?: string;
  verified?: boolean;
}) {
  const existing = await getCollectionByAddress(data.address);
  
  if (existing) {
    await db.update(collections)
      .set({
        ...data,
        address: data.address.toLowerCase(),
        lastSyncedAt: new Date(),
      })
      .where(eq(collections.address, data.address.toLowerCase()));
  } else {
    await db.insert(collections).values({
      ...data,
      address: data.address.toLowerCase(),
      lastSyncedAt: new Date(),
    });
  }
}

export async function needsCollectionSync() {
  // Check if we need to sync (last sync > 1 hour ago OR no collections)
  const count = await db.select({ count: sql<number>`count(*)` })
    .from(collections);
  
  if (!count[0] || count[0].count === 0) return true;
  
  const recent = await db.select()
    .from(collections)
    .orderBy(desc(collections.lastSyncedAt))
    .limit(1);
  
  if (!recent[0]) return true;
  
  const hourAgo = Date.now() - (60 * 60 * 1000);
  return recent[0].lastSyncedAt!.getTime() < hourAgo;
}


═══════════════════════════════════════════════════════════════════
STEP 3: CREATE BACKGROUND SYNC SERVICE
═══════════════════════════════════════════════════════════════════

1. CREATE FILE: server/lib/collectionSync.ts

import { ethers } from 'ethers';
import { RPC_URL } from '../../client/src/lib/constants';
import { upsertCollection } from '../storage';

export class CollectionSync {
  private static provider = new ethers.JsonRpcProvider(RPC_URL);
  
  private static readonly BASEDAI_COLLECTIONS = [
    '0x74f442F6bd614389cA63731f80901f603CDe1b53',
    '0x8EB23fefe4900ecEb8354Bee78B6f49c5983b87C',
    '0x3BFa8d4a9D77A54B623a272A558F9b471DbDd21f',
    '0x6fAEF90f2016980C656aE0577705581De6C65210',
    '0xECfc059EbB477FecEC139dD231e706C63a49901C',
    '0x0DCDaBeC6814EFe61BC7a0CD6fDcF00B905E1C2c',
    '0x7AD3ae91cA94A5e100C98C7E8Eb0b15a2e5B12bf',
    '0xCD52129Fb19FC09DCc75985897aEe6B25e294dB3',
    '0x54c2c028373D61ABe282aa227DC1e1f754B72C9e',
    '0x6B0313d189E3aFAfBeD3Ab31802B2489cE352Fe8',
    '0xc29A57D0Fe4fba9a4eC5296b7314cF28E85fc1d0',
    '0x405977B925D93189ba7A843AEA020108a7681dcf',
    '0x3eCd7dCd88F30342112Cc417E351A651D9950089',
    '0xBc3d1062A6A7B6450C785108f962fD6A9A4C3759',
    '0xa9500589CFC530dB57581E3c3eda4930FbDA90C1',
    '0x6aA2D24932E0AEB94Ac84b8C7545D040BD99999A',
    '0x332EF57B5f4e9A65B940453cFe83DC733b8e2b83',
    '0xaE51dc5fD1499A129f8654963560f9340773ad59', // Based Guardians
  ];

  static async syncAll() {
    console.log('[CollectionSync] Starting sync for', this.BASEDAI_COLLECTIONS.length, 'collections');
    
    const results = {
      success: 0,
      failed: 0,
      skipped: 0,
    };

    // Sync collections one at a time to avoid overwhelming RPC
    for (const address of this.BASEDAI_COLLECTIONS) {
      try {
        await this.syncCollection(address);
        results.success++;
        console.log(`[CollectionSync] ✓ Synced ${address}`);
        
        // Small delay to not overwhelm RPC
        await new Promise(resolve => setTimeout(resolve, 500));
      } catch (error) {
        results.failed++;
        console.error(`[CollectionSync] ✗ Failed ${address}:`, error);
      }
    }

    console.log('[CollectionSync] Sync complete:', results);
    return results;
  }

  private static async syncCollection(address: string) {
    const contract = new ethers.Contract(
      address,
      [
        'function name() view returns (string)',
        'function symbol() view returns (string)',
        'function totalSupply() view returns (uint256)',
        'function tokenURI(uint256) view returns (string)',
      ],
      this.provider
    );

    // Fetch basic data with timeout
    const timeout = 10000; // 10 second timeout per collection
    const [name, symbol, totalSupply] = await Promise.race([
      Promise.all([
        contract.name(),
        contract.symbol(),
        contract.totalSupply(),
      ]),
      new Promise<never>((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeout)
      ),
    ]);

    // Get image from first NFT (with fallback)
    let imageUrl = `https://via.placeholder.com/400?text=${encodeURIComponent(symbol)}`;
    try {
      if (Number(totalSupply) > 0) {
        const tokenURI = await Promise.race([
          contract.tokenURI(1),
          new Promise<never>((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 5000)
          ),
        ]);
        
        if (tokenURI.startsWith('http')) {
          const metadata = await fetch(tokenURI, { 
            signal: AbortSignal.timeout(5000) 
          }).then(r => r.json());
          if (metadata.image) {
            imageUrl = metadata.image;
          }
        }
      }
    } catch (error) {
      console.warn(`[CollectionSync] Could not fetch image for ${address}`);
    }

    // Save to database
    await upsertCollection({
      address,
      name,
      symbol,
      totalSupply: Number(totalSupply),
      imageUrl,
      verified: address.toLowerCase() === '0xae51dc5fd1499a129f8654963560f9340773ad59',
      // Volume/floor will be calculated separately by marketplace stats job
    });
  }
}


═══════════════════════════════════════════════════════════════════
STEP 4: ADD API ENDPOINTS
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: server/routes.ts

Add these endpoints:

// Get all collections (cached from database)
app.get('/api/collections/all', async (req, res) => {
  try {
    const collections = await getAllCollections();
    res.json(collections);
  } catch (error: any) {
    console.error('[API] Failed to fetch collections:', error);
    res.status(500).json({ error: 'Failed to fetch collections' });
  }
});

// Trigger collection sync (admin only - add auth check if needed)
app.post('/api/collections/sync', async (req, res) => {
  try {
    const { CollectionSync } = await import('./lib/collectionSync');
    const results = await CollectionSync.syncAll();
    res.json({ success: true, results });
  } catch (error: any) {
    console.error('[API] Sync failed:', error);
    res.status(500).json({ error: 'Sync failed' });
  }
});


═══════════════════════════════════════════════════════════════════
STEP 5: INITIALIZE COLLECTIONS ON SERVER START
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: server/index.ts

Add this after the server starts (before the app.listen or at the end):

// Initialize collections on startup if needed
(async () => {
  try {
    const needsSync = await needsCollectionSync();
    if (needsSync) {
      console.log('[Server] Collections need sync, starting background sync...');
      const { CollectionSync } = await import('./lib/collectionSync');
      // Run in background, don't block server start
      CollectionSync.syncAll().catch(err => 
        console.error('[Server] Background sync failed:', err)
      );
    } else {
      console.log('[Server] Collections are up to date');
    }
  } catch (error) {
    console.error('[Server] Failed to check collection sync status:', error);
  }
})();

// Set up hourly sync
setInterval(async () => {
  try {
    console.log('[Server] Running scheduled collection sync...');
    const { CollectionSync } = await import('./lib/collectionSync');
    await CollectionSync.syncAll();
  } catch (error) {
    console.error('[Server] Scheduled sync failed:', error);
  }
}, 60 * 60 * 1000); // Every hour


═══════════════════════════════════════════════════════════════════
STEP 6: CREATE COLLECTIONS PAGE COMPONENT
═══════════════════════════════════════════════════════════════════

1. CREATE FILE: client/src/pages/Collections.tsx

import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { Search, Grid3x3, Loader2 } from 'lucide-react';
import { Link } from 'wouter';

interface Collection {
  id: number;
  address: string;
  name: string;
  symbol: string;
  totalSupply: number;
  floorPrice: string | null;
  volume24h: string | null;
  totalVolume: string | null;
  imageUrl: string | null;
  verified: boolean;
}

export default function Collections() {
  const [collections, setCollections] = useState<Collection[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [sortBy, setSortBy] = useState<'name' | 'volume' | 'items'>('volume');

  useEffect(() => {
    fetchCollections();
  }, []);

  async function fetchCollections() {
    try {
      setLoading(true);
      const response = await fetch('/api/collections/all');
      if (!response.ok) throw new Error('Failed to fetch');
      const data = await response.json();
      setCollections(data);
    } catch (error) {
      console.error('[Collections] Failed to fetch:', error);
    } finally {
      setLoading(false);
    }
  }

  const filteredCollections = collections
    .filter(c => 
      c.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      c.symbol.toLowerCase().includes(searchQuery.toLowerCase())
    )
    .sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'volume') {
        const volA = parseFloat(a.totalVolume || '0');
        const volB = parseFloat(b.totalVolume || '0');
        return volB - volA;
      }
      if (sortBy === 'items') return b.totalSupply - a.totalSupply;
      return 0;
    });

  return (
    <div className="min-h-screen bg-gradient-to-b from-background via-background/95 to-primary/5">
      {/* Header */}
      <div className="relative border-b border-primary/20 bg-background/50 backdrop-blur-sm">
        <div className="max-w-7xl mx-auto px-4 py-12">
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="text-center"
          >
            <h1 className="text-4xl md:text-5xl font-bold mb-4 bg-gradient-to-r from-primary via-purple-400 to-primary bg-clip-text text-transparent">
              Collections
            </h1>
            <p className="text-muted-foreground text-lg">
              Explore NFT collections on BasedAI L1
            </p>
          </motion.div>

          {/* Search and Filters */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.1 }}
            className="mt-8 flex flex-col md:flex-row gap-4"
          >
            <div className="flex-1 relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-muted-foreground" />
              <input
                type="text"
                placeholder="Search collections..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full pl-10 pr-4 py-3 bg-card border border-primary/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50"
              />
            </div>

            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as any)}
              className="px-4 py-3 bg-card border border-primary/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 cursor-pointer"
            >
              <option value="volume">Sort by Volume</option>
              <option value="items">Sort by Items</option>
              <option value="name">Sort by Name</option>
            </select>
          </motion.div>
        </div>
      </div>

      {/* Collections Grid */}
      <div className="max-w-7xl mx-auto px-4 py-12">
        {loading ? (
          <div className="flex items-center justify-center py-20">
            <Loader2 className="w-8 h-8 animate-spin text-primary" />
            <span className="ml-3 text-lg">Loading collections...</span>
          </div>
        ) : filteredCollections.length === 0 ? (
          <div className="text-center py-20">
            <Grid3x3 className="w-16 h-16 mx-auto mb-4 text-muted-foreground" />
            <h3 className="text-xl font-semibold mb-2">No collections found</h3>
            <p className="text-muted-foreground">
              {searchQuery ? 'Try adjusting your search' : 'No collections available'}
            </p>
          </div>
        ) : (
          <motion.div 
            className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6"
            initial="hidden"
            animate="visible"
            variants={{ visible: { transition: { staggerChildren: 0.05 } } }}
          >
            {filteredCollections.map((collection) => (
              <motion.div
                key={collection.id}
                variants={{
                  hidden: { opacity: 0, y: 20 },
                  visible: { opacity: 1, y: 0 }
                }}
              >
                <Link href={`/marketplace?collection=${collection.address}`}>
                  <div className="group bg-card border border-primary/20 rounded-lg overflow-hidden hover:border-primary/50 hover:shadow-lg hover:shadow-primary/20 transition-all duration-300 cursor-pointer">
                    <div className="relative aspect-square overflow-hidden bg-gradient-to-br from-primary/20 to-purple-500/20">
                      <img
                        src={collection.imageUrl || `https://via.placeholder.com/400?text=${encodeURIComponent(collection.symbol)}`}
                        alt={collection.name}
                        className="w-full h-full object-cover group-hover:scale-110 transition-transform duration-300"
                        loading="lazy"
                      />
                      {collection.verified && (
                        <div className="absolute top-2 right-2 bg-primary/90 backdrop-blur-sm px-2 py-1 rounded-full text-xs font-semibold">
                          ✓ Verified
                        </div>
                      )}
                    </div>

                    <div className="p-4">
                      <h3 className="font-bold text-lg mb-1 truncate group-hover:text-primary transition-colors">
                        {collection.name}
                      </h3>
                      <p className="text-sm text-muted-foreground mb-3">{collection.symbol}</p>

                      <div className="grid grid-cols-2 gap-2 text-sm">
                        <div>
                          <div className="text-muted-foreground text-xs">Items</div>
                          <div className="font-semibold">{collection.totalSupply.toLocaleString()}</div>
                        </div>
                        <div>
                          <div className="text-muted-foreground text-xs">Floor</div>
                          <div className="font-semibold">
                            {collection.floorPrice && collection.floorPrice !== '0' 
                              ? `${parseFloat(collection.floorPrice).toFixed(0)} $BASED`
                              : 'N/A'}
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </Link>
              </motion.div>
            ))}
          </motion.div>
        )}
      </div>
    </div>
  );
}


═══════════════════════════════════════════════════════════════════
STEP 7: ADD ROUTE AND NAVIGATION
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: client/src/App.tsx

Import:
import Collections from '@/pages/Collections';

Add route:
<Route path="/collections" component={Collections} />

2. UPDATE FILE: client/src/components/Navbar.tsx

Add to navigation:
{ label: 'Collections', path: '/collections' },


═══════════════════════════════════════════════════════════════════
STEP 8: TEST & VERIFY
═══════════════════════════════════════════════════════════════════

1. Restart server: npm run dev

2. Check terminal for: "[Server] Collections need sync, starting background sync..."

3. Wait 30-60 seconds for initial sync to complete

4. Navigate to /collections - should load INSTANTLY (< 100ms)

5. Verify:
   ✓ Collections display immediately
   ✓ Search works
   ✓ Sorting works
   ✓ Images load progressively
   ✓ Based Guardians shows verified badge
   ✓ No performance lag

DONE! Collections page is now production-ready with proper caching and background sync.