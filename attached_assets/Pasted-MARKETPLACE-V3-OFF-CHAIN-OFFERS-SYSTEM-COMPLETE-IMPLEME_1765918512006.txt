MARKETPLACE V3 - OFF-CHAIN OFFERS SYSTEM (COMPLETE IMPLEMENTATION)

We are implementing a new offer system where:
- Buyer makes offer â†’ Signs a message (FREE, no gas, funds stay in wallet)
- Seller accepts â†’ Creates pending sale, buyer has 24h to complete
- Buyer completes â†’ NOW funds transfer and NFT transfers
- If buyer doesn't complete in 24h â†’ Offer expires, no penalty

This is how Aftermint and other modern marketplaces work. Funds NEVER leave buyer's wallet until they complete the purchase.

=== IMPORTANT: NEW CONTRACT ADDRESS ===
After deploying V3, update constants.ts:
export const MARKETPLACE_V3_CONTRACT = "YOUR_V3_ADDRESS_HERE";
(Keep V2 for backwards compatibility during transition)


=====================================================================
FILE 1: hooks/useOffersV3.ts - NEW HOOK FOR OFF-CHAIN OFFERS
=====================================================================

Create a new file: hooks/useOffersV3.ts

import { useState, useCallback, useEffect } from 'react';
import { useAccount, useSignTypedData, useWriteContract, useWaitForTransactionReceipt, useChainId } from 'wagmi';
import { parseEther, formatEther, keccak256, encodePacked } from 'viem';
import { useToast } from '@/hooks/use-toast';
import { NFT_CONTRACT, CHAIN_ID } from '@/lib/constants';

// V3 Contract Address - UPDATE THIS after deployment
export const MARKETPLACE_V3_CONTRACT = "0x2836f07Ed31a6DEc09E0d62Fb15D7c6c6Ddb139c"; // Placeholder - update after deploy

// EIP-712 Domain for signing
const DOMAIN = {
  name: 'BasedGuardiansMarketplace',
  version: '3',
  chainId: 32323,
  verifyingContract: MARKETPLACE_V3_CONTRACT as `0x${string}`,
};

// Offer type for EIP-712
const OFFER_TYPES = {
  Offer: [
    { name: 'tokenId', type: 'uint256' },
    { name: 'buyer', type: 'address' },
    { name: 'price', type: 'uint256' },
    { name: 'nonce', type: 'uint256' },
    { name: 'expiration', type: 'uint256' },
  ],
};

// Offer structure
export interface OffchainOffer {
  id: string;
  tokenId: number;
  buyer: string;
  price: string;        // In $BASED (not wei)
  priceWei: string;     // In wei
  nonce: number;
  expiration: number;   // Unix timestamp
  signature: string;
  status: 'pending' | 'accepted' | 'completed' | 'expired' | 'cancelled';
  createdAt: number;
  acceptedAt?: number;
  completionDeadline?: number;
}

// Pending sale from contract
export interface PendingSale {
  tokenId: number;
  seller: string;
  buyer: string;
  price: string;
  priceWei: bigint;
  acceptedAt: number;
  deadline: number;
  active: boolean;
}

// Storage key for offers
const OFFERS_STORAGE_KEY = 'basedguardians_offers_v3';

// V3 Contract ABI
const MARKETPLACE_V3_ABI = [
  {
    name: 'acceptOffer',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'tokenId', type: 'uint256' },
      { name: 'buyer', type: 'address' },
      { name: 'price', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'expiration', type: 'uint256' },
      { name: 'signature', type: 'bytes' },
    ],
    outputs: [],
  },
  {
    name: 'completePurchase',
    type: 'function',
    stateMutability: 'payable',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [],
  },
  {
    name: 'expirePendingSale',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [],
  },
  {
    name: 'cancelAllOffers',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [],
    outputs: [],
  },
  {
    name: 'getNonce',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'user', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'getPendingSale',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [
      { name: 'seller', type: 'address' },
      { name: 'buyer', type: 'address' },
      { name: 'price', type: 'uint256' },
      { name: 'acceptedAt', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
      { name: 'active', type: 'bool' },
    ],
  },
  {
    name: 'listNFT',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'tokenId', type: 'uint256' },
      { name: 'price', type: 'uint256' },
    ],
    outputs: [],
  },
  {
    name: 'delistNFT',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [],
  },
  {
    name: 'buyNFT',
    type: 'function',
    stateMutability: 'payable',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [],
  },
] as const;

// === OFFER STORAGE (localStorage + future API) ===

function getStoredOffers(): OffchainOffer[] {
  try {
    const stored = localStorage.getItem(OFFERS_STORAGE_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch {
    return [];
  }
}

function saveOffers(offers: OffchainOffer[]) {
  try {
    localStorage.setItem(OFFERS_STORAGE_KEY, JSON.stringify(offers));
  } catch (e) {
    console.error('Failed to save offers:', e);
  }
}

function addOffer(offer: OffchainOffer) {
  const offers = getStoredOffers();
  // Remove any existing offer from same buyer on same token
  const filtered = offers.filter(o => !(o.tokenId === offer.tokenId && o.buyer.toLowerCase() === offer.buyer.toLowerCase()));
  filtered.push(offer);
  saveOffers(filtered);
}

function updateOfferStatus(id: string, status: OffchainOffer['status'], extra?: Partial<OffchainOffer>) {
  const offers = getStoredOffers();
  const updated = offers.map(o => o.id === id ? { ...o, status, ...extra } : o);
  saveOffers(updated);
}

function removeOffer(id: string) {
  const offers = getStoredOffers();
  saveOffers(offers.filter(o => o.id !== id));
}

// === MAIN HOOK ===

export function useOffersV3() {
  const { address, isConnected } = useAccount();
  const chainId = useChainId();
  const { toast } = useToast();
  
  const [isLoading, setIsLoading] = useState(false);
  const [myOffers, setMyOffers] = useState<OffchainOffer[]>([]);
  const [offersForToken, setOffersForToken] = useState<Map<number, OffchainOffer[]>>(new Map());
  const [pendingSales, setPendingSales] = useState<Map<number, PendingSale>>(new Map());
  const [userNonce, setUserNonce] = useState<number>(0);
  
  // Sign typed data hook
  const { signTypedDataAsync } = useSignTypedData();
  
  // Write contract hooks
  const { writeContract, data: txHash, isPending, error: writeError, reset } = useWriteContract();
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash: txHash });

  // Fetch user's nonce from contract
  const fetchNonce = useCallback(async () => {
    if (!address) return;
    
    try {
      const { ethers } = await import('ethers');
      const provider = new ethers.JsonRpcProvider('https://mainnet.basedaibridge.com/rpc/');
      const contract = new ethers.Contract(MARKETPLACE_V3_CONTRACT, MARKETPLACE_V3_ABI, provider);
      const nonce = await contract.getNonce(address);
      setUserNonce(Number(nonce));
    } catch (e) {
      console.error('Failed to fetch nonce:', e);
    }
  }, [address]);

  // Load offers from storage
  const loadOffers = useCallback(() => {
    const allOffers = getStoredOffers();
    
    // Filter out expired offers
    const now = Math.floor(Date.now() / 1000);
    const validOffers = allOffers.filter(o => {
      if (o.status === 'completed' || o.status === 'cancelled') return false;
      if (o.status === 'pending' && o.expiration < now) {
        updateOfferStatus(o.id, 'expired');
        return false;
      }
      return true;
    });
    
    // My offers (I made)
    if (address) {
      setMyOffers(validOffers.filter(o => o.buyer.toLowerCase() === address.toLowerCase()));
    }
    
    // Group by token
    const byToken = new Map<number, OffchainOffer[]>();
    validOffers.forEach(o => {
      const existing = byToken.get(o.tokenId) || [];
      existing.push(o);
      byToken.set(o.tokenId, existing);
    });
    setOffersForToken(byToken);
  }, [address]);

  // Initial load
  useEffect(() => {
    loadOffers();
    fetchNonce();
  }, [loadOffers, fetchNonce]);

  // Refresh periodically
  useEffect(() => {
    const interval = setInterval(loadOffers, 30000);
    return () => clearInterval(interval);
  }, [loadOffers]);

  // === MAKE OFFER (Sign message - FREE, no gas!) ===
  const makeOffer = useCallback(async (
    tokenId: number, 
    priceInBased: number, 
    expirationDays: number = 7
  ): Promise<boolean> => {
    if (!isConnected || !address) {
      toast({ title: "Connect Wallet", description: "Please connect your wallet first", variant: "destructive" });
      return false;
    }

    if (chainId !== CHAIN_ID) {
      toast({ title: "Wrong Network", description: "Please switch to BasedAI network", variant: "destructive" });
      return false;
    }

    try {
      setIsLoading(true);
      
      // Fetch current nonce
      await fetchNonce();
      
      const priceWei = parseEther(priceInBased.toString());
      const expiration = Math.floor(Date.now() / 1000) + (expirationDays * 24 * 60 * 60);
      
      // Prepare offer data for signing
      const offerData = {
        tokenId: BigInt(tokenId),
        buyer: address,
        price: priceWei,
        nonce: BigInt(userNonce),
        expiration: BigInt(expiration),
      };

      toast({
        title: "Sign Offer",
        description: "Please sign the message in your wallet. This is FREE - no gas needed!",
        className: "bg-black border-cyan-500 text-cyan-400",
      });

      // Sign the typed data (FREE - no transaction!)
      const signature = await signTypedDataAsync({
        domain: DOMAIN,
        types: OFFER_TYPES,
        primaryType: 'Offer',
        message: offerData,
      });

      // Create offer object
      const offer: OffchainOffer = {
        id: `${tokenId}-${address}-${Date.now()}`,
        tokenId,
        buyer: address,
        price: priceInBased.toString(),
        priceWei: priceWei.toString(),
        nonce: userNonce,
        expiration,
        signature,
        status: 'pending',
        createdAt: Math.floor(Date.now() / 1000),
      };

      // Store offer
      addOffer(offer);
      loadOffers();

      toast({
        title: "âœ… Offer Created!",
        description: `Offer of ${priceInBased.toLocaleString()} $BASED submitted. Funds stay in your wallet until seller accepts!`,
        className: "bg-black border-green-500 text-green-400",
      });

      return true;

    } catch (e: any) {
      console.error('Make offer error:', e);
      
      if (e.message?.includes('rejected') || e.message?.includes('denied')) {
        toast({ title: "Cancelled", description: "You cancelled the signature request" });
      } else {
        toast({ title: "Error", description: "Failed to create offer", variant: "destructive" });
      }
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [isConnected, address, chainId, userNonce, signTypedDataAsync, toast, fetchNonce, loadOffers]);

  // === ACCEPT OFFER (Seller action - creates pending sale) ===
  const acceptOffer = useCallback(async (offer: OffchainOffer): Promise<boolean> => {
    if (!isConnected || !address) {
      toast({ title: "Connect Wallet", description: "Please connect your wallet", variant: "destructive" });
      return false;
    }

    try {
      setIsLoading(true);

      toast({
        title: "Accept Offer",
        description: "Confirm in your wallet to accept this offer...",
        className: "bg-black border-cyan-500 text-cyan-400",
      });

      writeContract({
        address: MARKETPLACE_V3_CONTRACT as `0x${string}`,
        abi: MARKETPLACE_V3_ABI,
        functionName: 'acceptOffer',
        args: [
          BigInt(offer.tokenId),
          offer.buyer as `0x${string}`,
          BigInt(offer.priceWei),
          BigInt(offer.nonce),
          BigInt(offer.expiration),
          offer.signature as `0x${string}`,
        ],
        gas: BigInt(500000),
        gasPrice: BigInt(10000000000), // 10 gwei
      });

      return true;
    } catch (e: any) {
      console.error('Accept offer error:', e);
      toast({ title: "Error", description: "Failed to accept offer", variant: "destructive" });
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [isConnected, address, writeContract, toast]);

  // === COMPLETE PURCHASE (Buyer action - sends funds) ===
  const completePurchase = useCallback(async (tokenId: number, priceWei: bigint): Promise<boolean> => {
    if (!isConnected || !address) {
      toast({ title: "Connect Wallet", description: "Please connect your wallet", variant: "destructive" });
      return false;
    }

    try {
      setIsLoading(true);

      toast({
        title: "Complete Purchase",
        description: "Confirm in your wallet to complete the purchase...",
        className: "bg-black border-cyan-500 text-cyan-400",
      });

      writeContract({
        address: MARKETPLACE_V3_CONTRACT as `0x${string}`,
        abi: MARKETPLACE_V3_ABI,
        functionName: 'completePurchase',
        args: [BigInt(tokenId)],
        value: priceWei,
        gas: BigInt(500000),
        gasPrice: BigInt(10000000000),
      });

      return true;
    } catch (e: any) {
      console.error('Complete purchase error:', e);
      toast({ title: "Error", description: "Failed to complete purchase", variant: "destructive" });
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [isConnected, address, writeContract, toast]);

  // === CANCEL OFFER (Remove from storage + optionally invalidate on-chain) ===
  const cancelOffer = useCallback(async (offerId: string, invalidateOnChain: boolean = false): Promise<boolean> => {
    try {
      // Remove from local storage
      removeOffer(offerId);
      loadOffers();

      // Optionally invalidate all offers by incrementing nonce on-chain
      if (invalidateOnChain) {
        writeContract({
          address: MARKETPLACE_V3_CONTRACT as `0x${string}`,
          abi: MARKETPLACE_V3_ABI,
          functionName: 'cancelAllOffers',
          args: [],
          gas: BigInt(100000),
          gasPrice: BigInt(10000000000),
        });
      }

      toast({
        title: "Offer Cancelled",
        description: "Your offer has been removed",
        className: "bg-black border-cyan-500 text-cyan-400",
      });

      return true;
    } catch (e) {
      console.error('Cancel offer error:', e);
      return false;
    }
  }, [writeContract, toast, loadOffers]);

  // === GET OFFERS FOR TOKEN ===
  const getOffersForToken = useCallback((tokenId: number): OffchainOffer[] => {
    return offersForToken.get(tokenId) || [];
  }, [offersForToken]);

  // Track transaction success
  useEffect(() => {
    if (isSuccess && txHash) {
      toast({
        title: "âœ… Transaction Confirmed!",
        description: "The transaction was successful",
        className: "bg-black border-green-500 text-green-400",
      });
      loadOffers();
      fetchNonce();
    }
  }, [isSuccess, txHash, toast, loadOffers, fetchNonce]);

  return {
    // State
    isLoading: isLoading || isPending || isConfirming,
    isPending,
    isConfirming,
    isSuccess,
    txHash,
    myOffers,
    userNonce,
    
    // Actions
    makeOffer,
    acceptOffer,
    completePurchase,
    cancelOffer,
    getOffersForToken,
    
    // Utilities
    refresh: loadOffers,
    reset,
  };
}

export default useOffersV3;


=====================================================================
FILE 2: components/MyOffersPanel.tsx - USER'S OFFERS WITH CANCEL
=====================================================================

Create a new file: components/MyOffersPanel.tsx

import { useState } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { useOffersV3, OffchainOffer } from '@/hooks/useOffersV3';
import { useAccount } from 'wagmi';
import { 
  Gavel, 
  X, 
  Clock, 
  CheckCircle, 
  AlertTriangle,
  Wallet,
  ExternalLink,
  Loader2,
  Trash2
} from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';

export function MyOffersPanel() {
  const { address, isConnected } = useAccount();
  const { myOffers, cancelOffer, isLoading, refresh } = useOffersV3();
  const [cancellingId, setCancellingId] = useState<string | null>(null);

  const handleCancel = async (offer: OffchainOffer) => {
    setCancellingId(offer.id);
    await cancelOffer(offer.id, false); // Don't invalidate on-chain by default
    setCancellingId(null);
  };

  if (!isConnected) {
    return (
      <Card className="p-8 bg-black/40 border-white/10 text-center">
        <Wallet className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
        <h3 className="text-lg font-orbitron text-white mb-2">Connect Wallet</h3>
        <p className="text-muted-foreground text-sm">Connect your wallet to view your offers</p>
      </Card>
    );
  }

  if (myOffers.length === 0) {
    return (
      <Card className="p-8 bg-black/40 border-white/10 text-center">
        <Gavel className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
        <h3 className="text-lg font-orbitron text-white mb-2">No Active Offers</h3>
        <p className="text-muted-foreground text-sm">
          You haven't made any offers yet. Browse the marketplace to make offers on NFTs!
        </p>
        <p className="text-cyan-400 text-xs mt-4">
          ðŸ’¡ Making offers is FREE - funds stay in your wallet until seller accepts
        </p>
      </Card>
    );
  }

  const getStatusBadge = (offer: OffchainOffer) => {
    const now = Math.floor(Date.now() / 1000);
    
    if (offer.status === 'accepted') {
      const timeLeft = (offer.completionDeadline || 0) - now;
      if (timeLeft > 0) {
        const hours = Math.floor(timeLeft / 3600);
        return (
          <Badge className="bg-amber-500/20 text-amber-400 border-amber-500/50 animate-pulse">
            <Clock size={12} className="mr-1" />
            ACCEPTED - {hours}h to complete
          </Badge>
        );
      } else {
        return (
          <Badge className="bg-red-500/20 text-red-400 border-red-500/50">
            <AlertTriangle size={12} className="mr-1" />
            EXPIRED
          </Badge>
        );
      }
    }
    
    if (offer.status === 'completed') {
      return (
        <Badge className="bg-green-500/20 text-green-400 border-green-500/50">
          <CheckCircle size={12} className="mr-1" />
          COMPLETED
        </Badge>
      );
    }
    
    if (offer.expiration < now) {
      return (
        <Badge className="bg-gray-500/20 text-gray-400 border-gray-500/50">
          EXPIRED
        </Badge>
      );
    }
    
    return (
      <Badge className="bg-cyan-500/20 text-cyan-400 border-cyan-500/50">
        <Clock size={12} className="mr-1" />
        PENDING
      </Badge>
    );
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-orbitron text-white flex items-center gap-2">
          <Gavel className="text-cyan-400" size={20} />
          MY OFFERS ({myOffers.length})
        </h3>
        <Button 
          variant="ghost" 
          size="sm" 
          onClick={refresh}
          disabled={isLoading}
          className="text-muted-foreground hover:text-white"
        >
          {isLoading ? <Loader2 className="animate-spin" size={16} /> : 'Refresh'}
        </Button>
      </div>

      {/* Info Banner */}
      <div className="p-3 rounded-lg bg-cyan-500/10 border border-cyan-500/30 mb-4">
        <p className="text-xs text-cyan-300 flex items-center gap-2">
          <CheckCircle size={14} />
          <span>Your funds stay in your wallet until you complete a purchase after seller accepts.</span>
        </p>
      </div>

      {/* Offers List */}
      <div className="space-y-3">
        {myOffers.map((offer) => (
          <Card 
            key={offer.id} 
            className="p-4 bg-black/60 border-white/10 hover:border-cyan-500/30 transition-colors"
          >
            <div className="flex items-center justify-between">
              <div className="flex-1">
                <div className="flex items-center gap-3 mb-2">
                  <span className="text-white font-bold font-orbitron">
                    Guardian #{offer.tokenId}
                  </span>
                  {getStatusBadge(offer)}
                </div>
                
                <div className="flex items-center gap-4 text-sm">
                  <div>
                    <span className="text-muted-foreground">Offer: </span>
                    <span className="text-cyan-400 font-mono font-bold">
                      {Number(offer.price).toLocaleString()} $BASED
                    </span>
                  </div>
                  <div className="text-muted-foreground text-xs">
                    Expires: {formatDistanceToNow(offer.expiration * 1000, { addSuffix: true })}
                  </div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                {offer.status === 'accepted' && (
                  <Button 
                    size="sm"
                    className="bg-green-500 text-black hover:bg-green-400 font-bold"
                  >
                    COMPLETE PURCHASE
                  </Button>
                )}
                
                {offer.status === 'pending' && (
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => handleCancel(offer)}
                    disabled={cancellingId === offer.id}
                    className="text-red-400 hover:text-red-300 hover:bg-red-500/10"
                  >
                    {cancellingId === offer.id ? (
                      <Loader2 className="animate-spin" size={16} />
                    ) : (
                      <>
                        <Trash2 size={14} className="mr-1" />
                        Cancel
                      </>
                    )}
                  </Button>
                )}
              </div>
            </div>
          </Card>
        ))}
      </div>

      {/* Cancel All Button */}
      {myOffers.filter(o => o.status === 'pending').length > 1 && (
        <div className="pt-4 border-t border-white/10">
          <Button 
            variant="outline" 
            size="sm"
            className="w-full border-red-500/30 text-red-400 hover:bg-red-500/10"
          >
            <X size={14} className="mr-2" />
            Cancel All Pending Offers
          </Button>
          <p className="text-[10px] text-muted-foreground text-center mt-2">
            This will invalidate all your signed offers (costs gas)
          </p>
        </div>
      )}
    </div>
  );
}

export default MyOffersPanel;


=====================================================================
FILE 3: Update components/EscrowMarketplace.tsx - INTEGRATE V3 OFFERS
=====================================================================

Find the OfferModal component in EscrowMarketplace.tsx and update it to use the new V3 system.

REPLACE the entire OfferModal function with:

// Offer Modal Component - V3 OFF-CHAIN OFFERS
function OfferModal({ 
  isOpen, 
  onClose, 
  item, 
  onSubmit 
}: { 
  isOpen: boolean; 
  onClose: () => void; 
  item: MarketItem | null; 
  onSubmit: (amount: number, duration: string) => void;
}) {
  const [amount, setAmount] = useState<number>(0);
  const [duration, setDuration] = useState("7");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { isConnected, address } = useAccount();
  const chainId = useChainId();
  const { switchChain } = useSwitchChain();
  const { toast } = useToast();
  const { openConnectModal } = useConnectModal();
  
  // V3 Offers hook
  const { makeOffer, isLoading: offerLoading } = useOffersV3();
  
  // Wallet balance
  const [walletBalance, setWalletBalance] = useState<number | null>(null);
  const [balanceLoading, setBalanceLoading] = useState(false);
  
  const durationOptions = [
    { value: "1", label: "1 Day" },
    { value: "3", label: "3 Days" },
    { value: "7", label: "1 Week" },
    { value: "30", label: "1 Month" },
    { value: "90", label: "3 Months" },
  ];

  // Fetch balance
  useEffect(() => {
    if (isOpen && isConnected && address) {
      setBalanceLoading(true);
      const fetchBalance = async () => {
        try {
          const { ethers } = await import('ethers');
          const provider = new ethers.JsonRpcProvider('https://mainnet.basedaibridge.com/rpc/');
          const balance = await provider.getBalance(address);
          setWalletBalance(parseFloat(ethers.formatEther(balance)));
        } catch (e) {
          setWalletBalance(null);
        } finally {
          setBalanceLoading(false);
        }
      };
      fetchBalance();
    }
  }, [isOpen, isConnected, address]);

  // Reset on item change
  useEffect(() => {
    if (item) {
      setAmount(item.price ? Math.floor(item.price * 0.9) : 1000);
      setDuration("7");
    }
  }, [item]);

  const handleSubmit = async () => {
    if (!isConnected) {
      openConnectModal?.();
      return;
    }

    if (chainId !== 32323) {
      switchChain?.({ chainId: 32323 });
      return;
    }

    if (!amount || amount <= 0) {
      toast({ title: "Invalid Amount", description: "Please enter an offer amount", variant: "destructive" });
      return;
    }

    if (!item) return;

    setIsSubmitting(true);
    
    try {
      const success = await makeOffer(item.id, amount, parseInt(duration));
      
      if (success) {
        onClose();
      }
    } catch (e) {
      console.error('Offer submission error:', e);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (!item) return null;

  const isButtonDisabled = !isConnected || balanceLoading || isSubmitting || offerLoading;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="bg-black/95 backdrop-blur-xl border-cyan-500/30 text-white sm:max-w-md" style={{ zIndex: 99999 }}>
        <DialogHeader>
          <DialogTitle className="font-orbitron text-xl flex items-center gap-2">
            <Gavel className="text-cyan-400" size={20} />
            MAKE AN OFFER
          </DialogTitle>
          <DialogDescription className="text-gray-400">
            Offer on <span className="text-cyan-400 font-bold">{item.name}</span>
          </DialogDescription>
        </DialogHeader>

        {/* V3 INFO BANNER */}
        <div className="p-4 rounded-lg bg-green-500/10 border border-green-500/30">
          <div className="flex items-start gap-3">
            <CheckCircle className="w-5 h-5 text-green-400 flex-shrink-0 mt-0.5" />
            <div>
              <p className="font-bold text-green-400 text-sm mb-1">FUNDS STAY IN YOUR WALLET</p>
              <p className="text-xs text-green-200/80">
                This offer is FREE to create (just a signature). Your $BASED stays in your wallet 
                until you complete the purchase after the seller accepts.
              </p>
            </div>
          </div>
        </div>

        <div className="space-y-4 py-4">
          {/* Amount Input */}
          <div className="space-y-2">
            <Label className="text-xs text-cyan-400/70 uppercase font-mono">OFFER AMOUNT ($BASED)</Label>
            <div className="flex gap-2">
              <Input 
                type="text"
                inputMode="numeric"
                value={amount || ''} 
                onChange={(e) => {
                  const val = e.target.value.replace(/[^0-9]/g, '');
                  setAmount(val ? parseInt(val, 10) : 0);
                }}
                className="bg-white/5 border-white/20 text-white font-mono text-lg"
                placeholder="Enter amount..."
              />
              <Button 
                variant="outline" 
                size="sm" 
                onClick={() => walletBalance && setAmount(Math.floor(walletBalance * 0.95))}
                disabled={!walletBalance}
                className="bg-cyan-500/10 border-cyan-500/30 text-cyan-400 hover:bg-cyan-500/20"
              >
                MAX
              </Button>
            </div>
            <div className="text-xs text-muted-foreground">
              {balanceLoading ? 'Loading...' : walletBalance !== null ? (
                <>Balance: <span className="text-cyan-400">{walletBalance.toLocaleString()}</span> $BASED</>
              ) : 'Connect wallet to see balance'}
            </div>
          </div>

          {/* Duration */}
          <div className="space-y-2">
            <Label className="text-xs text-cyan-400/70 uppercase font-mono">OFFER DURATION</Label>
            <Select value={duration} onValueChange={setDuration}>
              <SelectTrigger className="bg-white/5 border-white/20 text-white">
                <Timer size={16} className="mr-2 text-cyan-400" />
                <SelectValue />
              </SelectTrigger>
              <SelectContent className="bg-black/95 border-cyan-500/30" style={{ zIndex: 999999 }}>
                {durationOptions.map((opt) => (
                  <SelectItem key={opt.value} value={opt.value} className="text-white hover:bg-cyan-500/20">
                    {opt.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Flow Explanation */}
          <div className="p-3 rounded-lg bg-white/5 border border-white/10 space-y-2 text-xs">
            <div className="flex items-center gap-2 text-white">
              <span className="w-5 h-5 rounded-full bg-cyan-500/20 flex items-center justify-center text-cyan-400">1</span>
              <span>You sign offer (FREE - no gas)</span>
            </div>
            <div className="flex items-center gap-2 text-muted-foreground">
              <span className="w-5 h-5 rounded-full bg-white/10 flex items-center justify-center">2</span>
              <span>Seller accepts â†’ You get notified</span>
            </div>
            <div className="flex items-center gap-2 text-muted-foreground">
              <span className="w-5 h-5 rounded-full bg-white/10 flex items-center justify-center">3</span>
              <span>Complete purchase within 24h</span>
            </div>
          </div>
        </div>

        <DialogFooter className="flex gap-3 flex-col sm:flex-row">
          <Button variant="ghost" onClick={onClose} className="flex-1 border border-white/20">
            CANCEL
          </Button>
          <Button 
            onClick={handleSubmit}
            disabled={isButtonDisabled}
            className={`flex-1 font-bold font-orbitron h-12 ${
              isButtonDisabled
                ? 'bg-gray-700 text-gray-400'
                : 'bg-gradient-to-r from-cyan-500 to-cyan-400 text-black hover:from-cyan-400 hover:to-cyan-300 shadow-[0_0_20px_rgba(0,255,255,0.4)]'
            }`}
          >
            {isSubmitting || offerLoading ? (
              <span className="flex items-center gap-2">
                <Loader2 className="animate-spin" size={18} />
                SIGNING...
              </span>
            ) : !isConnected ? (
              'CONNECT WALLET'
            ) : (
              <span className="flex items-center gap-2">
                <Gavel size={18} />
                SIGN OFFER (FREE)
              </span>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


=====================================================================
FILE 4: Add import at top of EscrowMarketplace.tsx
=====================================================================

Add this import near the top of EscrowMarketplace.tsx with other imports:

import { useOffersV3 } from '@/hooks/useOffersV3';
import { MyOffersPanel } from '@/components/MyOffersPanel';
import { CheckCircle, Timer, Loader2 } from 'lucide-react';


=====================================================================
FILE 5: Add "MY OFFERS" Tab in EscrowMarketplace.tsx
=====================================================================

In the Tabs component, add a new tab for "MY OFFERS". Find the TabsList and add:

<TabsTrigger value="my-offers" className="data-[state=active]:bg-cyan-500 data-[state=active]:text-black font-orbitron">
    <Gavel size={14} className="mr-2" /> MY OFFERS
</TabsTrigger>

Then add the TabsContent after the "offers" TabsContent:

<TabsContent value="my-offers">
    <MyOffersPanel />
</TabsContent>


=====================================================================
FILE 6: Update lib/constants.ts - Add V3 Contract
=====================================================================

Add to constants.ts (keep V2 for backwards compatibility):

// Marketplace V3 - off-chain offers, on-chain settlement (Aftermint style)
// UPDATE THIS after deploying V3 contract
export const MARKETPLACE_V3_CONTRACT = "0x_YOUR_V3_ADDRESS_HERE";


=====================================================================
SUMMARY OF CHANGES
=====================================================================

1. NEW: hooks/useOffersV3.ts
   - Sign offers off-chain (EIP-712)
   - Store offers in localStorage
   - Handle accept, complete, cancel flows
   - Track user's nonce for replay protection

2. NEW: components/MyOffersPanel.tsx
   - Shows all user's pending offers
   - Easy one-click cancel
   - Status badges (pending, accepted, expired)
   - Complete purchase button for accepted offers

3. UPDATED: components/EscrowMarketplace.tsx
   - New OfferModal using V3 off-chain signing
   - Clear messaging: "Funds stay in wallet"
   - Step-by-step flow visualization
   - "MY OFFERS" tab added

4. UPDATED: lib/constants.ts
   - Add MARKETPLACE_V3_CONTRACT address

KEY FEATURES:
âœ… Making offers is FREE (just signature, no gas)
âœ… Funds stay in buyer's wallet until purchase completes
âœ… Easy cancel from "My Offers" panel
âœ… 24-hour completion window after seller accepts
âœ… Works exactly like Aftermint

AFTER DEPLOYING V3 CONTRACT:
1. Update MARKETPLACE_V3_CONTRACT in constants.ts
2. Update MARKETPLACE_V3_CONTRACT in useOffersV3.ts
3. Users need to approve the new V3 contract for their NFTs