I need to add a Governance/Voting system to my NFT dApp. Please add these 2 new files and update constants:

---

## 1. UPDATE: `client/src/lib/constants.ts`

Add this line after MARKETPLACE_CONTRACT:

export const GOVERNANCE_CONTRACT = "0x2B107A4Ea8fCC4FAa6d55a5bEeb5E2740C849995"; // DAO Governance

---

## 2. NEW FILE: `client/src/hooks/useGovernance.ts`

/**
 * useGovernance Hook - Governance/Voting functionality
 */

import { useAccount, useReadContract, useWriteContract, useWaitForTransactionReceipt } from 'wagmi';
import { parseEther, formatEther } from 'viem';
import { useState, useCallback } from 'react';
import { NFT_CONTRACT } from '@/lib/constants';

export const GOVERNANCE_CONTRACT = "0x2B107A4Ea8fCC4FAa6d55a5bEeb5E2740C849995";

export enum ProposalStatus { Pending = 0, Active = 1, Passed = 2, Failed = 3, Executed = 4, Cancelled = 5 }

export const PROPOSAL_STATUS_LABELS: Record<ProposalStatus, string> = {
  [ProposalStatus.Pending]: 'Pending', [ProposalStatus.Active]: 'Active', [ProposalStatus.Passed]: 'Passed',
  [ProposalStatus.Failed]: 'Failed', [ProposalStatus.Executed]: 'Executed', [ProposalStatus.Cancelled]: 'Cancelled'
};

export const PROPOSAL_STATUS_COLORS: Record<ProposalStatus, string> = {
  [ProposalStatus.Pending]: 'text-gray-400', [ProposalStatus.Active]: 'text-cyan-400', [ProposalStatus.Passed]: 'text-green-400',
  [ProposalStatus.Failed]: 'text-red-400', [ProposalStatus.Executed]: 'text-purple-400', [ProposalStatus.Cancelled]: 'text-gray-500'
};

export interface Proposal {
  id: bigint; proposer: string; title: string; description: string; category: string;
  startTime: bigint; endTime: bigint; votesFor: bigint; votesAgainst: bigint;
  totalVoters: bigint; executed: boolean; cancelled: boolean; status: ProposalStatus;
}

const GOVERNANCE_ABI = [
  { name: 'proposalCount', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'getProposal', type: 'function', stateMutability: 'view', inputs: [{ name: '_proposalId', type: 'uint256' }],
    outputs: [{ type: 'tuple', components: [
      { name: 'id', type: 'uint256' }, { name: 'proposer', type: 'address' }, { name: 'title', type: 'string' },
      { name: 'description', type: 'string' }, { name: 'category', type: 'string' }, { name: 'startTime', type: 'uint256' },
      { name: 'endTime', type: 'uint256' }, { name: 'votesFor', type: 'uint256' }, { name: 'votesAgainst', type: 'uint256' },
      { name: 'totalVoters', type: 'uint256' }, { name: 'executed', type: 'bool' }, { name: 'cancelled', type: 'bool' }, { name: 'status', type: 'uint8' }
    ]}]
  },
  { name: 'getVoteInfo', type: 'function', stateMutability: 'view',
    inputs: [{ name: '_proposalId', type: 'uint256' }, { name: '_voter', type: 'address' }],
    outputs: [{ name: 'voted', type: 'bool' }, { name: 'support', type: 'bool' }, { name: 'power', type: 'uint256' }]
  },
  { name: 'getVotingPower', type: 'function', stateMutability: 'view', inputs: [{ name: '_voter', type: 'address' }], outputs: [{ type: 'uint256' }] },
  { name: 'getActiveProposals', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256[]' }] },
  { name: 'isVotingActive', type: 'function', stateMutability: 'view', inputs: [{ name: '_proposalId', type: 'uint256' }], outputs: [{ type: 'bool' }] },
  { name: 'getTimeRemaining', type: 'function', stateMutability: 'view', inputs: [{ name: '_proposalId', type: 'uint256' }], outputs: [{ type: 'uint256' }] },
  { name: 'votingPeriod', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'quorumPercentage', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'minNFTsToPropose', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'createProposal', type: 'function', stateMutability: 'nonpayable',
    inputs: [{ name: '_title', type: 'string' }, { name: '_description', type: 'string' }, { name: '_category', type: 'string' }], outputs: [{ type: 'uint256' }] },
  { name: 'vote', type: 'function', stateMutability: 'nonpayable', inputs: [{ name: '_proposalId', type: 'uint256' }, { name: '_support', type: 'bool' }], outputs: [] },
  { name: 'finalizeProposal', type: 'function', stateMutability: 'nonpayable', inputs: [{ name: '_proposalId', type: 'uint256' }], outputs: [] },
  { name: 'cancelProposal', type: 'function', stateMutability: 'nonpayable', inputs: [{ name: '_proposalId', type: 'uint256' }], outputs: [] }
] as const;

export function useGovernance() {
  const { address, isConnected } = useAccount();
  const [pendingAction, setPendingAction] = useState<string | null>(null);
  const { writeContract, data: txHash, isPending, error: writeError, reset } = useWriteContract();
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash: txHash });

  const { data: proposalCount, refetch: refetchCount } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'proposalCount' });
  const { data: votingPower } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'getVotingPower', args: address ? [address] : undefined });
  const { data: minNFTsToPropose } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'minNFTsToPropose' });
  const { data: quorumPercentage } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'quorumPercentage' });
  const { data: activeProposalIds, refetch: refetchActive } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'getActiveProposals' });

  const createProposal = useCallback(async (title: string, description: string, category: string) => {
    if (!isConnected) throw new Error('Wallet not connected');
    setPendingAction('createProposal');
    writeContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'createProposal', args: [title, description, category] });
  }, [isConnected, writeContract]);

  const vote = useCallback(async (proposalId: number, support: boolean) => {
    if (!isConnected) throw new Error('Wallet not connected');
    setPendingAction('vote');
    writeContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'vote', args: [BigInt(proposalId), support] });
  }, [isConnected, writeContract]);

  const finalizeProposal = useCallback(async (proposalId: number) => {
    setPendingAction('finalize');
    writeContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'finalizeProposal', args: [BigInt(proposalId)] });
  }, [writeContract]);

  const cancelProposal = useCallback(async (proposalId: number) => {
    if (!isConnected) throw new Error('Wallet not connected');
    setPendingAction('cancel');
    writeContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'cancelProposal', args: [BigInt(proposalId)] });
  }, [isConnected, writeContract]);

  const canCreateProposal = isConnected && votingPower !== undefined && minNFTsToPropose !== undefined && votingPower >= minNFTsToPropose;

  return {
    isConnected, address, pendingAction, isPending, isConfirming, isSuccess, txHash, error: writeError, reset,
    proposalCount: proposalCount ? Number(proposalCount) : 0, votingPower: votingPower ? Number(votingPower) : 0,
    minNFTsToPropose: minNFTsToPropose ? Number(minNFTsToPropose) : 1, quorumPercentage: quorumPercentage ? Number(quorumPercentage) : 10,
    activeProposalIds: activeProposalIds || [], canCreateProposal,
    createProposal, vote, finalizeProposal, cancelProposal, refetchCount, refetchActive
  };
}

export function useProposal(proposalId: number | undefined) {
  const { address } = useAccount();
  const { data: proposal, isLoading, refetch } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'getProposal', args: proposalId !== undefined ? [BigInt(proposalId)] : undefined });
  const { data: voteInfo } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'getVoteInfo', args: proposalId !== undefined && address ? [BigInt(proposalId), address] : undefined });
  const { data: isActive } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'isVotingActive', args: proposalId !== undefined ? [BigInt(proposalId)] : undefined });
  const { data: timeRemaining } = useReadContract({ address: GOVERNANCE_CONTRACT as `0x${string}`, abi: GOVERNANCE_ABI, functionName: 'getTimeRemaining', args: proposalId !== undefined ? [BigInt(proposalId)] : undefined });
  return { proposal: proposal as Proposal | undefined, isLoading, refetch, userVote: voteInfo ? { hasVoted: voteInfo[0], support: voteInfo[1], power: Number(voteInfo[2]) } : null, isActive: isActive ?? false, timeRemaining: timeRemaining ? Number(timeRemaining) : 0 };
}

export function formatTimeRemaining(seconds: number): string {
  if (seconds <= 0) return 'Ended';
  const days = Math.floor(seconds / 86400); const hours = Math.floor((seconds % 86400) / 3600); const mins = Math.floor((seconds % 3600) / 60);
  if (days > 0) return `${days}d ${hours}h left`; if (hours > 0) return `${hours}h ${mins}m left`; return `${mins}m left`;
}

export function calculateVotePercentage(votesFor: bigint, votesAgainst: bigint): { forPercent: number; againstPercent: number; total: number } {
  const forNum = Number(votesFor); const againstNum = Number(votesAgainst); const total = forNum + againstNum;
  if (total === 0) return { forPercent: 0, againstPercent: 0, total: 0 };
  return { forPercent: Math.round((forNum / total) * 100), againstPercent: Math.round((againstNum / total) * 100), total };
}

---

## 3. NEW FILE: `client/src/components/Governance.tsx`

Create a Governance voting component with these features:
- Header with "GUARDIAN GOVERNANCE" title and voting power display
- Stats grid: Total Proposals, Min NFTs to Propose, Quorum Required, Your NFTs
- Create Proposal form with title, category selector, and description
- Proposals list showing all proposals with expandable cards
- Each proposal shows: ID, category, status badge, title, voter count, time remaining
- Expanded view shows: description, vote progress bars (For/Against with percentages)
- Vote For/Against buttons (green/red) when voting is active
- Shows "Already voted" message if user voted
- Uses framer-motion for animations
- Uses lucide-react icons: Vote, Plus, Clock, CheckCircle2, XCircle, Users, Zap, ChevronDown, ChevronUp, Loader2, AlertCircle
- Import useGovernance, useProposal, ProposalStatus, PROPOSAL_STATUS_LABELS, PROPOSAL_STATUS_COLORS, formatTimeRemaining, calculateVotePercentage from '@/hooks/useGovernance'
- Categories: Community, Treasury, Roadmap, Partnership, Other

Then add a "Governance" or "Vote" navigation link/tab to the app that routes to this component.

---

Contract Address: 0x2B107A4Ea8fCC4FAa6d55a5bEeb5E2740C849995
Features: 1 NFT = 1 Vote, 3-day voting periods, 10% quorum, NFT holders create proposals