TECHNICAL FIX: Implement global error handling with user-friendly feedback

Create services/ErrorHandler.js:

const ErrorHandler = {
  toastContainer: null,
  
  initialize() {
    // Create toast container if doesn't exist
    if (!this.toastContainer) {
      this.toastContainer = document.createElement('div');
      this.toastContainer.id = 'toast-container';
      this.toastContainer.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
      `;
      document.body.appendChild(this.toastContainer);
    }
  },
  
  // Show toast notification
  toast(message, type = 'info', duration = 5000) {
    this.initialize();
    
    const toast = document.createElement('div');
    toast.style.cssText = `
      padding: 14px 20px;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      max-width: 350px;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      pointer-events: auto;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    
    const colors = {
      success: '#16a34a',
      error: '#dc2626',
      warning: '#d97706',
      info: '#2563eb'
    };
    
    const icons = {
      success: '✓',
      error: '✕',
      warning: '⚠',
      info: 'ℹ'
    };
    
    toast.style.background = colors[type] || colors.info;
    toast.innerHTML = `<span>${icons[type]}</span><span>${Sanitizer.escapeHtml(message)}</span>`;
    
    toast.onclick = () => this._removeToast(toast);
    
    this.toastContainer.appendChild(toast);
    
    // Animate in
    requestAnimationFrame(() => {
      toast.style.opacity = '1';
      toast.style.transform = 'translateX(0)';
    });
    
    // Auto remove
    if (duration > 0) {
      setTimeout(() => this._removeToast(toast), duration);
    }
    
    return toast;
  },
  
  _removeToast(toast) {
    toast.style.opacity = '0';
    toast.style.transform = 'translateX(100%)';
    setTimeout(() => toast.remove(), 300);
  },
  
  // Handle errors with user-friendly messages
  handle(error, context = '') {
    console.error(`[${context}]`, error);
    
    // Map technical errors to user-friendly messages
    const errorMessages = {
      'user rejected': 'Transaction cancelled',
      'insufficient funds': 'Insufficient funds for this transaction',
      'network': 'Network connection issue. Please check your internet.',
      'timeout': 'Request timed out. Please try again.',
      'CALL_EXCEPTION': 'Transaction would fail. Check your inputs.',
      '4001': 'Request rejected',
      '-32002': 'Please check your wallet - a request is pending',
      '-32603': 'Internal wallet error. Try refreshing the page.',
      'nonce': 'Transaction conflict. Please wait and try again.',
    };
    
    let userMessage = 'An unexpected error occurred';
    const errorStr = error.message?.toLowerCase() || String(error.code);
    
    for (const [key, msg] of Object.entries(errorMessages)) {
      if (errorStr.includes(key.toLowerCase())) {
        userMessage = msg;
        break;
      }
    }
    
    this.toast(userMessage, 'error');
    return userMessage;
  },
  
  // Wrapper for async operations
  async wrapAsync(fn, context = '', showSuccess = false) {
    try {
      const result = await fn();
      if (showSuccess) {
        this.toast('Operation completed successfully', 'success', 3000);
      }
      return result;
    } catch (error) {
      this.handle(error, context);
      return null;
    }
  },
  
  // Loading indicator
  showLoading(message = 'Loading...') {
    return this.toast(message, 'info', 0); // 0 = don't auto-remove
  }
};

window.ErrorHandler = ErrorHandler;

// Global error handler for uncaught errors
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  ErrorHandler.handle(event.reason, 'Unhandled');
});