IMPLEMENT SAFE NFT PORTFOLIO DISPLAY FOR BASED GUARDIANS

GOAL: Show users which Based Guardians NFTs they own in their Portfolio, with safe fetching, caching, and no browser crashes.

SAFETY REQUIREMENTS:
- Only fetch from Based Guardians contract (not all collections)
- Use caching to avoid repeated RPC calls
- Timeout protection (abort after 15 seconds)
- Progressive loading (show NFTs as they load)
- Error handling and fallback UI

═══════════════════════════════════════════════════════════════════
STEP 1: CREATE SAFE NFT FETCHER HOOK
═══════════════════════════════════════════════════════════════════

1. CREATE FILE: client/src/hooks/useUserNFTs.ts

import { useState, useEffect } from 'react';
import { useAccount } from 'wagmi';
import { ethers } from 'ethers';
import { NFT_CONTRACT, RPC_URL } from '@/lib/constants';

interface NFTData {
  tokenId: number;
  name: string;
  image: string;
  attributes?: any[];
  owner: string;
}

const NFT_ABI = [
  'function balanceOf(address owner) view returns (uint256)',
  'function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)',
  'function tokenURI(uint256 tokenId) view returns (string)',
  'function ownerOf(uint256 tokenId) view returns (address)',
];

// Cache to avoid re-fetching
const nftCache = new Map<string, { data: NFTData[]; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

export function useUserNFTs() {
  const { address } = useAccount();
  const [nfts, setNfts] = useState<NFTData[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!address) {
      setNfts([]);
      return;
    }

    fetchUserNFTs(address);
  }, [address]);

  async function fetchUserNFTs(userAddress: string) {
    try {
      setLoading(true);
      setError(null);

      // Check cache first
      const cached = nftCache.get(userAddress.toLowerCase());
      if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
        console.log('[useUserNFTs] Using cached data');
        setNfts(cached.data);
        setLoading(false);
        return;
      }

      console.log('[useUserNFTs] Fetching NFTs for', userAddress);

      const provider = new ethers.JsonRpcProvider(RPC_URL);
      const contract = new ethers.Contract(NFT_CONTRACT, NFT_ABI, provider);

      // Step 1: Get balance (one RPC call)
      const balancePromise = contract.balanceOf(userAddress);
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Balance fetch timeout')), 10000)
      );

      const balance = await Promise.race([balancePromise, timeoutPromise]);
      const balanceNum = Number(balance);

      console.log('[useUserNFTs] User owns', balanceNum, 'NFTs');

      if (balanceNum === 0) {
        setNfts([]);
        setLoading(false);
        return;
      }

      // Step 2: Get token IDs (batch of up to 50)
      const maxToFetch = Math.min(balanceNum, 50); // Limit to 50 for safety
      const tokenIdPromises: Promise<any>[] = [];

      for (let i = 0; i < maxToFetch; i++) {
        tokenIdPromises.push(
          contract.tokenOfOwnerByIndex(userAddress, i).catch((err: any) => {
            console.warn(`[useUserNFTs] Failed to get token at index ${i}:`, err);
            return null;
          })
        );
      }

      // Fetch all token IDs with timeout
      const tokenIdsTimeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Token IDs timeout')), 15000)
      );

      const tokenIdsResults = await Promise.race([
        Promise.all(tokenIdPromises),
        tokenIdsTimeout,
      ]);

      const tokenIds = tokenIdsResults
        .filter((id: any) => id !== null)
        .map((id: any) => Number(id));

      console.log('[useUserNFTs] Found token IDs:', tokenIds);

      // Step 3: Fetch metadata progressively
      const nftData: NFTData[] = [];

      for (const tokenId of tokenIds) {
        try {
          // Fetch with individual timeout
          const metadataPromise = fetchNFTMetadata(contract, tokenId, userAddress);
          const metadataTimeout = new Promise<NFTData | null>((_, reject) =>
            setTimeout(() => reject(new Error('Metadata timeout')), 8000)
          );

          const metadata = await Promise.race([metadataPromise, metadataTimeout]);

          if (metadata) {
            nftData.push(metadata);
            // Update UI progressively as we fetch each NFT
            setNfts([...nftData]);
          }
        } catch (err) {
          console.warn(`[useUserNFTs] Failed to fetch metadata for token ${tokenId}:`, err);
          // Add placeholder for failed NFTs
          nftData.push({
            tokenId,
            name: `Based Guardian #${tokenId}`,
            image: '/placeholder-nft.png',
            owner: userAddress,
          });
          setNfts([...nftData]);
        }
      }

      // Cache the results
      nftCache.set(userAddress.toLowerCase(), {
        data: nftData,
        timestamp: Date.now(),
      });

      setNfts(nftData);
      console.log('[useUserNFTs] Fetch complete. Total NFTs:', nftData.length);
    } catch (err: any) {
      console.error('[useUserNFTs] Error fetching NFTs:', err);
      setError(err.message || 'Failed to fetch NFTs');
    } finally {
      setLoading(false);
    }
  }

  return { nfts, loading, error, refetch: () => address && fetchUserNFTs(address) };
}

async function fetchNFTMetadata(
  contract: ethers.Contract,
  tokenId: number,
  owner: string
): Promise<NFTData | null> {
  try {
    const tokenURI = await contract.tokenURI(tokenId);

    let metadataUrl = tokenURI;
    if (tokenURI.startsWith('ipfs://')) {
      metadataUrl = tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/');
    }

    // Fetch metadata with timeout
    const response = await fetch(metadataUrl, {
      signal: AbortSignal.timeout(5000),
    });

    if (!response.ok) {
      throw new Error('Metadata fetch failed');
    }

    const metadata = await response.json();

    let imageUrl = metadata.image || '/placeholder-nft.png';
    if (imageUrl.startsWith('ipfs://')) {
      imageUrl = imageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');
    }

    return {
      tokenId,
      name: metadata.name || `Based Guardian #${tokenId}`,
      image: imageUrl,
      attributes: metadata.attributes || [],
      owner,
    };
  } catch (err) {
    console.warn(`[fetchNFTMetadata] Failed for token ${tokenId}:`, err);
    return null;
  }
}


═══════════════════════════════════════════════════════════════════
STEP 2: UPDATE PORTFOLIO PAGE TO USE SAFE FETCHER
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: client/src/pages/Portfolio.tsx

Add import at top:
import { useUserNFTs } from '@/hooks/useUserNFTs';

Add this in the component (after the wallet connection check):

const { nfts, loading: nftsLoading, error: nftsError, refetch } = useUserNFTs();

Find the section where NFTs are displayed and replace with:

{/* User's NFTs Section */}
<div className="mb-8">
  <div className="flex items-center justify-between mb-4">
    <h2 className="text-2xl font-bold">Your Guardians</h2>
    {!nftsLoading && (
      <Button
        variant="outline"
        size="sm"
        onClick={refetch}
        className="gap-2"
      >
        <RefreshCw className="w-4 h-4" />
        Refresh
      </Button>
    )}
  </div>

  {nftsLoading && nfts.length === 0 && (
    <div className="flex items-center justify-center py-12">
      <Loader2 className="w-8 h-8 animate-spin text-primary mr-3" />
      <span>Loading your NFTs...</span>
    </div>
  )}

  {nftsError && (
    <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4 text-center">
      <p className="text-destructive">Failed to load NFTs: {nftsError}</p>
      <Button onClick={refetch} className="mt-3" variant="outline" size="sm">
        Try Again
      </Button>
    </div>
  )}

  {!nftsLoading && !nftsError && nfts.length === 0 && (
    <div className="text-center py-12 bg-card border border-primary/20 rounded-lg">
      <div className="text-muted-foreground mb-4">
        <Package className="w-16 h-16 mx-auto mb-3 opacity-50" />
        <p className="text-lg">No Guardians found</p>
        <p className="text-sm mt-2">Mint your first Guardian to get started!</p>
      </div>
      <Link href="/mint">
        <Button className="mt-4">
          Mint Now
        </Button>
      </Link>
    </div>
  )}

  {nfts.length > 0 && (
    <>
      <div className="text-sm text-muted-foreground mb-4">
        Showing {nfts.length} Guardian{nfts.length !== 1 ? 's' : ''}
        {nftsLoading && ' • Loading more...'}
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        {nfts.map((nft) => (
          <motion.div
            key={nft.tokenId}
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            className="group bg-card border border-primary/20 rounded-lg overflow-hidden hover:border-primary/50 hover:shadow-lg hover:shadow-primary/20 transition-all duration-300"
          >
            {/* NFT Image */}
            <div className="relative aspect-square overflow-hidden bg-gradient-to-br from-primary/20 to-purple-500/20">
              <img
                src={nft.image}
                alt={nft.name}
                className="w-full h-full object-cover group-hover:scale-110 transition-transform duration-300"
                loading="lazy"
                onError={(e) => {
                  e.currentTarget.src = '/placeholder-nft.png';
                }}
              />
              <div className="absolute top-2 right-2 bg-primary/90 backdrop-blur-sm px-2 py-1 rounded-full text-xs font-semibold">
                #{nft.tokenId}
              </div>
            </div>

            {/* NFT Info */}
            <div className="p-4">
              <h3 className="font-bold text-lg mb-2 truncate group-hover:text-primary transition-colors">
                {nft.name}
              </h3>

              {nft.attributes && nft.attributes.length > 0 && (
                <div className="space-y-1 mb-3">
                  {nft.attributes.slice(0, 3).map((attr: any, i: number) => (
                    <div key={i} className="flex justify-between text-xs">
                      <span className="text-muted-foreground">{attr.trait_type}:</span>
                      <span className="font-semibold">{attr.value}</span>
                    </div>
                  ))}
                </div>
              )}

              <div className="flex gap-2 mt-4">
                <Link href={`/marketplace/${nft.tokenId}`} className="flex-1">
                  <Button variant="outline" size="sm" className="w-full">
                    View Details
                  </Button>
                </Link>
                <Link href={`/marketplace?action=list&tokenId=${nft.tokenId}`} className="flex-1">
                  <Button size="sm" className="w-full">
                    List for Sale
                  </Button>
                </Link>
              </div>
            </div>
          </motion.div>
        ))}
      </div>
    </>
  )}
</div>


═══════════════════════════════════════════════════════════════════
STEP 3: ADD MISSING IMPORTS TO PORTFOLIO
═══════════════════════════════════════════════════════════════════

1. UPDATE FILE: client/src/pages/Portfolio.tsx

Make sure these imports are at the top:

import { RefreshCw, Package, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { motion } from 'framer-motion';
import { Link } from 'wouter';


═══════════════════════════════════════════════════════════════════
STEP 4: ADD PLACEHOLDER IMAGE
═══════════════════════════════════════════════════════════════════

1. CREATE FILE: public/placeholder-nft.png

If you don't have a placeholder image, we'll use a fallback.

2. UPDATE the image fallback in Portfolio.tsx:

Replace:
onError={(e) => {
  e.currentTarget.src = '/placeholder-nft.png';
}}

With:
onError={(e) => {
  e.currentTarget.src = 'https://via.placeholder.com/400/6366f1/ffffff?text=Guardian';
}}


═══════════════════════════════════════════════════════════════════
STEP 5: TEST THE IMPLEMENTATION
═══════════════════════════════════════════════════════════════════

1. Connect your wallet (one that owns Based Guardians NFTs)

2. Navigate to /profile or /portfolio

3. You should see:
   ✓ Loading spinner while fetching
   ✓ NFTs appear progressively as they load
   ✓ Each NFT shows image, name, ID, and attributes
   ✓ "View Details" and "List for Sale" buttons
   ✓ Refresh button to re-fetch

4. Check browser console:
   - Should see: "[useUserNFTs] User owns X NFTs"
   - Should see: "[useUserNFTs] Fetch complete. Total NFTs: X"
   - NO errors about infinite loops or memory issues

5. Test with wallet that owns 0 NFTs:
   - Should show "No Guardians found" message
   - Should not crash or freeze

6. Test refresh button:
   - Uses cache if within 5 minutes
   - Re-fetches if cache expired


═══════════════════════════════════════════════════════════════════
SAFETY FEATURES IMPLEMENTED
═══════════════════════════════════════════════════════════════════

✅ Only queries OUR contract (not scanning 18 collections)
✅ Caching prevents repeated fetches (5 min cache)
✅ Timeouts on all RPC calls (10-15 seconds max)
✅ Progressive loading (shows NFTs as they load)
✅ Error handling for each NFT (doesn't fail entire fetch)
✅ Limits to 50 NFTs max (prevents crashes for whales)
✅ No infinite loops or memory leaks
✅ Graceful fallbacks for missing images/metadata
✅ Manual refresh button (not auto-polling)

DONE! Users can now safely see their Based Guardians NFTs in Portfolio.