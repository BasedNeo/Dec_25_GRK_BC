interface AnalyticsEvent {
  event: string;
  properties?: Record<string, any>;
  timestamp: number;
  sessionId: string;
  userId?: string;
}

class AnalyticsManager {
  private sessionId: string;
  private userId?: string;
  private queue: AnalyticsEvent[] = [];
  private flushInterval: number = 10000; // 10 seconds
  private maxQueueSize: number = 50;
  private timer?: number;

  constructor() {
    this.sessionId = this.getOrCreateSessionId();
    this.startAutoFlush();
    
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', () => {
        this.flush();
      });
    }
  }

  private getOrCreateSessionId(): string {
    const existing = sessionStorage.getItem('analytics_session');
    if (existing) return existing;
    
    const newId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    sessionStorage.setItem('analytics_session', newId);
    return newId;
  }

  setUserId(userId: string) {
    this.userId = userId;
  }

  track(event: string, properties?: Record<string, any>) {
    const analyticsEvent: AnalyticsEvent = {
      event,
      properties: {
        ...properties,
        url: window.location.href,
        referrer: document.referrer,
        userAgent: navigator.userAgent,
        screenWidth: window.innerWidth,
        screenHeight: window.innerHeight,
      },
      timestamp: Date.now(),
      sessionId: this.sessionId,
      userId: this.userId,
    };

    this.queue.push(analyticsEvent);
    console.log(`[Analytics] ${event}`, properties);

    if (this.queue.length >= this.maxQueueSize) {
      this.flush();
    }
  }

  private startAutoFlush() {
    this.timer = window.setInterval(() => {
      if (this.queue.length > 0) {
        this.flush();
      }
    }, this.flushInterval);
  }

  private async flush() {
    if (this.queue.length === 0) return;

    const events = [...this.queue];
    this.queue = [];

    try {
      await fetch('/api/analytics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ events }),
      });
    } catch (error) {
      console.error('[Analytics] Failed to send events:', error);
      this.queue.unshift(...events);
    }
  }

  pageView(pageName: string) {
    this.track('page_view', { page: pageName });
  }

  walletConnected(address: string) {
    this.setUserId(address);
    this.track('wallet_connected', { address });
  }

  walletDisconnected() {
    this.track('wallet_disconnected');
    this.userId = undefined;
  }

  mintStarted(quantity: number) {
    this.track('mint_started', { quantity });
  }

  mintCompleted(quantity: number, txHash: string, totalCost: number) {
    this.track('mint_completed', { quantity, txHash, totalCost });
  }

  mintFailed(quantity: number, error: string) {
    this.track('mint_failed', { quantity, error });
  }

  listingStarted(tokenId: number, price: number) {
    this.track('listing_started', { tokenId, price });
  }

  listingCompleted(tokenId: number, price: number, txHash: string) {
    this.track('listing_completed', { tokenId, price, txHash });
  }

  buyStarted(tokenId: number, price: number) {
    this.track('buy_started', { tokenId, price });
  }

  buyCompleted(tokenId: number, price: number, txHash: string) {
    this.track('buy_completed', { tokenId, price, txHash });
  }

  buyFailed(tokenId: number, price: number, error: string) {
    this.track('buy_failed', { tokenId, price, error });
  }

  offerStarted(tokenId: number, amount: number) {
    this.track('offer_started', { tokenId, amount });
  }

  offerCompleted(tokenId: number, amount: number, txHash: string) {
    this.track('offer_completed', { tokenId, amount, txHash });
  }

  gameStarted() {
    this.track('game_started');
  }

  gameCompleted(score: number, level: number) {
    this.track('game_completed', { score, level });
  }

  customNameSet(name: string) {
    this.track('custom_name_set', { name });
  }

  searchPerformed(query: string, results: number) {
    this.track('search', { query, results });
  }

  filterApplied(filterType: string, filterValue: any) {
    this.track('filter_applied', { filterType, filterValue });
  }

  buttonClicked(buttonName: string, location: string) {
    this.track('button_click', { buttonName, location });
  }

  errorOccurred(errorMessage: string, errorStack?: string, feature?: string) {
    this.track('error', { errorMessage, errorStack, feature });
  }
}

export const analytics = new AnalyticsManager();

export function initAnalytics() {
  console.log('[Analytics] Initialized');
  analytics.pageView(window.location.pathname);
}