GAME OPTIMIZATION: Make Cyber Breach High-Quality, Crisp, Smooth, Premium

Goal: Professional-grade graphics, 60 FPS performance, crisp rendering
Game: Cyber Breach (RingO-style hacking game)

═══════════════════════════════════════════════════════════════════
OPTIMIZATION REQUIREMENTS
═══════════════════════════════════════════════════════════════════

VISUAL QUALITY:
✅ Crisp, anti-aliased graphics (no pixelation)
✅ Smooth animations (60 FPS)
✅ High-resolution sprites and text
✅ Professional color scheme with depth
✅ Particle effects for interactions
✅ Smooth gradient backgrounds
✅ Premium UI elements

PERFORMANCE:
✅ Optimized canvas rendering
✅ RequestAnimationFrame for smooth updates
✅ Efficient collision detection
✅ No lag or stutter
✅ Responsive on all devices
✅ Proper cleanup to prevent memory leaks

FEATURES TO ADD:
✅ Smooth player movement with interpolation
✅ Trail effects for player movement
✅ Particle explosions when collecting data
✅ Screen shake on significant events
✅ Smooth camera follow
✅ High-quality fonts
✅ Crisp ring rendering with gradients
✅ Professional HUD with animations
✅ Victory/game over animations


═══════════════════════════════════════════════════════════════════
IMPLEMENTATION INSTRUCTIONS
═══════════════════════════════════════════════════════════════════

File: client/src/components/games/CyberBreach.tsx

COMPLETELY REWRITE the game with these optimizations:

1. CANVAS SETUP:
   - Use high DPI scaling (devicePixelRatio)
   - Set imageSmoothingEnabled for anti-aliasing
   - Use proper canvas dimensions for crisp rendering

2. RENDERING:
   - Use gradients instead of solid colors
   - Add shadows and glows for depth
   - Render with sub-pixel accuracy
   - Use requestAnimationFrame for 60 FPS

3. PLAYER MOVEMENT:
   - Smooth acceleration/deceleration
   - Add motion trails
   - Interpolate between positions

4. VISUAL EFFECTS:
   - Particle system for collections
   - Screen shake for impact
   - Smooth transitions
   - Glow effects on rings
   - Animated HUD elements

5. RINGS:
   - Render with gradients (cyan to blue)
   - Add inner shadows
   - Smooth rotation animation
   - Pulsing effect

6. ENEMIES:
   - Smooth movement patterns
   - Gradient rendering
   - Warning indicators
   - Death animations

7. HUD:
   - High-quality fonts
   - Smooth number animations
   - Icon-based UI
   - Semi-transparent panels with blur

8. BACKGROUND:
   - Animated gradient
   - Moving grid pattern
   - Parallax starfield
   - Depth layers


═══════════════════════════════════════════════════════════════════
KEY CODE OPTIMIZATIONS
═══════════════════════════════════════════════════════════════════

Canvas Initialization:
const canvas = canvasRef.current;
const ctx = canvas.getContext('2d', { alpha: false });
const dpr = window.devicePixelRatio || 1;

canvas.width = canvas.offsetWidth * dpr;
canvas.height = canvas.offsetHeight * dpr;
canvas.style.width = canvas.offsetWidth + 'px';
canvas.style.height = canvas.offsetHeight + 'px';

ctx.scale(dpr, dpr);
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';Smooth Player Movement:
// Add velocity and acceleration
const playerVelocity = { x: 0, y: 0 };
const acceleration = 0.5;
const friction = 0.85;
const maxSpeed = 8;

// In update loop
if (keys.current.w) playerVelocity.y -= acceleration;
if (keys.current.s) playerVelocity.y += acceleration;
if (keys.current.a) playerVelocity.x -= acceleration;
if (keys.current.d) playerVelocity.x += acceleration;

// Apply friction
playerVelocity.x *= friction;
playerVelocity.y *= friction;

// Clamp to max speed
const speed = Math.sqrt(playerVelocity.x ** 2 + playerVelocity.y ** 2);
if (speed > maxSpeed) {
  playerVelocity.x = (playerVelocity.x / speed) * maxSpeed;
  playerVelocity.y = (playerVelocity.y / speed) * maxSpeed;
}

// Update position
player.x += playerVelocity.x;
player.y += playerVelocity.y;Particle System:
interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  color: string;
  size: number;
}

function createParticles(x: number, y: number, count: number, color: string) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count;
    const speed = 2 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      maxLife: 30 + Math.random() * 30,
      color,
      size: 2 + Math.random() * 3,
    });
  }
}

function updateParticles() {
  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.life++;
    p.vx *= 0.98;
    p.vy *= 0.98;
  });
  particles = particles.filter(p => p.life < p.maxLife);
}

function renderParticles(ctx: CanvasRenderingContext2D) {
  particles.forEach(p => {
    const alpha = 1 - (p.life / p.maxLife);
    ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
}Premium Ring Rendering:
function renderRing(ctx: CanvasRenderingContext2D, ring: Ring) {
  // Outer glow
  const gradient = ctx.createRadialGradient(
    ring.x, ring.y, ring.radius * 0.8,
    ring.x, ring.y, ring.radius * 1.2
  );
  gradient.addColorStop(0, 'rgba(6, 182, 212, 0.3)');
  gradient.addColorStop(1, 'rgba(6, 182, 212, 0)');
  
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(ring.x, ring.y, ring.radius * 1.2, 0, Math.PI * 2);
  ctx.fill();
  
  // Main ring with gradient
  const ringGradient = ctx.createRadialGradient(
    ring.x, ring.y, ring.radius - 10,
    ring.x, ring.y, ring.radius
  );
  ringGradient.addColorStop(0, '#06b6d4');
  ringGradient.addColorStop(1, '#0891b2');
  
  ctx.strokeStyle = ringGradient;
  ctx.lineWidth = 8;
  ctx.shadowBlur = 15;
  ctx.shadowColor = '#06b6d4';
  ctx.beginPath();
  ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
  ctx.stroke();
  ctx.shadowBlur = 0;
  
  // Inner highlight
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(ring.x, ring.y, ring.radius - 5, 0, Math.PI * 2);
  ctx.stroke();
}Animated Background:
let bgOffset = 0;

function renderBackground(ctx: CanvasRenderingContext2D, width: number, height: number) {
  // Animated gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, height);
  gradient.addColorStop(0, '#0a0e27');
  gradient.addColorStop(1, '#1a1f3a');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
  
  // Moving grid
  ctx.strokeStyle = 'rgba(6, 182, 212, 0.1)';
  ctx.lineWidth = 1;
  
  const gridSize = 40;
  bgOffset = (bgOffset + 0.5) % gridSize;
  
  for (let x = -gridSize; x < width + gridSize; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x + bgOffset, 0);
    ctx.lineTo(x + bgOffset, height);
    ctx.stroke();
  }
  
  for (let y = -gridSize; y < height + gridSize; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y + bgOffset);
    ctx.lineTo(width, y + bgOffset);
    ctx.stroke();
  }
  
  // Stars
  ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
  for (let i = 0; i < 50; i++) {
    const x = (i * 37) % width;
    const y = (i * 71) % height;
    const size = (i % 3) + 1;
    ctx.fillRect(x, y, size, size);
  }
}Premium HUD:
function renderHUD(ctx: CanvasRenderingContext2D) {
  // Semi-transparent panel
  ctx.fillStyle = 'rgba(10, 14, 39, 0.8)';
  ctx.fillRect(10, 10, 200, 100);
  
  // Border
  ctx.strokeStyle = '#06b6d4';
  ctx.lineWidth = 2;
  ctx.strokeRect(10, 10, 200, 100);
  
  // Score with glow
  ctx.shadowBlur = 10;
  ctx.shadowColor = '#06b6d4';
  ctx.fillStyle = '#06b6d4';
  ctx.font = 'bold 24px monospace';
  ctx.fillText(`Score: ${score}`, 25, 45);
  
  // Level
  ctx.fillStyle = '#ffffff';
  ctx.font = '18px monospace';
  ctx.fillText(`Level: ${level}`, 25, 75);
  
  // Lives with icons
  ctx.fillText('Lives:', 25, 100);
  for (let i = 0; i < lives; i++) {
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.arc(100 + i * 25, 95, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.shadowBlur = 0;
}═══════════════════════════════════════════════════════════════════
STYLE REQUIREMENTS
═══════════════════════════════════════════════════════════════════

Color Palette:
- Background: #0a0e27 to #1a1f3a (gradient)
- Primary: #06b6d4 (cyan)
- Secondary: #0891b2 (dark cyan)
- Accent: #22d3ee (bright cyan)
- Danger: #ef4444 (red)
- Success: #10b981 (green)
- Text: #ffffff (white)

Fonts:
- Use system monospace for game text
- Bold weights for scores
- Regular for labels

Effects:
- Glow: shadowBlur + shadowColor
- Particles: Radial gradients
- Smooth transitions: Linear interpolation
- Screen shake: Canvas offset


═══════════════════════════════════════════════════════════════════
PERFORMANCE CHECKLIST
═══════════════════════════════════════════════════════════════════

✅ Use requestAnimationFrame (not setInterval)
✅ Clear canvas efficiently (fillRect instead of clearRect)
✅ Limit particle count (max 100)
✅ Use object pooling for particles
✅ Optimize collision detection (spatial partitioning)
✅ Batch draw calls where possible
✅ Clean up on component unmount
✅ Use integer coordinates when possible
✅ Minimize Math operations in loops
✅ Cache commonly used values


═══════════════════════════════════════════════════════════════════
DELIVERABLE
═══════════════════════════════════════════════════════════════════

After implementation, the game should:

✅ Run at solid 60 FPS
✅ Look crisp on all screen sizes
✅ Have smooth player movement
✅ Show particle effects on interactions
✅ Have animated, professional HUD
✅ Include gradient rings with glow
✅ Feature animated background
✅ Display smooth transitions
✅ Work perfectly on mobile
✅ Load instantly with no lag

Test by playing for 2-3 minutes and verifying:
- No frame drops
- Smooth movement
- Crisp graphics
- Premium feel
- No memory leaks