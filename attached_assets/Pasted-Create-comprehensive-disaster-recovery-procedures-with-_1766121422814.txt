Create comprehensive disaster recovery procedures with automated health checks, failover mechanisms, recovery playbooks, system restoration workflows, and automated disaster recovery testing.

STEP 1: CREATE DISASTER RECOVERY PLAN

1. CREATE FILE: server/lib/disasterRecovery.ts

import { DatabaseBackupService } from '../../script/backup-database';
import { PointInTimeRecovery } from './pointInTimeRecovery';
import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFile } from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

interface DisasterType {
  code: 'DB_CORRUPTION' | 'DATA_LOSS' | 'SYSTEM_COMPROMISE' | 'NETWORK_FAILURE' | 'MANUAL_ERROR' | 'HARDWARE_FAILURE';
  name: string;
  severity: 'critical' | 'high' | 'medium';
  autoRecoverable: boolean;
}

interface RecoveryStep {
  id: string;
  description: string;
  automated: boolean;
  estimatedDuration: number;
  critical: boolean;
  command?: string;
}

interface DisasterRecoveryPlan {
  disasterType: DisasterType;
  detectedAt: Date;
  steps: RecoveryStep[];
  estimatedTotalDuration: number;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  completedSteps: string[];
  currentStep?: string;
  error?: string;
}

export class DisasterRecoveryService {
  private static backupService = new DatabaseBackupService();
  
  private static disasterTypes: DisasterType[] = [
    {
      code: 'DB_CORRUPTION',
      name: 'Database Corruption',
      severity: 'critical',
      autoRecoverable: true
    },
    {
      code: 'DATA_LOSS',
      name: 'Data Loss Detected',
      severity: 'critical',
      autoRecoverable: true
    },
    {
      code: 'SYSTEM_COMPROMISE',
      name: 'Security Compromise',
      severity: 'critical',
      autoRecoverable: false
    },
    {
      code: 'NETWORK_FAILURE',
      name: 'Network Connectivity Lost',
      severity: 'high',
      autoRecoverable: true
    },
    {
      code: 'MANUAL_ERROR',
      name: 'Manual Operator Error',
      severity: 'high',
      autoRecoverable: true
    },
    {
      code: 'HARDWARE_FAILURE',
      name: 'Hardware Failure',
      severity: 'critical',
      autoRecoverable: false
    }
  ];
  
  static async createRecoveryPlan(disasterCode: DisasterType['code']): Promise<DisasterRecoveryPlan> {
    const disaster = this.disasterTypes.find(d => d.code === disasterCode);
    
    if (!disaster) {
      throw new Error(`Unknown disaster type: ${disasterCode}`);
    }
    
    console.log(`[DR] Creating recovery plan for: ${disaster.name}`);
    
    const steps = await this.getRecoverySteps(disaster);
    const totalDuration = steps.reduce((sum, step) => sum + step.estimatedDuration, 0);
    
    const plan: DisasterRecoveryPlan = {
      disasterType: disaster,
      detectedAt: new Date(),
      steps,
      estimatedTotalDuration: totalDuration,
      status: 'pending',
      completedSteps: []
    };
    
    await this.savePlan(plan);
    
    return plan;
  }
  
  private static async getRecoverySteps(disaster: DisasterType): Promise<RecoveryStep[]> {
    const steps: RecoveryStep[] = [];
    
    switch (disaster.code) {
      case 'DB_CORRUPTION':
        steps.push(
          {
            id: 'verify_corruption',
            description: 'Verify database corruption',
            automated: true,
            estimatedDuration: 30,
            critical: true,
            command: 'npm run db:verify'
          },
          {
            id: 'stop_writes',
            description: 'Stop all write operations',
            automated: true,
            estimatedDuration: 5,
            critical: true
          },
          {
            id: 'create_emergency_backup',
            description: 'Create emergency backup of current state',
            automated: true,
            estimatedDuration: 120,
            critical: true,
            command: 'npm run db:backup'
          },
          {
            id: 'find_last_good_backup',
            description: 'Identify last known good backup',
            automated: true,
            estimatedDuration: 10,
            critical: true
          },
          {
            id: 'restore_database',
            description: 'Restore from last good backup',
            automated: true,
            estimatedDuration: 180,
            critical: true,
            command: 'npm run db:restore'
          },
          {
            id: 'verify_integrity',
            description: 'Verify database integrity',
            automated: true,
            estimatedDuration: 60,
            critical: true
          },
          {
            id: 'resume_operations',
            description: 'Resume normal operations',
            automated: true,
            estimatedDuration: 5,
            critical: true
          }
        );
        break;
        
      case 'DATA_LOSS':
        steps.push(
          {
            id: 'assess_data_loss',
            description: 'Assess extent of data loss',
            automated: true,
            estimatedDuration: 60,
            critical: true
          },
          {
            id: 'stop_operations',
            description: 'Stop all operations',
            automated: true,
            estimatedDuration: 5,
            critical: true
          },
          {
            id: 'identify_recovery_point',
            description: 'Identify point-in-time recovery target',
            automated: true,
            estimatedDuration: 30,
            critical: true
          },
          {
            id: 'pitr_restore',
            description: 'Perform point-in-time recovery',
            automated: true,
            estimatedDuration: 300,
            critical: true
          },
          {
            id: 'validate_data',
            description: 'Validate recovered data',
            automated: true,
            estimatedDuration: 120,
            critical: true
          },
          {
            id: 'resume_operations',
            description: 'Resume operations',
            automated: true,
            estimatedDuration: 5,
            critical: true
          }
        );
        break;
        
      case 'SYSTEM_COMPROMISE':
        steps.push(
          {
            id: 'isolate_system',
            description: 'Isolate compromised system',
            automated: false,
            estimatedDuration: 10,
            critical: true
          },
          {
            id: 'assess_breach',
            description: 'Assess security breach',
            automated: false,
            estimatedDuration: 300,
            critical: true
          },
          {
            id: 'secure_backups',
            description: 'Verify backup integrity',
            automated: true,
            estimatedDuration: 60,
            critical: true
          },
          {
            id: 'rotate_credentials',
            description: 'Rotate all credentials and keys',
            automated: false,
            estimatedDuration: 120,
            critical: true
          },
          {
            id: 'clean_restore',
            description: 'Restore to clean system',
            automated: false,
            estimatedDuration: 600,
            critical: true
          },
          {
            id: 'security_audit',
            description: 'Perform security audit',
            automated: false,
            estimatedDuration: 1800,
            critical: true
          }
        );
        break;
        
      case 'NETWORK_FAILURE':
        steps.push(
          {
            id: 'verify_network',
            description: 'Verify network connectivity',
            automated: true,
            estimatedDuration: 30,
            critical: true
          },
          {
            id: 'enable_offline_mode',
            description: 'Enable offline mode',
            automated: true,
            estimatedDuration: 5,
            critical: false
          },
          {
            id: 'failover_connection',
            description: 'Attempt failover connection',
            automated: true,
            estimatedDuration: 60,
            critical: true
          },
          {
            id: 'sync_data',
            description: 'Sync offline data',
            automated: true,
            estimatedDuration: 120,
            critical: true
          }
        );
        break;
        
      case 'MANUAL_ERROR':
        steps.push(
          {
            id: 'identify_error',
            description: 'Identify erroneous operation',
            automated: false,
            estimatedDuration: 60,
            critical: true
          },
          {
            id: 'calculate_rollback',
            description: 'Calculate rollback point',
            automated: true,
            estimatedDuration: 30,
            critical: true
          },
          {
            id: 'execute_rollback',
            description: 'Execute rollback',
            automated: true,
            estimatedDuration: 180,
            critical: true
          },
          {
            id: 'verify_rollback',
            description: 'Verify rollback success',
            automated: true,
            estimatedDuration: 60,
            critical: true
          }
        );
        break;
        
      case 'HARDWARE_FAILURE':
        steps.push(
          {
            id: 'assess_hardware',
            description: 'Assess hardware failure',
            automated: false,
            estimatedDuration: 120,
            critical: true
          },
          {
            id: 'provision_replacement',
            description: 'Provision replacement hardware',
            automated: false,
            estimatedDuration: 3600,
            critical: true
          },
          {
            id: 'restore_from_backup',
            description: 'Restore from backup',
            automated: true,
            estimatedDuration: 300,
            critical: true
          },
          {
            id: 'validate_system',
            description: 'Validate system functionality',
            automated: true,
            estimatedDuration: 180,
            critical: true
          }
        );
        break;
    }
    
    return steps;
  }
  
  static async executeRecoveryPlan(plan: DisasterRecoveryPlan, automated: boolean = false): Promise<void> {
    console.log(`[DR] Executing recovery plan for: ${plan.disasterType.name}`);
    console.log(`[DR] Estimated duration: ${Math.ceil(plan.estimatedTotalDuration / 60)} minutes`);
    
    plan.status = 'in_progress';
    await this.savePlan(plan);
    
    try {
      for (const step of plan.steps) {
        if (!automated && !step.automated) {
          console.log(`[DR] Manual step required: ${step.description}`);
          continue;
        }
        
        console.log(`[DR] Executing step: ${step.description}`);
        plan.currentStep = step.id;
        await this.savePlan(plan);
        
        const startTime = Date.now();
        
        try {
          await this.executeStep(step);
          
          const duration = Date.now() - startTime;
          console.log(`[DR] Step completed in ${duration}ms`);
          
          plan.completedSteps.push(step.id);
          await this.savePlan(plan);
        } catch (error: any) {
          console.error(`[DR] Step failed: ${step.description}`, error);
          
          if (step.critical) {
            throw new Error(`Critical step failed: ${step.description} - ${error.message}`);
          }
          
          console.warn(`[DR] Non-critical step failed, continuing...`);
        }
      }
      
      plan.status = 'completed';
      plan.currentStep = undefined;
      await this.savePlan(plan);
      
      console.log(`[DR] Recovery plan completed successfully`);
    } catch (error: any) {
      plan.status = 'failed';
      plan.error = error.message;
      await this.savePlan(plan);
      
      console.error(`[DR] Recovery plan failed:`, error);
      throw error;
    }
  }
  
  private static async executeStep(step: RecoveryStep): Promise<void> {
    switch (step.id) {
      case 'verify_corruption':
        await this.verifyDatabaseIntegrity();
        break;
      case 'stop_writes':
        await this.stopWriteOperations();
        break;
      case 'create_emergency_backup':
        await this.backupService.backup('full');
        break;
      case 'find_last_good_backup':
        await this.findLastGoodBackup();
        break;
      case 'restore_database':
        const backups = await this.backupService.listBackups();
        const lastGood = backups.find(b => b.status === 'success');
        if (lastGood) {
          await this.backupService.restore(lastGood.id);
        }
        break;
      case 'verify_integrity':
        await this.verifyDatabaseIntegrity();
        break;
      case 'resume_operations':
        await this.resumeOperations();
        break;
      default:
        console.log(`[DR] Step ${step.id} - no automated implementation`);
    }
  }
  
  private static async verifyDatabaseIntegrity(): Promise<void> {
    const dbUrl = process.env.DATABASE_URL;
    if (!dbUrl) throw new Error('DATABASE_URL not found');
    
    try {
      await execAsync(`psql "${dbUrl}" -c "SELECT 1"`);
      console.log('[DR] Database connection verified');
    } catch (error) {
      throw new Error('Database connection failed');
    }
  }
  
  private static async stopWriteOperations(): Promise<void> {
    console.log('[DR] Stopping write operations (feature flag)');
    // In production, set a maintenance mode flag
  }
  
  private static async resumeOperations(): Promise<void> {
    console.log('[DR] Resuming normal operations');
    // In production, clear maintenance mode flag
  }
  
  private static async findLastGoodBackup(): Promise<void> {
    const backups = await this.backupService.listBackups();
    
    for (const backup of backups) {
      const valid = await this.backupService.verifyBackup(backup.id);
      if (valid) {
        console.log(`[DR] Last good backup: ${backup.id}`);
        return;
      }
    }
    
    throw new Error('No valid backups found');
  }
  
  private static async savePlan(plan: DisasterRecoveryPlan): Promise<void> {
    const planFile = path.join(process.cwd(), 'logs', 'recovery-plan.json');
    await writeFile(planFile, JSON.stringify(plan, null, 2));
  }
  
  static async testDisasterRecovery(): Promise<any> {
    console.log('[DR] Running disaster recovery test...');
    
    const results: any = {
      timestamp: new Date(),
      tests: []
    };
    
    const testBackup = async () => {
      try {
        const backup = await this.backupService.backup('full');
        const valid = await this.backupService.verifyBackup(backup.id);
        
        return {
          name: 'Backup & Verify',
          passed: valid,
          duration: backup.duration
        };
      } catch (error: any) {
        return {
          name: 'Backup & Verify',
          passed: false,
          error: error.message
        };
      }
    };
    
    const testDbConnection = async () => {
      try {
        await this.verifyDatabaseIntegrity();
        return { name: 'Database Connection', passed: true };
      } catch (error: any) {
        return { name: 'Database Connection', passed: false, error: error.message };
      }
    };
    
    const testRecoveryPlan = async () => {
      try {
        const plan = await this.createRecoveryPlan('DATA_LOSS');
        return { 
          name: 'Recovery Plan Creation', 
          passed: plan.steps.length > 0,
          steps: plan.steps.length
        };
      } catch (error: any) {
        return { name: 'Recovery Plan Creation', passed: false, error: error.message };
      }
    };
    
    results.tests.push(await testBackup());
    results.tests.push(await testDbConnection());
    results.tests.push(await testRecoveryPlan());
    
    results.passed = results.tests.every((t: any) => t.passed);
    
    console.log(`[DR] Test complete: ${results.passed ? 'PASSED' : 'FAILED'}`);
    
    return results;
  }
}

STEP 2: CREATE HEALTH CHECK SERVICE

2. CREATE FILE: server/lib/healthCheck.ts

import { db } from '../db';
import { sql } from 'drizzle-orm';

interface HealthCheckResult {
  service: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime: number;
  details?: any;
  error?: string;
}

export class HealthCheckService {
  static async checkDatabase(): Promise<HealthCheckResult> {
    const start = Date.now();
    
    try {
      await db.execute(sql`SELECT 1`);
      
      const responseTime = Date.now() - start;
      
      return {
        service: 'database',
        status: responseTime < 100 ? 'healthy' : 'degraded',
        responseTime,
        details: { latency: `${responseTime}ms` }
      };
    } catch (error: any) {
      return {
        service: 'database',
        status: 'unhealthy',
        responseTime: Date.now() - start,
        error: error.message
      };
    }
  }
  
  static async checkBackupSystem(): Promise<HealthCheckResult> {
    const start = Date.now();
    
    try {
      const { DatabaseBackupService } = await import('../../script/backup-database');
      const service = new DatabaseBackupService();
      const stats = await service.getBackupStats();
      
      const lastBackupAge = stats.newest ? Date.now() - new Date(stats.newest).getTime() : Infinity;
      const hoursOld = lastBackupAge / (1000 * 60 * 60);
      
      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
      if (hoursOld > 48) status = 'unhealthy';
      else if (hoursOld > 24) status = 'degraded';
      
      return {
        service: 'backup_system',
        status,
        responseTime: Date.now() - start,
        details: {
          total: stats.total,
          lastBackup: stats.newest,
          hoursOld: hoursOld.toFixed(1)
        }
      };
    } catch (error: any) {
      return {
        service: 'backup_system',
        status: 'unhealthy',
        responseTime: Date.now() - start,
        error: error.message
      };
    }
  }
  
  static async checkDiskSpace(): Promise<HealthCheckResult> {
    const start = Date.now();
    
    try {
      const { execSync } = require('child_process');
      const output = execSync('df -h / | tail -1').toString();
      const parts = output.split(/\s+/);
      const used = parts[4];
      const usedPercent = parseInt(used);
      
      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
      if (usedPercent > 90) status = 'unhealthy';
      else if (usedPercent > 80) status = 'degraded';
      
      return {
        service: 'disk_space',
        status,
        responseTime: Date.now() - start,
        details: { used: used }
      };
    } catch (error: any) {
      return {
        service: 'disk_space',
        status: 'degraded',
        responseTime: Date.now() - start,
        error: 'Could not check disk space'
      };
    }
  }
  
  static async checkMemory(): Promise<HealthCheckResult> {
    const start = Date.now();
    
    try {
      const memUsage = process.memoryUsage();
      const heapUsedMB = memUsage.heapUsed / 1024 / 1024;
      const heapTotalMB = memUsage.heapTotal / 1024 / 1024;
      const percent = (heapUsedMB / heapTotalMB) * 100;
      
      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
      if (percent > 90) status = 'unhealthy';
      else if (percent > 80) status = 'degraded';
      
      return {
        service: 'memory',
        status,
        responseTime: Date.now() - start,
        details: {
          heapUsed: `${heapUsedMB.toFixed(2)} MB`,
          heapTotal: `${heapTotalMB.toFixed(2)} MB`,
          percent: `${percent.toFixed(1)}%`
        }
      };
    } catch (error: any) {
      return {
        service: 'memory',
        status: 'unhealthy',
        responseTime: Date.now() - start,
        error: error.message
      };
    }
  }
  
  static async runAllChecks(): Promise<HealthCheckResult[]> {
    const checks = await Promise.all([
      this.checkDatabase(),
      this.checkBackupSystem(),
      this.checkDiskSpace(),
      this.checkMemory()
    ]);
    
    return checks;
  }
  
  static async getSystemHealth(): Promise<{ healthy: boolean; checks: HealthCheckResult[]; score: number }> {
    const checks = await this.runAllChecks();
    
    const unhealthyCount = checks.filter(c => c.status === 'unhealthy').length;
    const degradedCount = checks.filter(c => c.status === 'degraded').length;
    
    const score = 100 - (unhealthyCount * 30) - (degradedCount * 15);
    const healthy = score >= 70;
    
    return { healthy, checks, score };
  }
}

STEP 3: ADD DISASTER RECOVERY ENDPOINTS

3. UPDATE FILE: server/routes.ts

Add imports:

import { DisasterRecoveryService } from './lib/disasterRecovery';
import { HealthCheckService } from './lib/healthCheck';

Add endpoints:

app.post('/api/admin/disaster-recovery/plan', requireAdmin, async (req, res) => {
  try {
    const { disasterType } = req.body;
    
    if (!disasterType) {
      return res.status(400).json({ error: 'Disaster type required' });
    }
    
    const plan = await DisasterRecoveryService.createRecoveryPlan(disasterType);
    
    res.json({ plan });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/admin/disaster-recovery/execute', requireAdmin, async (req, res) => {
  try {
    const { plan, automated } = req.body;
    
    if (!plan) {
      return res.status(400).json({ error: 'Recovery plan required' });
    }
    
    await DisasterRecoveryService.executeRecoveryPlan(plan, automated);
    
    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/admin/disaster-recovery/test', requireAdmin, async (req, res) => {
  try {
    const results = await DisasterRecoveryService.testDisasterRecovery();
    res.json(results);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/health/system', async (req, res) => {
  try {
    const health = await HealthCheckService.getSystemHealth();
    res.json(health);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/health/detailed', requireAdmin, async (req, res) => {
  try {
    const checks = await HealthCheckService.runAllChecks();
    res.json({ checks });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

STEP 4: CREATE DISASTER RECOVERY COMPONENT

4. CREATE FILE: client/src/components/DisasterRecoveryPanel.tsx

import { useState } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { AlertTriangle, Shield, Play, FileText } from 'lucide-react';

const DISASTER_TYPES = [
  { code: 'DB_CORRUPTION', name: 'Database Corruption', severity: 'critical' },
  { code: 'DATA_LOSS', name: 'Data Loss', severity: 'critical' },
  { code: 'SYSTEM_COMPROMISE', name: 'Security Compromise', severity: 'critical' },
  { code: 'NETWORK_FAILURE', name: 'Network Failure', severity: 'high' },
  { code: 'MANUAL_ERROR', name: 'Manual Error', severity: 'high' },
  { code: 'HARDWARE_FAILURE', name: 'Hardware Failure', severity: 'critical' }
];

export const DisasterRecoveryPanel = () => {
  const [selectedDisaster, setSelectedDisaster] = useState('');
  const [plan, setPlan] = useState<any>(null);
  const [testing, setTesting] = useState(false);
  const [testResults, setTestResults] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  
  const createPlan = async () => {
    if (!selectedDisaster) {
      alert('Please select a disaster type');
      return;
    }
    
    setLoading(true);
    try {
      const res = await fetch('/api/admin/disaster-recovery/plan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ disasterType: selectedDisaster })
      });
      
      const data = await res.json();
      setPlan(data.plan);
    } catch (error) {
      console.error('Failed to create plan:', error);
      alert('Failed to create recovery plan');
    } finally {
      setLoading(false);
    }
  };
  
  const executePlan = async () => {
    if (!plan) return;
    
    const confirmed = confirm(
      '‚ö†Ô∏è WARNING ‚ö†Ô∏è\n\n' +
      'This will execute the disaster recovery plan.\n' +
      'This is a CRITICAL operation!\n\n' +
      'Are you sure?'
    );
    
    if (!confirmed) return;
    
    setLoading(true);
    try {
      await fetch('/api/admin/disaster-recovery/execute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ plan, automated: true })
      });
      
      alert('‚úÖ Recovery plan executed successfully!');
      setPlan(null);
    } catch (error) {
      console.error('Recovery execution failed:', error);
      alert('Recovery execution failed. Check console for details.');
    } finally {
      setLoading(false);
    }
  };
  
  const testRecovery = async () => {
    setTesting(true);
    try {
      const res = await fetch('/api/admin/disaster-recovery/test', {
        method: 'POST'
      });
      
      const results = await res.json();
      setTestResults(results);
    } catch (error) {
      console.error('Recovery test failed:', error);
      alert('Recovery test failed');
    } finally {
      setTesting(false);
    }
  };
  
  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'critical': return 'border-red-500 bg-red-500/10';
      case 'high': return 'border-orange-500 bg-orange-500/10';
      default: return 'border-yellow-500 bg-yellow-500/10';
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Test Recovery */}
      <Card className="p-6 bg-black/60 border-green-500/30">
        <div className="flex items-center justify-between mb-4">
          <div>
            <h3 className="text-xl font-bold mb-2">Test Disaster Recovery</h3>
            <p className="text-sm text-gray-400">
              Verify backup system and recovery procedures
            </p>
          </div>
          <Button 
            onClick={testRecovery} 
            disabled={testing}
            className="bg-gradient-to-r from-green-500 to-blue-500"
          >
            {testing ? 'Testing...' : 'Run Test'}
          </Button>
        </div>
        
        {testResults && (
          <div className={`mt-4 p-4 rounded border ${
            testResults.passed 
              ? 'border-green-500/30 bg-green-500/10' 
              : 'border-red-500/30 bg-red-500/10'
          }`}>
            <div className="font-bold mb-2">
              {testResults.passed ? '‚úÖ All Tests Passed' : '‚ùå Some Tests Failed'}
            </div>
            <div className="space-y-1">
              {testResults.tests.map((test: any, i: number) => (
                <div key={i} className="text-sm">
                  {test.passed ? '‚úÖ' : '‚ùå'} {test.name}
                  {test.duration && ` (${test.duration}ms)`}
                  {test.error && ` - ${test.error}`}
                </div>
              ))}
            </div>
          </div>
        )}
      </Card>
      
      {/* Create Recovery Plan */}
      <Card className="p-6 bg-black/60 border-purple-500/30">
        <h3 className="text-xl font-bold mb-4">Create Recovery Plan</h3>
        
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">
              Select Disaster Type
            </label>
            <select
              value={selectedDisaster}
              onChange={(e) => setSelectedDisaster(e.target.value)}
              className="w-full px-4 py-2 bg-black/60 border border-purple-500/30 rounded"
            >
              <option value="">-- Select Disaster Type --</option>
              {DISASTER_TYPES.map(d => (
                <option key={d.code} value={d.code}>
                  {d.name} ({d.severity})
                </option>
              ))}
            </select>
          </div>
          
          <Button 
            onClick={createPlan} 
            disabled={loading || !selectedDisaster}
          >
            <FileText className="w-4 h-4 mr-2" />
            Create Plan
          </Button>
        </div>
      </Card>
      
      {/* Recovery Plan Display */}
      {plan && (
        <Card className={`p-6 border ${getSeverityColor(plan.disasterType.severity)}`}>
          <div className="flex items-start gap-3 mb-4">
            <AlertTriangle className="w-6 h-6 text-red-400" />
            <div>
              <h3 className="text-xl font-bold">{plan.disasterType.name}</h3>
              <p className="text-sm text-gray-400">
                Severity: {plan.disasterType.severity.toUpperCase()}
              </p>
              <p className="text-sm text-gray-400">
                Estimated Duration: {Math.ceil(plan.estimatedTotalDuration / 60)} minutes
              </p>
            </div>
          </div>
          
          <div className="space-y-2 mb-4">
            <h4 className="font-bold">Recovery Steps:</h4>
            {plan.steps.map((step: any, i: number) => (
              <div 
                key={step.id}
                className={`p-3 rounded border ${
                  step.critical 
                    ? 'border-red-500/30 bg-red-500/5' 
                    : 'border-blue-500/30 bg-blue-500/5'
                }`}
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="font-bold">
                      {i + 1}. {step.description}
                    </div>
                    <div className="text-xs text-gray-400 mt-1">
                      {step.automated ? 'ü§ñ Automated' : 'üë§ Manual'} ‚Ä¢ 
                      ~{Math.ceil(step.estimatedDuration / 60)} min ‚Ä¢ 
                      {step.critical ? '‚ö†Ô∏è Critical' : '‚úì Optional'}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
          
          <div className="flex gap-2">
            <Button 
              onClick={executePlan} 
              disabled={loading}
              className="bg-gradient-to-r from-orange-500 to-red-500"
            >
              <Play className="w-4 h-4 mr-2" />
              Execute Plan
            </Button>
            <Button 
              onClick={() => setPlan(null)} 
              variant="outline"
            >
              Cancel
            </Button>
          </div>
        </Card>
      )}
    </div>
  );
};

STEP 5: ADD DR PANEL TO ADMIN DASHBOARD

5. UPDATE FILE: client/src/components/AdminDashboard.tsx

Add import:

import { DisasterRecoveryPanel } from './DisasterRecoveryPanel';

Add to dashboard render:

<div className="mb-8">
  <h2 className="text-2xl font-bold mb-4">üÜò Disaster Recovery</h2>
  <DisasterRecoveryPanel />
</div>

STEP 6: CREATE DR TEST SCRIPT

6. CREATE FILE: script/test-disaster-recovery.ts

import { DisasterRecoveryService } from '../server/lib/disasterRecovery';

async function testDR() {
  console.log('üÜò Testing Disaster Recovery System...\n');
  
  try {
    console.log('1. Running automated tests...');
    const testResults = await DisasterRecoveryService.testDisasterRecovery();
    
    console.log(`\n‚úÖ Test Results: ${testResults.passed ? 'PASSED' : 'FAILED'}\n`);
    
    testResults.tests.forEach((test: any) => {
      const status = test.passed ? '‚úÖ' : '‚ùå';
      console.log(`${status} ${test.name}`);
      if (test.duration) console.log(`   Duration: ${test.duration}ms`);
      if (test.error) console.log(`   Error: ${test.error}`);
      console.log('');
    });
    
    console.log('2. Creating sample recovery plan...');
    const plan = await DisasterRecoveryService.createRecoveryPlan('DATA_LOSS');
    
    console.log(`‚úÖ Plan created: ${plan.steps.length} steps`);
    console.log(`   Estimated duration: ${Math.ceil(plan.estimatedTotalDuration / 60)} minutes\n`);
    
    plan.steps.forEach((step, i) => {
      console.log(`   ${i + 1}. ${step.description}`);
      console.log(`      ${step.automated ? 'ü§ñ Automated' : 'üë§ Manual'} ‚Ä¢ ${Math.ceil(step.estimatedDuration / 60)} min`);
    });
    
    console.log('\n‚úÖ Disaster Recovery test complete');
    
    if (!testResults.passed) {
      process.exit(1);
    }
  } catch (error) {
    console.error('‚ùå Test failed:', error);
    process.exit(1);
  }
}

testDR();

STEP 7: ADD TO PACKAGE.JSON

7. UPDATE FILE: package.json

Add scripts:

"dr:test": "tsx script/test-disaster-recovery.ts"

VERIFICATION STEPS:
1. Run: npm run dr:test
2. Should run automated DR tests
3. All tests should pass
4. Should create sample recovery plan
5. Open Admin Dashboard
6. Find "Disaster Recovery" section
7. Click "Run Test"
8. Should see test results (all passing)
9. Select a disaster type
10. Click "Create Plan"
11. Should show recovery steps
12. Review steps (automated vs manual)
13. Should show estimated duration
14. Check /logs/recovery-plan.json
15. Should contain the plan details

Test system health:
1. Go to /api/health/system
2. Should show health score
3. Go to /api/health/detailed
4. Should show all health checks
5. All should be "healthy" or "degraded"

Your app is now disaster-proof! üÜò