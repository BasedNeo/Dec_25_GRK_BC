Implement comprehensive transaction logging and audit trails for all financial operations, ensuring complete transparency and forensic capability for debugging and compliance.

STEP 1: ENHANCE TRANSACTION RECEIPTS SCHEMA

1. UPDATE FILE: shared/schema.ts

Add enhanced fields to transactionReceipts table (if not already complete):

export const transactionReceipts = pgTable('transaction_receipts', {
  id: serial('id').primaryKey(),
  walletAddress: text('wallet_address').notNull(),
  transactionType: text('transaction_type').notNull(),
  transactionHash: text('transaction_hash').notNull().unique(),
  status: text('status').notNull().default('pending'),
  amount: text('amount'),
  tokenId: integer('token_id'),
  fromAddress: text('from_address'),
  toAddress: text('to_address'),
  blockNumber: integer('block_number'),
  gasUsed: text('gas_used'),
  gasPrice: text('gas_price'),
  gasCostInBase: text('gas_cost_in_base'),
  platformFee: text('platform_fee'),
  royaltyFee: text('royalty_fee'),
  netAmount: text('net_amount'),
  metadata: text('metadata'),
  errorMessage: text('error_message'),
  createdAt: timestamp('created_at').defaultNow(),
  confirmedAt: timestamp('confirmed_at'),
  failedAt: timestamp('failed_at'),
});

export const auditLogs = pgTable('audit_logs', {
  id: serial('id').primaryKey(),
  timestamp: timestamp('timestamp').defaultNow(),
  userId: text('user_id'),
  action: text('action').notNull(),
  resource: text('resource').notNull(),
  resourceId: text('resource_id'),
  previousValue: text('previous_value'),
  newValue: text('new_value'),
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),
  success: integer('success').notNull().default(1),
  errorMessage: text('error_message'),
});

export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertAuditLog = typeof auditLogs.$inferInsert;

STEP 2: PUSH DATABASE CHANGES

2. RUN IN TERMINAL:

npm run db:push

STEP 3: CREATE AUDIT LOGGER SERVICE

3. CREATE FILE: server/lib/auditLogger.ts

import { Request } from 'express';

interface AuditLogData {
  userId?: string;
  action: string;
  resource: string;
  resourceId?: string;
  previousValue?: any;
  newValue?: any;
  success?: boolean;
  errorMessage?: string;
}

export class AuditLogger {
  private storage: any;
  
  constructor(storage: any) {
    this.storage = storage;
  }
  
  async log(data: AuditLogData, req?: Request): Promise<void> {
    try {
      const ipAddress = req ? this.getClientIp(req) : undefined;
      const userAgent = req?.get('user-agent');
      
      await this.storage.createAuditLog({
        userId: data.userId,
        action: data.action,
        resource: data.resource,
        resourceId: data.resourceId,
        previousValue: data.previousValue ? JSON.stringify(data.previousValue) : undefined,
        newValue: data.newValue ? JSON.stringify(data.newValue) : undefined,
        ipAddress,
        userAgent,
        success: data.success !== false ? 1 : 0,
        errorMessage: data.errorMessage,
      });
      
      console.log(`[AUDIT] ${data.action} on ${data.resource} by ${data.userId || 'system'}`);
    } catch (error) {
      console.error('[AUDIT] Failed to log:', error);
    }
  }
  
  private getClientIp(req: Request): string {
    const forwarded = req.get('x-forwarded-for');
    if (forwarded) {
      return forwarded.split(',')[0].trim();
    }
    return req.ip || 'unknown';
  }
  
  async logTransaction(txData: {
    walletAddress: string;
    action: string;
    transactionHash: string;
    amount?: string;
    tokenId?: number;
    success: boolean;
    errorMessage?: string;
  }, req?: Request): Promise<void> {
    await this.log({
      userId: txData.walletAddress,
      action: `transaction_${txData.action}`,
      resource: 'blockchain_transaction',
      resourceId: txData.transactionHash,
      newValue: {
        amount: txData.amount,
        tokenId: txData.tokenId,
      },
      success: txData.success,
      errorMessage: txData.errorMessage,
    }, req);
  }
  
  async logAdminAction(adminAddress: string, action: string, resource: string, details: any, req?: Request): Promise<void> {
    await this.log({
      userId: adminAddress,
      action: `admin_${action}`,
      resource,
      resourceId: details.id || details.tokenId,
      previousValue: details.previousValue,
      newValue: details.newValue,
      success: true,
    }, req);
  }
  
  async logFeatureFlagChange(adminAddress: string, flagName: string, oldValue: boolean, newValue: boolean, req?: Request): Promise<void> {
    await this.log({
      userId: adminAddress,
      action: 'feature_flag_update',
      resource: 'feature_flags',
      resourceId: flagName,
      previousValue: { enabled: oldValue },
      newValue: { enabled: newValue },
      success: true,
    }, req);
  }
  
  async logBanAction(adminAddress: string, targetAddress: string, banned: boolean, reason?: string, req?: Request): Promise<void> {
    await this.log({
      userId: adminAddress,
      action: banned ? 'user_banned' : 'user_unbanned',
      resource: 'user_bans',
      resourceId: targetAddress,
      newValue: { banned, reason },
      success: true,
    }, req);
  }
}

STEP 4: ADD DATABASE METHODS

4. UPDATE FILE: server/storage.ts

Add import:

import { auditLogs, type AuditLog, type InsertAuditLog } from "@shared/schema";

Add methods:

async createAuditLog(log: InsertAuditLog): Promise<AuditLog> {
  const [created] = await db.insert(auditLogs).values(log).returning();
  return created;
}

async getAuditLogs(filters: {
  userId?: string;
  action?: string;
  resource?: string;
  startDate?: Date;
  endDate?: Date;
  limit?: number;
}): Promise<AuditLog[]> {
  let query = db.select().from(auditLogs);
  
  if (filters.userId) {
    query = query.where(eq(auditLogs.userId, filters.userId)) as any;
  }
  if (filters.action) {
    query = query.where(eq(auditLogs.action, filters.action)) as any;
  }
  if (filters.resource) {
    query = query.where(eq(auditLogs.resource, filters.resource)) as any;
  }
  if (filters.startDate) {
    query = query.where(gte(auditLogs.timestamp, filters.startDate)) as any;
  }
  if (filters.endDate) {
    query = query.where(lte(auditLogs.timestamp, filters.endDate)) as any;
  }
  
  query = query.orderBy(desc(auditLogs.timestamp)) as any;
  
  if (filters.limit) {
    query = query.limit(filters.limit) as any;
  }
  
  return query;
}

async getAuditLogsByUser(userId: string, limit: number = 100): Promise<AuditLog[]> {
  return db.select()
    .from(auditLogs)
    .where(eq(auditLogs.userId, userId))
    .orderBy(desc(auditLogs.timestamp))
    .limit(limit);
}

async getAuditLogsByResource(resource: string, resourceId?: string): Promise<AuditLog[]> {
  let query = db.select().from(auditLogs).where(eq(auditLogs.resource, resource));
  
  if (resourceId) {
    query = query.where(eq(auditLogs.resourceId, resourceId)) as any;
  }
  
  return query.orderBy(desc(auditLogs.timestamp));
}

async getFailedTransactions(limit: number = 50): Promise<AuditLog[]> {
  return db.select()
    .from(auditLogs)
    .where(eq(auditLogs.success, 0))
    .orderBy(desc(auditLogs.timestamp))
    .limit(limit);
}

async exportAuditLogs(startDate: Date, endDate: Date): Promise<string> {
  const logs = await this.getAuditLogs({ startDate, endDate, limit: 10000 });
  
  const csv = [
    'Timestamp,User ID,Action,Resource,Resource ID,Success,Error Message',
    ...logs.map(log => 
      `${log.timestamp?.toISOString()},${log.userId || ''},${log.action},${log.resource},${log.resourceId || ''},${log.success ? 'Yes' : 'No'},"${log.errorMessage || ''}"`
    )
  ].join('\n');
  
  return csv;
}

STEP 5: INITIALIZE AUDIT LOGGER IN ROUTES

5. UPDATE FILE: server/routes.ts

Add at top after imports:

import { AuditLogger } from './lib/auditLogger';

const auditLogger = new AuditLogger(storage);

STEP 6: ADD AUDIT LOGGING TO EXISTING ROUTES

6. UPDATE FILE: server/routes.ts

Add audit logging to critical operations:

// Example: After updating feature flag
app.put('/api/admin/feature-flags/:flagName', isAdmin, async (req, res) => {
  try {
    const { flagName } = req.params;
    const { enabled } = req.body;
    const adminAddress = req.headers['x-wallet-address'] as string;
    
    const oldFlag = await storage.getFeatureFlags();
    const oldValue = oldFlag.find(f => f.flagName === flagName)?.enabled || false;
    
    await storage.updateFeatureFlag(flagName, enabled);
    
    await auditLogger.logFeatureFlagChange(adminAddress, flagName, oldValue, enabled, req);
    
    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Add similar audit logging to:
// - Ban/unban users
// - Delete proposals
// - Cancel proposals
// - Update pool tracker settings
// - Force delist NFTs
// - Cancel offers
// - Treasury withdrawals

STEP 7: ADD AUDIT LOG API ENDPOINTS

7. UPDATE FILE: server/routes.ts

Add:

app.get('/api/admin/audit-logs', isAdmin, async (req, res) => {
  try {
    const { userId, action, resource, startDate, endDate, limit } = req.query;
    
    const logs = await storage.getAuditLogs({
      userId: userId as string,
      action: action as string,
      resource: resource as string,
      startDate: startDate ? new Date(startDate as string) : undefined,
      endDate: endDate ? new Date(endDate as string) : undefined,
      limit: limit ? parseInt(limit as string) : 100,
    });
    
    res.json({ logs });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/audit-logs/user/:userId', isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const logs = await storage.getAuditLogsByUser(userId);
    res.json({ logs });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/audit-logs/failed', isAdmin, async (req, res) => {
  try {
    const logs = await storage.getFailedTransactions();
    res.json({ logs });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/audit-logs/export', isAdmin, async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate required' });
    }
    
    const csv = await storage.exportAuditLogs(
      new Date(startDate as string),
      new Date(endDate as string)
    );
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=audit-logs.csv');
    res.send(csv);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

STEP 8: ADD AUDIT LOG VIEWER TO ADMIN DASHBOARD

8. UPDATE FILE: client/src/components/AdminDashboard.tsx

Add this component:

const AuditLogViewer = () => {
  const [logs, setLogs] = useState<any[]>([]);
  const [filter, setFilter] = useState({ resource: '', action: '', userId: '' });
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    fetchLogs();
  }, []);
  
  const fetchLogs = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (filter.resource) params.append('resource', filter.resource);
      if (filter.action) params.append('action', filter.action);
      if (filter.userId) params.append('userId', filter.userId);
      params.append('limit', '100');
      
      const res = await fetch(`/api/admin/audit-logs?${params}`);
      const data = await res.json();
      setLogs(data.logs);
    } catch (error) {
      console.error('Failed to fetch logs:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const exportLogs = async () => {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const params = new URLSearchParams({
      startDate: thirtyDaysAgo.toISOString(),
      endDate: new Date().toISOString(),
    });
    
    window.open(`/api/admin/audit-logs/export?${params}`, '_blank');
  };
  
  return (
    <div className="p-6 bg-black/40 border border-purple-500/30 rounded-xl">
      <h3 className="text-xl font-bold mb-4">ðŸ“œ Audit Logs</h3>
      
      <div className="grid grid-cols-3 gap-2 mb-4">
        <input
          type="text"
          placeholder="Filter by resource"
          value={filter.resource}
          onChange={(e) => setFilter({ ...filter, resource: e.target.value })}
          className="px-3 py-2 bg-black/60 border border-purple-500/30 rounded text-white"
        />
        <input
          type="text"
          placeholder="Filter by action"
          value={filter.action}
          onChange={(e) => setFilter({ ...filter, action: e.target.value })}
          className="px-3 py-2 bg-black/60 border border-purple-500/30 rounded text-white"
        />
        <input
          type="text"
          placeholder="Filter by user ID"
          value={filter.userId}
          onChange={(e) => setFilter({ ...filter, userId: e.target.value })}
          className="px-3 py-2 bg-black/60 border border-purple-500/30 rounded text-white"
        />
      </div>
      
      <div className="flex gap-2 mb-4">
        <Button onClick={fetchLogs} disabled={loading}>
          {loading ? 'Loading...' : 'Refresh'}
        </Button>
        <Button onClick={exportLogs} variant="outline">
          Export CSV
        </Button>
      </div>
      
      <div className="max-h-96 overflow-y-auto space-y-2">
        {logs.map((log) => (
          <div key={log.id} className={`p-3 rounded border ${
            log.success ? 'border-green-500/30 bg-green-500/10' : 'border-red-500/30 bg-red-500/10'
          }`}>
            <div className="flex justify-between items-start mb-1">
              <span className="font-bold text-sm">{log.action}</span>
              <span className="text-xs text-gray-400">
                {new Date(log.timestamp).toLocaleString()}
              </span>
            </div>
            <div className="text-sm text-gray-300">
              Resource: {log.resource} {log.resourceId && `(${log.resourceId})`}
            </div>
            {log.userId && (
              <div className="text-xs text-gray-400">User: {log.userId}</div>
            )}
            {!log.success && log.errorMessage && (
              <div className="text-xs text-red-400 mt-1">Error: {log.errorMessage}</div>
            )}
            {log.ipAddress && (
              <div className="text-xs text-gray-500">IP: {log.ipAddress}</div>
            )}
          </div>
        ))}
        
        {logs.length === 0 && (
          <div className="text-center text-gray-400 py-8">No logs found</div>
        )}
      </div>
    </div>
  );
};

Then add <AuditLogViewer /> to the dashboard render.

STEP 9: ADD TRANSACTION RECEIPT LOGGER TO CLIENT

9. UPDATE FILE: client/src/lib/receiptLogger.ts

Enhance with more detail:

export async function logTransactionReceipt(data: {
  walletAddress: string;
  transactionType: string;
  transactionHash: string;
  amount?: string;
  tokenId?: number;
  fromAddress?: string;
  toAddress?: string;
  platformFee?: string;
  royaltyFee?: string;
  netAmount?: string;
  metadata?: any;
}) {
  try {
    await fetch('/api/transactions/receipt', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...data,
        metadata: data.metadata ? JSON.stringify(data.metadata) : undefined,
        status: 'pending',
        createdAt: new Date().toISOString()
      })
    });
  } catch (error) {
    console.error('[RECEIPT] Failed to log:', error);
  }
}

STEP 10: VERIFY EVERYTHING

10. TEST:

Run in terminal:
npm run db:push

Then test:
1. Open Admin Dashboard
2. Find Audit Log Viewer
3. Should see empty state or existing logs
4. Perform an admin action (toggle feature flag)
5. Refresh audit logs
6. Should see new entry
7. Click "Export CSV"
8. Should download CSV file
9. Apply filters (resource, action, userId)
10. Should filter results

Run query in database:
SELECT * FROM audit_logs ORDER BY timestamp DESC LIMIT 10;

Should see audit log entries.

VERIFICATION COMPLETE:
âœ… All financial operations now logged
âœ… Complete audit trail with IP tracking
âœ… Admin dashboard viewer
âœ… CSV export capability
âœ… Forensic debugging enabled
âœ… Compliance-ready

This creates an immutable audit trail for all critical operations.